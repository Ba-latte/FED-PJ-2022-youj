// 쇼핑몰 배너 JS - 01.가로방향 배너 슬라이드 //

// HTML태그 로딩후 loadFn함수 호출! ///
window.addEventListener("DOMContentLoaded", loadFn);

/***************************************************** 
    [ 슬라이드 이동 기능정의 ]
    1. 이벤트 종류: click
    2. 이벤트 대상: 이동버튼(.abtn)
    3. 변경 대상: 슬라이드 박스(#slide)
    4. 기능 설계:

        (1) 오른쪽 버튼 클릭시 다음 슬라이드가
            나타나도록 슬라이드 박스의 left값을
            -100%로 변경시킨다.
            -> 슬라이드 이동후!!! 
            바깥에 나가있는 첫번째 슬라이드
            li를 잘라서 맨뒤로 보낸다!
            동시에 left값을 0으로 변경한다!

        (2) 왼쪽버튼 클릭시 이전 슬라이드가
            나타나도록 하기위해 우선 맨뒤 li를
            맨앞으로 이동하고 동시에 left값을
            -100%로 변경한다.
            그 후 left값을 0으로 애니메이션하여
            슬라이드가 왼쪽에서 들어온다.

        (3) 공통기능: 슬라이드 위치표시 블릿
            - 블릿 대상: .indic li
            - 변경 내용: 슬라이드 순번과 같은 순번의
            li에 클래스 "on"주기(나머진 빼기->초기화!)

*****************************************************/

/****************************************** 
    함수명: loadFn
    기능: 로딩 후 버튼 이벤트 및 기능구현
******************************************/

function loadFn() {
    // 0.호출 확인
    console.log("로딩 완료!");

    // 💕슬라이드 li리스트
    let slist = document.querySelectorAll("#slide>li");
    // : 잘라내기로 li순번이 뒤섞이므로 블릿 변경 매칭을 위한 고유한 순번을 '사용자정의' 속성(data-)으로  만들어주기!!

    slist.forEach((ele, idx) => {
        // data-seq 라는 사용자정의 속성을 만들어서 집어넣기
        ele.setAttribute("data-seq", idx);
    }); ////// forEach ///////////

    // 1.대상 선정
    // 1-1.이벤트 대상 : .abtn
    const abtn = document.querySelectorAll(".abtn");
    // console.log(abtn);
    // 1-2.변경 대상 : #slide
    const slide = document.querySelector("#slide");
    // 1-3.블릿 대상 : .indic
    const indic = document.querySelectorAll(".indic li");
    // console.log(indic);

    // 🍓4-1.광클 금지 변수 만들기
    let prot = 0;
    // : 0 - 허용 / 1 - 불허용
    // : 함수 바깥에 만들어서 상대적으로 전역변수로 만들고, 공간을 확보함

    // 2.슬라이드 변경 함수 만들기 - 할당형 함수로 만들기
    // 호출시 seq에 들어오는 값 중에서 1은 오른쪽, 0은 왼쪽임!!
    const goSlide = (seq) => {
        // 확인
        // console.log("슬라이드고우!", seq);

        // 🍓4.광클 금지 설정하기
        // : 계속 쉼없이 클릭하면 이미지가 버벅거리면서 잘 안넘어가진다! 그걸 방지하기 위함!!
        // how)방문 잠그고 못들어오게 해주면 됨! -> 못들어가 돌아가! -> 리턴!
        // console.log("못들어갔어!!!!!");
        // 🍓4-2.광클금지 설정하기
        if (prot) return;
        prot = 1;
        // if문으로 제어해서 한명만 들어가구 바로 방문을 잠가버려!
        // console.log("난 들어왔어!!!");
        // 정해진 시간이 지난 후 (슬라이드 넘어가는 트랜지션 시간이 지난 후), 다시 방문 열어주기!
        setTimeout(() => {
            prot = 0;
            // 방문 열어주기!
        }, 400);
        // tip) 그리고 시간같은건 바뀔 수 있으니까 변수로 처리해주면 더 굿굿~!

        // 2-0.현재의 슬라이드 li 수집하기
        let clist = slide.querySelectorAll("li");
        // : clist : current list 현재 리스트 의미함

        // 2-1. 방향에 따른 분기
        // 2-1-1. 오른쪽 버튼 클릭시 : seq===1
        if (seq) {
            // 확인
            // console.log("오른!");

            // (1) 오른쪽 버튼 클릭시 다음 슬라이드가
            // 나타나도록 슬라이드 박스의 left값을
            // -100%로 변경시킨다.
            slide.style.left = "-100%";
            // 📢->> 딱 한번만 이동하게 세팅해두기
            slide.style.transition = "left .4s ease-in-out";

            // (2) 슬라이드 이동후!!!
            setTimeout(() => {
                // : 0.4초 지나고 슬라이드가 이동한 후 말함

                // (2-1)바깥에 나가있는 첫번째 슬라이드 li를 잘라서 맨뒤로 보낸다!
                slide.appendChild(clist[0]);

                // (2-2)동시에 left값을 0으로 변경한다!
                slide.style.left = "0";

                // (2-3)밖의 첫번째 li를 잘라서 맨뒤로 보내면서 동시에 left값을 0으로 바꾸는걸...이렇게 움직이는 걸 굳이 보여줄 필요 없기 때문에 트랜지션을 없애주면 됨
                slide.style.transition = "none";
            }, 400); /////////////////// 타임 아웃 끝 ///////////////////
        } ////////////////////// if문 : 오른쪽 클릭시 /////////////////////////////

        // 2-1-2. 왼쪽 버튼 클릭시 : seq===0
        else {
            // 확인
            // console.log("왼!");

            // (1) 왼쪽버튼 클릭시 이전 슬라이드가 나타나도록 하기위해 우선 맨뒤 li를 맨앞으로 이동한다
            // slide.insertBefore(넣을놈, 넣을놈전놈);
            // slide.insertBefore(맨끝 li, 맨앞 li);
            slide.insertBefore(clist[clist.length - 1], clist[0]);

            // (2) 동시에 left값을 -100%로 변경한다.
            slide.style.left = "-100%";
            // : 안 튀게 만들기 위함
            // ->>이때 트랜지션도 없애줘야, 바깥쪽에서는 트랜지션이 없어서 팍팍 튀지 않는다;;
            // (처음에만 없지, 한번 실행후부터는 생기므로.....)
            slide.style.transition = "none";

            // (3) 그 후 left값을 0으로 애니메이션하여 슬라이드가 왼쪽에서 들어온다.
            // slide.style.left = "0";
            // : 이렇게 해두면 너무 빛으 속도로...해서.. 변함이 없어보여;; 그래서 코딩공간을 구분하면! 그러면 조금이라도 시차가 생김!! -> 이때 사용하는 게 setTimeout이래!
            // 📢📢쌤왈: 동일 속성인 left가 같은 코딩 처리 공간에서 동시에 있으므로, 이것을 분리해야 효과가 있다! 이때 쓰는게 setTimeout임!!
            setTimeout(() => {
                slide.style.left = "0";
                slide.style.transition = "left .4s ease-in-out";
            }, 0); ///////////////////// 타임 아웃 ////////////////////////////
        } //////////////////////// else문 : 왼쪽 클릭시 //////////////////////////////////

        // 5.현재 슬라이드 순번과 같은 불릿 표시하기
        // 대상 : .indic li -> indic 변수
        // indic[순번].classList.add("on")
        // 현재 순번을 모르겠으니까 ㅋㅋㅋ 현재 순번 콘솔에 찍어보기
        // 5-1.현재 배너 리스트 업데이트 하기!!
        clist = slide.querySelectorAll("li");
        // 오른쪽 클릭시 두번째 슬라이드[1] -> 즉 (seq===1)
        // 왼쪽 클릭시 첫번째 슬라이드[0] -> 즉 (seq===0)
        // ->>>>> seq순번과 읽어올 슬라이드의 순번이 일치한다!!

        // 5-2.방향별로 읽어올 슬라이드를 순번으로 "data-seq"값 읽어오기
        let cseq = clist[seq].getAttribute("data-seq");
        // console.log("현재 순번: ", cseq);

        // 5-4.블릿 초기화하기
        for (let x of indic) x.classList.remove("on");

        // 5-3.읽어온 슬라이드 순번의 블릿에 클래스 "on"넣기
        indic[cseq].classList.add("on");

        // (추가!!) 불릿 클릭시 이동 현재 순번 변수(iseq)에 일치시키기!
        iseq = Number(cseq);
        // cseq는 string이라서 숫자형으로 바꿔주면 굿굿,,!! 숫자로 형변환은 Number()임!!

    }; //////////////// goSlide 함수 끝 /////////////////////

    // 3.대상에 이벤트 설정하기
    // : abtn버튼 클릭하면 슬라이드 넘어가는 함수 호출해서 실행하기!!
    abtn.forEach((ele, idx) => {
        ele.onclick = () => {
            // 😊인터발 지우기 함수 호출!!
            // clearAuto();

            // 😊슬라이드 함수 호출!!
            goSlide(idx);
        }; //////////// onclick 끝 ///////////////
    }); //////////////////////// forEach 끝 /////////////////////////////

    ///////////////////////////////////////////////////
    // 😊자동 넘김 설정하기 ////////////////////////////
    ///////////////////////////////////////////////////
    // 자동넘김 : 일정 시간 간격으로 넘어가기
    // ->setInterval(함수, 시간) 사용하면 됨
    // setInterval(goSlide(1),3000);
    // ->전달변수가 있다면 함수명()이렇게 쓰면 안 됨! 함수에 소괄호()가 붙는 순간 바로 실행됨!!
    // ->>전달변수가 있다면~ 익명함수에 담아서 보내야 함

    // [ 인터발 함수의 함수전달값 사용 예 +타임아웃 함수도 동일함!!]
    // 1. 함수에 전달값이 없으면 함수명만 사용 가능
    // setInterval(goSlide, 3000);
    // 2. 전달값이 있다면 익명함수구역에 코딩
    // setInterval(function(){goSlide(1)}, 3000);
    // 3. 화살표함수 사용가능
    // setInterval(()=>{goSlide(1)}, 3000);
    // 4. 화살표함수에서 중괄호 생략 가능
    // setInterval(()=>goSlide(1), 3000);

    // 나는 반대쪽을 건들고있는데, 자동넘김이 되면 둘이 충돌하는거임!
    // 이런거 방지하기 위해서.. 내가 건들고 있을 때는 너는 자동넘김 멈춰! 함수를 만들어서 호출해주면 됨!

    // 😊0.인터발 함수 멈추기 위한 변수 만들기
    let autoI;
    // : 값이 왔다갔다하니까 상수 안돼!
    // 😊4.타임아웃 함수 지우기 위한 변수
    let autoT;

    // 😊1.오토슬라이드 함수 만들기
    /*************************************************************
        함수명 : autoSlide
        기능 : 인터발 함수로 슬라이드 함수 호출하기
    *************************************************************/
    function autoSlide() {
        // 호출 확인
        console.log("인터벌 시작!");

        // 인터발 함수로 슬라이드 함수 호출하기
        autoI = setInterval(() => goSlide(1), 3000);
        // : 넘어가는 함수를 시간 지정해서 지정된 시간이 끝나면 넘어가도록하되, 바로 실행되지는 않도록 익명함수에 담아서 autoI변수에 담기! (오토아이라는 공간에 담아 두면 얘의 주소가 특정하게 잡히니까! 그래야 얘를 마음대로 부를 수 있음)
    } /////////////////////////// autoSlide 함수 끝 ///////////////////////////

    // 😊2.자동넘김 최초 호출하기
    // autoSlide();

    // 😊3.멈추기 함수 만들기
    /***********************************************************************
        함수명 : clearAuto
        기능 : 인터발 함수를 지우고 다시 세팅하도록 만들기
    ***********************************************************************/
    function clearAuto() {
        // 호출 확인
        console.log("인터발 멈춰!");

        // 3-1.인터발 지우기
        clearInterval(autoI);

        // 3-3.타임아웃도 지우지 않으면! 그대로 쌓여서.. 타임아웃이 쓰나미처럼... 갑자기 막 실행된다ㅠ
        // ->따라서 지워줘야하는데, 그럼 얘도 변수에 담아서 특정 주소값을 줘야한다...!
        clearTimeout(autoT);

        // 3-2.잠시후 다시 작동하도록 타임아웃으로 인터발함수를 호출한다!!
        autoT = setTimeout(autoSlide, 5000);
        // : 5초후(인터발을 3초 후니까... 토탈 8초 후 작동 시작함)
    } //////////////////////////// clearAuto 함수 끝 ///////////////////////////////////

    /***************************************************
        [ 불릿 클릭 이동 구현하기 ]
    1.오른쪽 이동시 : 현재 불릿보다 오른쪽 클릭시
        1)기본형 : 오른쪽 버튼 클릭 구현
        2)유형 : 먼저 이동 후 맨 앞요소 맨뒤로 보내기
        3)원리 : 차이수만큼 %이동 후 for문으로 잘라서 순서대로 맨뒤로 이동

    2.왼쪽 이동시 : 현재 불릿보다 왼쪽 클릭시
        1)기본형 : 왼쪽 버튼 클릭기능 구현
        2)유형 : 먼저 맨 뒤에 있는 요소를 맨앞으로 이동 후 들어오기
        3)원리 : 차이수만큼 앞에 for문으로 쌓은 후, 이동하기

    3.방향구분의 기준 : 클릭된 불릿 순번 - 현재 불릿 순번
        1)양수가 나올 경우 : 오른쪽으로 이동
        2)음수가 나올 경우 : 왼쪽으로 이동
    
    ***************************************************/

    // 대상 : .indic li -> indic변수
    // 이벤트 : 클릭 이벤트
    // 순번을 담을 변수 만들기 : 처음엔 무조건 맨 처음슬라이드가 보이니까, 맨 처음 슬라이드의 인덱스번호는 0임
    // 클래스리스트.컨테인스"on"으로 무조건 찾을 필요 없음1 요기서는 맨처음에 온이 들어간 li가 뭔지 아니까
    // =>> 함수 바깥에 변수를 만든 이유 : 공용으로... 함수내에서 바뀌는 그런 내용들이 바로바로 업데이트돼서 적용되는거..확인용..??
    // ->>>>>
    let iseq = 0;

    // indic.forEach((ele,idx)=>{ ////// ele : 요소 / idx : 순번
    //     // 클릭 이벤트 설정하기
    //     ele.onclick = ()=>{
    //         // 1.클릭된 순번 담을 변수
    //         let cseq
    //         // 2.현재 순번 : iseq변수
    //         // 3.순번차 : 클릭된 순번 - 현재 순번
    //         let diff = cseq - iseq;

    //         console.log("클릭된 순번: ",cseq);
    //         console.log("현재 순번: ",iseq);
    //         console.log("순번 차이: ",diff);

    //         // 4.방향별 슬라이드 이동하기
    //         // 4-1.양수면 오른쪽
    //         if(diff<0){

    //         } /////////////////

    //         // 5. 현재불릿 초기화
    //         indic[iseq].classList.remove("on");

    //         // 6.클릭된 순번으로 현재순번 변경
    //         iseq = cseq;

    //         // 7.클릭된 부릿에 on넣기
    //         indic[iseq].classList.add("on");

    //     }; /////////////// click //////////////////
    // }); //////////////// forEach /////////////////////

    indic.forEach((ele, idx) => {
        // 클릭이벤트 설정하기
        ele.onclick = () => {
            // 1. 클릭된 순번
            let cseq = idx;
            // 2. 현재 순번 - iseq
            // 3. 순번차 : 클릭된 순번 - 현재 순번
            let diff = cseq - iseq;
            // 순수값 차이 -> 절대값 : Math.abs() 쓰면 된다!
            let pure = Math.abs(diff);
            // : 이렇게하면 어떻게하든지 순수하게 양수값만 나옴

            console.log("클릭된순번: ", cseq);
            console.log("현재순번", iseq);
            console.log("순번차: ", diff);
            console.log("순수한 차이값: ", pure);

            // 4. 방향별 슬라이드 이동하기
            // 4-1.양수면 오른쪽 /////////////////
            if (diff > 0) {
                //  console.log("오른!");
                // (1) 오른쪽 버튼 클릭시 다음 슬라이드가
                //     나타나도록 슬라이드 박스의 left값을
                //     (-100% * 순수차)로 변경시킨다.
                slide.style.left = -100 * pure + "%";
                slide.style.transition = "left .4s ease-in-out";

                // // (2) 슬라이드 이동후!!! (0.4초후)
                setTimeout(() => {
                    // for문으로 자를 수(순수값)만큼 순서대로 처리하기!
                    // 계산되는 차이수 : 1씩 감소하여 left값에 계산시킴!!
                    let temp = pure;
                    // 임시변수에 넣은 이유: pure는 건들면 안되니까! 근데 pure의 값을 바꿔야하니까;; 그래서 다른곳에 옮겨담고 그 다른것을 바꾸는것임

                    for (let i = 0; i < pure; i++) {
                        // temp 1씩 감소하기!
                        temp--;

                        // (2-1) 바깥에 나가있는 첫번째 슬라이드
                        //       li를 잘라서 맨뒤로 보낸다!
                        // : 슬라이드 li가 잘라내면 매번 변경되므로, 새로 읽어서 맨 뒤로 이동한다
                        slide.appendChild(slide.querySelectorAll("li")[0]);
                        // ->>슬라이드이 첫번째 요소가 매번 바뀌기 때문에! 계속 쿼리셀렉터올로 계속해서 새로 선택해와야함!
                        // (2-2) 동시에 left값을 0으로 변경한다! : 잘라낸거 끝에다가 붙이기...
                        slide.style.left = -100 * temp + "%";
                        // (2-3) 트랜지션 없애기!
                        slide.style.transition = "none";
                    } ////////////////// for문 //////////////////////
                }, 400); //// 타임아웃 //////
            } //////////////// if ///////////////////
            // 4-2.음수면 왼쪽 ///////////////////
            else if (diff < 0) {
                // 확인
                // console.log("왼!");

                
                // (1) 왼쪽버튼 클릭시 이전 슬라이드가 나타나도록 하기위해 우선 맨뒤 li를 맨앞으로 이동한다. -> 개수만큼 처리한다(pure: 순수차이값)
                // slide.insertBefore(넣을놈, 넣을놈전놈);
                // slide.insertBefore(맨끝 li, 맨앞 li);

                for(let i = 0; i < pure; i++){
                    
                    // 이동할 리스트 : 매번 li순서가 바뀌니까! for돌때마다 새로이 찾아서 선택해야 하니까 for문 안에서 변수 선언해야함
                    let clist = slide.querySelectorAll("li");

                    // (2) 동시에 left값을 -100% 단위로 변경한다.
                    // i값이 0부터 반복횟수만큼 증가하므로, 이것을 이용했다!

                    slide.style.left = ((i+1)*-100)+"%";
                    // : 안 튀게 만들기 위함
                    // ->>이때 트랜지션도 없애줘야, 바깥쪽에서는 트랜지션이 없어서 팍팍 튀지 않는다;;
                    // (처음에만 없지, 한번 실행후부터는 생기므로.....)

                    slide.insertBefore(clist[clist.length - 1], clist[0]);
                    
                } //////////////////// for //////////////////
                

                slide.style.transition = "none";
                // (3) 그 후 left값을 0으로 애니메이션하여 슬라이드가 왼쪽에서 들어온다.
                // slide.style.left = "0";
                // : 이렇게 해두면 너무 빛으 속도로...해서.. 변함이 없어보여;; 그래서 코딩공간을 구분하면! 그러면 조금이라도 시차가 생김!! -> 이때 사용하는 게 setTimeout이래!
                // 📢📢쌤왈: 동일 속성인 left가 같은 코딩 처리 공간에서 동시에 있으므로, 이것을 분리해야 효과가 있다! 이때 쓰는게 setTimeout임!!
                setTimeout(() => {
                    slide.style.left = "0";
                    slide.style.transition = "left .4s ease-in-out";
                }, 0); ///////////////////// 타임 아웃 ////////////////////////////


            } //////////////// else if ///////////////////
            // 4-3.0이면 나가기!
            else {
                return;
            }

            // 5. 현재 변경블릿 초기화
            indic[iseq].classList.remove("on");

            // 6. 클릭된 순번으로 현재순번 변경
            iseq = cseq;

            // 7. 클릭된 블릿에 on넣기
            indic[iseq].classList.add("on");
        };
    });
} //////////////// loadFn 함수 ///////////////
/////////////////////////////////////////////
