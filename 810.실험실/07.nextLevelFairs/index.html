<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>넥스트 레벨 페어스 클론 코딩</title>
    <link rel="stylesheet" href="./index.css">
</head>
<body>
    <div class="cursor">
        <!-- 항상 따라다니는 기본값 -->
        <div class="cursor_default">
            <span class="cursor_default_inner"></span>
        </div>
        <!-- 뒤에 따라 오는 배경 원 -->
        <div class="cursor_trace">
            <span class="cursor_trace_inner"></span>
        </div>
    </div>
    <!-- 일정 시간 눌러야 동작하는 버튼 구현하기 -->
    <section class="preloader shown-area">
        <button class="preloader_btn">
            <span class="preloader_btn_hold">Hold</span>
        </button>
    </section>

    <!-- 동작하는 버튼이 없어진 다음에 보여줄 영역 -->
    <section class="header hidden-area">
        Header
    </section>
</body>

<script>
    document.addEventListener("mousemove", (event)=>{
        // console.log(event);
        // console.log("x : ", event.clientX, " / y : ", event.clientY);
        
        const cursorDefaultInner = document.querySelector(".cursor_default_inner");
        const cursorTraceInner = document.querySelector(".cursor_trace_inner");
        
        // clientX, Y를 가지고 cursor_default_inner의 스타일 변경하기
        cursorDefaultInner.style.top = event.clientY + "px";
        cursorDefaultInner.style.left = event.clientX + "px";

        // clientX, Y를 가지고 cursor_trace_inner의 스타일 변경하기
        cursorTraceInner.style.top = event.clientY + "px";
        cursorTraceInner.style.left = event.clientX + "px";

    })


    // [ 클래스를 줘서 scale이 작았다 커지게 만듦으로써 애니메이션 부여하기 ]
    const cursor = document.querySelector(".cursor");

    document.addEventListener("mousedown", ()=>{
        cursor.classList.add("cursor--active");
    });

    document.addEventListener("mouseup", ()=>{
        cursor.classList.remove("cursor--active");
    });

    // [ 클릭하면 물결처럼 퍼지는 원 등장하기 ]
    function createRipple(event){
        let ripple = document.createElement("span");
        
        // 클래스 부여해서 애니메이션 주기
        ripple.classList.add("ripple");
        
        // DOM에 만든 요소 집어 넣기
        cursor.appendChild(ripple);

        // 마우스 커서 위치로 포지션 잡기
        ripple.style.top = (event.clientY - (ripple.clientHeight / 2)) + "px";
        ripple.style.left = (event.clientX - (ripple.clientWidth / 2)) + "px";

        // 만들어낸 요소 없애기
        ripple.addEventListener("animationend", ()=>{
            cursor.removeChild(ripple);
        });
    }

    document.addEventListener("click", ()=>{
        // 물결처럼 퍼지는 원 만드는 함수 호출
        createRipple(event);
    })


    // [ 일정시간 눌러야 동작하는 버튼 구현하기 ]
    const preloaderBtn = document.querySelector(".preloader_btn");

    // 계속 누르고 있는지 반복해서 물어봐서 얻어온 결과 담을 변수 만들기 : 돌고 있는 인터벌의 고유한 아이디를 가지고 있게 하기
    let intervalId = null;

    // 버튼 크기값 담을 변수 만들기
    let scale = 1;

    // 스케일이 어디까지 커질 것인지 한계값 만들기
    const preloaderHideThreshold = 18;

    // preloader 버튼에 스타일 설정하는 함수 만들기
    function setPreloaderStyle(scale){
        // scale값을 인자로 받아와서 스타일 바꾸기
        preloaderBtn.style.transform = `scale(${scale})`;
        
        // 스케일이 커지면 hold 텍스트 연해지게 만들기 : scale이 1일때 투명도도 1이어야하고, scale이 커지면 투명도도 1보다 작아져야 하는데! 한계값을 넘어서지 않게 하기
        document.querySelector(".preloader_btn_hold").style.opacity = 1 - (scale - 1) / preloaderHideThreshold;

    }

    // 마우스 누르고 있는 이벤트에서 함수 호출하기
    preloaderBtn.addEventListener("mousedown", ()=>{
        // console.log("마우스 다운!");

        // 인터벌아이디에 setInterval 돌리기 : 매 10밀리초 마다 돌기
        intervalId = setInterval(()=>{
            console.log("버튼 크기 커지는 인터벌");

            // 매 10밀리초 돌 때마다 scale을 0.175배 증가시키기
            scale += 0.175;

            // preloader 스타일 바꾸는 함수 호출하기
            setPreloaderStyle(scale);

            // scale이 정해둔 한계값을 넘어가면 보여지던 preloader영역을 숨기고 header영역을 보이게 만들기
            // (이때 1 더한 것은 기본값에 한계값을 더한다는 의미로, 1을 쓰지 않고 threshold값을 19로 만들어도 됨 )
            if(scale >= (1 + preloaderHideThreshold)){
                const header = document.querySelector(".header");

                document.querySelector(".preloader").classList.add("hidden-area");

                header.classList.remove("hidden-area");
                header.classList.add("show-area");

                // scale이 1을 넘어섰으므로 더 커질 필요 없어서 인터벌 중지시키기
                clearInterval(intervalId);
            }
        }, 10);
    });

    // 마우스를 뗐을 때 다시 작아지도록 만들기
    preloaderBtn.addEventListener("mouseup", ()=>{
        // console.log("마우스 업!");

        // 반복해서 돌도록 만든 인터벌 함수를 지워서 리셋시키기
        clearInterval(intervalId);

        // 버튼 크기 줄이는 인터벌 만들기
        intervalId = setInterval(()=>{
            console.log("버튼 크기 줄어드는 인터벌");

            scale -= 0.075;

            setPreloaderStyle(scale);

            // scale값이 음수가 되면 요소가 뒤집어지므로 1을 한계값으로 하여 멈추게 만들기
            if(scale <= 1) clearInterval(intervalId);
        }, 10);

    });
</script>
</html>


<!--

    [ 넥스트 레벨 페어스 클론 코딩 ]

[ CSS cursor ]
-요소 위에 마우스를 올릴 때 (hover)의 커서 모양을 변경
-특정 아이콘을 설정 가능

1. 속성
-pointer: 손 아이콘
-default : 브라우저 기본 커서
-url(image) : image로 custom된 커서
-기타 다른 속성은 mdn 참고!

2.문법
-cursor: url(....), auto;


3.우리가 할일
-별도의 커서 레이어를 만들 것임
-z인덱스 설정함

-커서가 따라오는 포지션의 위치에 우리가 만든 어떤 요소를 계속 배치하여 커서처럼 보이게 만들 계획


-마우스움직임을 이벤트 리스너로 달면 움직일때마다 이벤트 발생하지만 그 프레임률만큼 따라갈 수 없음...그래ㅓㅅ 중간중간 이벤트 발생해ㅓㅅ 중간중간 따라오게 됨
->그래서 계속해서 이벤트 발생해서 부드럽게 따라오게 하려면 조금 더 깊게 들어가야 함
->자스의 리퀘스트애니메이션 프레임이라는 속성을 사용해야 거의 매 움직임마다 따라올 수 있으나 성능 저하 이슈가 있을 수 있음...
->좀더 부드러운 애니메이션이 구현 가능하긴 함,.,

궁금증) 왜 클래스 이름붙일때 --을 썼을까??



[ 물결 애니메이션 넣기 ]
1.원리
-새로운 요소를 추가하고, 그 요소에 물결처럼 퍼지는 애니메이션을 넣기
-애니메이션이 끝나면 요소 없애기

2.과정
-자스에서도 요소 만들기 가능 : document.createElement
-자스에서 자식 요소 지우기 : removeChild(지울요소)




[ 일정 시간 이상 눌러야 동작하는 버튼 제작 ]
1.웹에서 흔히 있는 패턴
-유저가 실수로 눌렀을 때 원치않는 액션 수행하지 않기 위해서 사용됨
(조금 더 누른 상태로 있어야 다음 진행되는 것들)
-유저의 미스클릭을 줄이기 위함

2.JavaScript setInerval()
-특정 간격의 시간(밀리초)에 맞춰 반복하여 특정 함수를 동작하게 함
-inerval의 동작을 멈추려면 clearInterval()함수 사용
-JS native 함수임

-문법 예시
sestInterval(myFunction, 1000); // 매 1000 밀리초마다 myFunction을 동작시킴

let inervalId = setInterval(myFunction, 1000); // unique ID를 return함
clearInterval(intervalId); // setInterval()의 결과값(여기서는 uniqe ID)을 인자로 받음

-시계만들때 (1초에 한번씩 불러와서 시간 초 흐르는 것처럼 만들기)
-새 채팅이 오면 빨간 점이 떠서 채팅이 있는 것을 알려야한다, 이런식의 실시간 소통을 위함
-그 화면에 있지 않으면 채팅이 있는지 없는지를 확인하려면 서버에 계속 물어봐야함
-이런식으로 계속 반복적인 일을 할 때에 사용함

-우리는 여기에서 여전히 누르고있나? 얼마나 누르고있나? 이런 것을 얻어오려고 함
-그래서 누른 상태로 몇 초이상 혹은 지표가 어느정도 커졌을 때까지 확인하기 위해 계속 물어보려고 사용할 예정

-필요 없을 때엔 그만 반복하도록 멈추게 해야함. 이때 클리어 인터벌을 사용해서 멈추게 해야함


**중요한 점
1.엄밀한 시간 정확도를 보장하지 않음 = 항상 정확한 시간 아님
-브라우저와 컴퓨터 성능에 따라 다를 수 있음
-자스는 스케줄러처럼 도는 게 있는데 그 주기적인 도는 스케줄에 맞을 때만 돌기 때문에..즉 자스는 싱글스레드언어라서 한번에 하나만 수행할 수 있기 때문에... 1초가 돌았냐 하는 것을... 다른 일을 수행하느라 조금 느리게 1초 도는 일을 느리게 수행할 수 있다는 뜻임
ex) let inervalId = setInterval(myFunction, intervalTime);

2.setTimeout과 조합하여 시간 흐름에 따른 함수 실행을 만들기도 함
ex) timeoutId = setTimeout(myFunction, timeout); // timeout 밀리초만큼 기다린 후 myFunction을 실행함
clearTimeout(timeoutId);

setTImeout : 특정 시간 이후에 딱 한번말 실행시키는 함수
-보통 의도된 지연을 만들거나
화면이 나타나고 1초 뒤에 수행해 이런 것들
-클리어 타임아웃 함수와 함께 써서 몇초 뒤에 동작 멈추도록 해 이런식으로 활용함

-웹에서는 CSS 애니메이션이 인피니트를 하는데 그렇게 만들 수도 있고 자스로 매초마다 애니메이션 발생시킬수도 있음

-이 함수들은 자스 함수라서 대부분의 모던 브라우저들이 지원할 확률이 높음 즉 확장성, 범용성이 좋음



[ 일정시간 눌러야 동작하는 버튼 구현하기 ]
1.개념
-누르고 있을때 버튼이 커지고 마우스 클릭 뗐을 때 다시 버튼 작아지게 만들기


2.구현

1.버튼도 마냥 커지는 게 아니라 한계값이 되면 버튼 사라지게 만들기 : 클래스로 컨트롤
-처음에는 preloader가 보이는 영역이어야 하니까 .shown-area 부여
-한계값을 넘으면 preloader영역을 안보이게 숨기고 나머지를 보이게 만들기


-->