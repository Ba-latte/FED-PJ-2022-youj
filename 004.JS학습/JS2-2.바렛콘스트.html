<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS2-2. 바(var), 렛(let), 콘스트(const)</title>
    <script>
        /******************************************************************************
                변수는 바, 렛, 콘스트!!
        
            [ var ]
        -함수영역 변수
        1.함수영역에서 사용할 때만 지역변수
        2.함수영역 바깥에서 사용하면 전역변수
        3.전역변수와 같은 이름의 변수를 함수 내에서 값을 할당하면, 덮어쓰기가 된다
        4.함수 영역에서 전역변수와 같은 이름의 변수를 선언하면, 전역변수와 다른 지역변수로 관리된다
        (동명이인이 되는 것임!)
        이렇게 하면 코딩이 매우 혼란스러워 질 수 있지만 또는 변수 이름이 같은 이름이지만, 지역변수로 사용할 수 있다는 장점이 되기도 한다
        ______________________________________________________________________
            [ 지역변수 : Local Variable ]
        -함수영역 내에 선언한 변수를 말함
        -특징 : 다른 함수나 바깥(전역)영역에서 지역변수를 참조할 수 없음
        (즉, 사용할 수 없다)
        
            [ 전역변수 : Global Variable ]
        -함수 바깥 영역에서 선언한 변수
        -특징 : 어떤 함수에서도 전역변수를 참조할 수 있음
        ->>> 즉, 전역변수의 값도 변경할 수 있다!!!
        ->>> 전역변수는 공유하고자 하는 데이터를 저장할 때 사용
        ______________________________________________________________________

            [ let ]
        -블록영역 변수 (중괄호{}는 모두 블록임!)
        1.let으로 변수를 선언하면 전역과 지역을 별도로 관리하여, 같은 이름의 변수도 별개의 변수로 인식함
        2.let변수는 선언 후 아래쪽에서 사용해야만 한다! = 변수 호이스팅 금지
        ((비교 : var는 위에서 호출하고, 아래에서 선언할 수도 있다 -> '변수의 호이스팅'이라 함))
        -hoist (호이스트) : 끌어올리다라는 뜻
        3.같은 영역에서 같은 이름의 변수를 중복 선언할 수 없다
        ((비교 : var는 중복 선언하면 덮어쓴다 = 재선언 가능 ->단점으로 지적 받는 것 중 하나))

            [ const ]
        -상수(constant)는 '변하지 않는 값'을 말함
        1. 선언과 동시에 할당해야함
        2. 한번 할당한 값은 변경 불가함
        3. 따라서 배열과 객체, 함수를 상수로 만드는 경우가 많음
        -> 변경불가는 각 배열형, 객체형, 함수형 =>즉 '형'을 바꾸지 못한다는 의미
        -> 변경가능은 각 배열값, 객체값, 함수전달값
        4. 기타의 특징은 let과 동일함
        (블록단위변수임)
        
        ******************************************************************************/


        /////////////////////////////////////////////////////////////////////////////
        ///////////////////////////// var 테스트 ///////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////

        // JS에서 중괄호{}란? - 코드를 묶어주는 영역이다!


        // 1. 함수 중괄호{}에서 var ///////////////////////////////////////////////////////////////////////
        function callMe(){
            // 함수 내에서 변수를 선언하면 지역변수!
            var usa = "미국";

            console.log("3.함수 안 지역 usa : ", usa);
            
            // 함수 내에서 전역변수 korea 값변경하기
            korea = "코리아";
            
            console.log("4.함수 안 전역 korea : ", korea);

            // 함수 내에서 전역 uk 찍기
            console.log("5.함수 안 전역 uk : ", uk);
            // ->아래쪽에 같은 이름의 지역변수 uk를 만드는 순간! 선언한 줄 보다 윗 줄에 있어도! 이 변수는 지역변수로 취급된다!
            // ->>> 그래서 전역변수 uk와는 영영 이별하게 된다!!
            // 결과 : undefined => 지역 uk변수에 데이터 값이 할당되기 전에 출력됐다는 의미!
            // +++ "아랫줄에서 선언했는데 어떻게 윗줄에서 쓸 수 있지?" => '호이스팅(?)'이라는 기능이 적용돼서... 아랫줄에서 선언한 변수를 윗줄로 끌어와서 적용시킴... 이걸 개발자들이 너무 싫어함...!  이거때문에 프로그램이 꼬이는 일이 많음!!!! 이걸 못 하게 한 것이 바로 '렛, 콘스트'임

            // 전역변수에 선언된 uk변수와 같은 이름의 지역변수 만들기
            var uk = "유케이";
            console.log("6.함수 안 지역 uk : ", uk);

            // 선언한 적이 없는 변수를 바로 사용해보자!
            rabbit = "토끼";
            console.log("7.함수 안 선언없는 rabbit : ", rabbit);


        } ///////////// callMe 함수 끝 /////////////

        // 함수 바깥에서 변수를 선언하면 전역변수!
        var korea = "한국";
        var uk = "영국";
        
        console.log("1.함수 밖 전역 korea : ", korea);
        console.log("2.함수 밖 전역 uk : ", uk);
        
        // callMe 함수 호출
        callMe();

        // 함수에서 전역변수값을 변경하였음!
        console.log("8.함수 밖 전역 korea : ", korea);
        
        // 💥지역변수를 전역에서 참조 불가함!! = 에러남!!
        // console.log("함수 밖 지역 usa : ", usa);
        // 에러메시지 : JS2-2.바렛콘스트.html:68 Uncaught ReferenceError: usa is not defined...

        // 함수 안에서 선언 없이 할당한 변수 rabbit 바깥에서 찍어보기
        console.log("9.함수 밖 선언없는 rabbit : ", rabbit);
        // -> 선언없이 지역에서 할당한 변수는 전역에 등록된다!
        // 변수관리가 어려워지고 나중에 소스 관리에 리스크로 작용할 수 있다
        // 그러므로! 선언 없이 변수를 사용하지 말라~~~~ (w3c, JS업데이트 팀의 권고사항)


        //////////////////////////////////////////////////////////////////////////////////////////////////


        // 2.if문에서 중괄호{} var //////////////////////////////////////////////////////////////////////
        if(true){
            var who = "누구?";
            console.log("if문 안 who : ", who);
        } ///////////// if문 끝 //////////////
        
        console.log("if문 밖 who : ", who);
        // -> if문의 중괄호{} 안에서 변수를 선언하면, 중괄호{}는 '지역' 역할을 못 한다는 것을 알아야 함
        //////////////////////////////////////////////////////////////////////////////////////////////////
        

        // 2-1.if문에서 중괄호{} let 비교 ///////////////////////////////////////////////////////////////
        if(true){
            let what = "뭣이?";
            console.log("if문 안 what : ", what);
        } ///////////// if문 끝 //////////////
        
        // console.log("if문 밖 what : ", what);
        // if문 중괄호{}안의 let는 지역변수이므로! 바깥에서 쓰면 못 쓴다!
        //////////////////////////////////////////////////////////////////////////////////////////////////


        // 3.for문에서 중괄호{} var ////////////////////////////////////////////////////////////////////
        for(var i = 3; i > 0; i--){
            console.log("for문 안 i : ", i);
        } //////////// for문 끝 //////////////
        
        console.log("for문 밖 i : ", i);
        // for문의 중괄호{}도 지역변수 역할을 하지 못함!
        // 3,2,1은 for문 안에서 돌면서 찍히고, i가 0이 되면서 조건에 맞지 않아 밖으로 빠져나오게 됨 -> 0은 for문 안에 들어가지 못했을 뿐이지, i에 저장되어있는 상황임 -> for문 바깥으로 나와서 만난 console.log()에서 i를 찍어보라 하니까 0이 찍힌 것임!
        //////////////////////////////////////////////////////////////////////////////////////////////////


        // 3-1.for문에서 중괄호{} let 비교 ////////////////////////////////////////////////////////////////
        for(let j = 3; j > 0; j--){
            console.log("for문 안 j : ", j);
        } //////////// for문 끝 //////////////
        
        // console.log("for문 밖 j : ", j); -> 에러메시지 : Uncaught ReferenceError: j is not defined
        // for문의 소괄호()안의 세팅은 중괄호{} 안으로 들어가므로! let 변수 선언시, for 중괄호{} 안의 선언으로 처리된다
        // 따라서, 지역변수로 처리된다는 말이다!

        //////////////////////////////////////////////////////////////////////////////////////////////////


        // >>>>>>>>>>>>>> 결론 <<<<<<<<<<<<<<<
        // 💥var는 오직 '함수의 중괄호{}'에서 선언했을 때만! 지역변수가 된다



        //////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////// let,const 테스트 ///////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////

        var seoul = "서울";
        var jeju = "제주도";
        let toktok = "카톡";
        let sport = "축구";

        ////////////// 중괄호{}로 블록영역을 만들어 보자 ///////////////////
        /*******************************************************************/
        {
            // 블록 내부에서 전역변수 찍기! 앞 //
            console.log("블록 내부에서 전역변수 찍기! 앞");
            console.log("seoul : ", seoul);

            // 블록에서 변수 재선언하기
            var seoul = "강남구";
            // : 하단에서 변수를 전역으로 다시 선언,할당한 것과 같은 결과임
            
            // console.log("jeju : ", jeju);
            // : let으로 선언한 변수는 선언 전 (선언한 줄의 윗줄에서) 사용 불가함
            // 에러메시지 : Uncaught ReferenceError: Cannot access 'jeju' before initialization

            // let으로 지역변수 jeju 선언
            let jeju = "마라도";
            // 중괄호{} 안의 let은 지역변수를 생성함 (바깥에서 만든 var는 그대로 있음(?))
            console.log("jeju : ", jeju);

            // 전역변수 let으로 선언된, 같은 이름의 변수 만들기 - toktok
            let toktok = "라인";
            // : 중괄호 바깥의 let변수와 구분함!
            // : 지역변수로 사용됨
            console.log("toktok : ", toktok);

            // var로 전역변수의 let변수를 다시 선언하기
            // var sport = "배구";
            // 전역에 선언된 let과 같은 이름으로 변수를 두번 선언할 수 없도록 막아줌
            // 에러메시지 : Uncaught SyntaxError: Identifier 'sport' has already been declared
            // -Syntax : 문법이라 함
            console.log("sport : ", sport);
            
            // 선언하지 않은 변수를 할당하기
            myitem = "곰인형";
            console.log("myitem : ", myitem);
            // : 기본적으로 선언 없이 사용한 변수는 'var'로 전역변수 선언 된다!
            // : 함수 안에서도 마찬가지임
            // 따라서, 변수에 대한 관리가 매우 어려워진다!!! 나쁜 케이스!!!
            ////////////////////////////////////



            // 블록 내부에서 전역변수 찍기! 뒤 //
            console.log("블록 내부에서 전역변수 찍기! 뒤");
            console.log("seoul : ", seoul);
            console.log("jeju : ", jeju);
            console.log("toktok : ", toktok);
            console.log("sport : ", sport);
            console.log("myitem : ", myitem);
            ////////////////////////////////////

        }
        /*******************************************************************/

        // 블록 바깥에서 전역변수 찍기! //
        console.log("블록 바깥에서 전역변수 찍기!");
        console.log("seoul : ", seoul);
        console.log("jeju : ", jeju);
        console.log("toktok : ", toktok);
        console.log("sport : ", sport);
        ////////////////////////////////////



        // 변수 호이스팅(Variable Hoisting) ///////
        cat = "고양이";  // 변수 할당 먼저
        console.log("cat : ", cat);
        var cat;  // 변수 선언 나중에
        // 위에서 변수 uk의 경우와 마찬가지임
        // 변수 선언을 아래에서 하는 허용은 'var'에서만 가능함
        // 이경우 문제 : 코딩 순서의 혼란 야기

        // let은 변수 호이스팅을 허용하는가? ////////
        let dog;
        dog = "강아지";
        console.log("dog : ", dog);
        // let dog; -> 에러 : Uncaught ReferenceError: Cannot access 'dog' before initialization
        // 💥let은 변수 호이스팅을 금지한다!
        // -> 변수의 선언과 할당에 대한 철저한 순서를 지킬 수 있게 되었다
        // -> var를 사용하지 않는 중요한 이유 중 하나임
        
        var cat = "먼치킨";
        console.log("cat : ", cat);
        // var는 재선언 가능함

        // let dog = "시바견";
        // let은 재선언 못함 -> let을 쓰는 이유 중 하나임



        /////////////////////////////////// 상수 테스트 /////////////////////////////////////////
        // 원래 상수가 없고 변수만 썼었음!

        // const fish;
        // fish = "고등어";
        // 원칙1 : 상수는 선언과 동시에 할당해야함!

        const fish = "고등어";
        console.log("상수 fish : ", fish);
        // fish = "참치";
        // 원칙2 : 상수는 재할당 불가함 (다시 할당할 수 없음)
        // 에러메시지 : Uncaught TypeError: Assignment to constant variable.
        // -Assignment : 할당
        // 따라서, 상수는 바꾸지 않을 값을 할당할 때 씀

        // 상수는 배열, 객체, 함수를 할당하여 많이 사용함!!!

        /////////////////////////////////////////////////////////////////////////////////////////////



        //////////////////////////// const의 활용 : 배열, 객체, 함수 //////////////////////////////////
        
        // [ 1.배열 ] ///////////////////////////////
        const arr = ["상추", "고기", "마늘"];
        console.log("배열 arr값 : ", arr);

        // 1-1.재할당 시도하기
        // arr = "닭고기";
        // : 재할당 시도하면 에러남! 즉, 재할당 불가능함!
        // 에러 메시지 : Uncaught TypeError: Assignment to constant variable.

        // arr = ["고양이", "강아지", "다람쥐"];
        // console.log("배열 arr값 : ", arr);
        // ->에러 메시지 : Uncaught TypeError: Assignment to constant variable.

        // 1-2.배열값 추가하기
        arr.push("닭고기");
        console.log("배열 arr값 : ", arr);
        
        // 💥배열값은 변경가능함 그러나 새로운 데이터 할당은 불가능함
        // 💥??? 저 여기 이해 못했는데여? 
        /*
            지금 푸시로 닭고기를 추가했잖아요...?
            그러면...
            arr = ["상추", "고기", "마늘", "닭고기"]; 가 된거 아닌가요?
            그러면.. "닭고기"라는 새로운 데이터가 할당된거 아닌가요...?

        */



        // [ 2.객체 ] ///////////////////////////////
        const obj = {name:"김수현"};
        console.log("객체 obj : ", obj);

        // 2-1.재할당 시도하기
        // obj = 100;
        // : 재할당 불가
        // 에러 메시지 : Uncaught TypeError: Assignment to constant variable.


        // 2-2.객체에 속성 추가하기
        // 추가 방법 : Object 객체의 '속성정의' 메서드를 사용하면 됨
        // -> Object.defineProperty(객체명, 속성명, {value:속성값})
        Object.defineProperty(obj, "weight", {value:"74kg"});

        console.log("객체 obj : ", obj);

        

        // [ 3.함수 ] ///////////////////////////////
        const fn = function(txt){
            console.log("나야나", txt);
        }; //// fn 함수 끝 ///////

        // 3-1.함수 호출
        fn("화이팅!");

        // 3-2.재할당 시도하기
        // fn = function(){
        //     console.log("이걸로 바꿔봐");
        // };
        // : 재할당 불가
        // 에러 메시지 : Uncaught TypeError: Assignment to constant variable.


        // 💥그밖에 배열, 객체, 함수 외에, 요소를 담을 경우에도 많이 사용된다
        // 그 이유는? 실수로 재할당될 위험에서 지키기 위함. 또는 보안상의 이유로 많이 사용된다



    </script>
</head>
<body>
    
</body>
</html>