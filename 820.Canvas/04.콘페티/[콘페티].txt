콘페티 만들기


-이벤트 당첨이나 축하해주는 일이 있을 떄 시각적으로 많이 사용됨

1.기초 뼈대 구성
2.콘페티 이펙트의 핵심 원리
3.파티클 클래스1
4.파티클 클래스2
5.응용하기


[ 1.기초 뼈대 구성 ]
1.보일러 세팅하기


[ 2.콘페티 이펙트의 핵심 원리 ]
-콘퍼트라이브러리가 있음
: canvas-confetti 임

-데모사이트 들어가보면 구경 가능


1.math()의 사인 코사인 함수를 이용해서 콘페티 사각형 모양의 파티클을 움직일 예정
-widthAlpa 변수 선언해서 만들고 프레임함수 안에서 이 알파값을 0.1씩 계속 더해주기
-fillRect() 함수의 width인자 뒤에 Math().cos()의 라디안값으로 widthAlpa를 넣고 곱하기

->이러면 y축을 중심으로 회전하는 애니메이션이 만들어짐

-Math.cos 함수는 1에서 -1사이값을 계속해서 반복하게 되는데, width의 코사인값을 곱해주니까 코사인값이 계속 커지면서 계속 왔다갔다하면서 애니메이션이 만들어지는 것임


2.height도 동일한 방식으로 만들 것인데 sin함수를 활용해서 애니메이션 만들 예정임
-clearRect함수를 잠깐 주석처리해보면 width와 height값이 변화면서 원을 그려내는 것을 알 수 있음



->바람떄문에 종이가 원의 모양으로 회전하는 것처럼 됨


3.ctx의 rotate는 전체 캔버스를 회전시키는 함수라고 보면 되는데 이를 활용할 예정임
-frame함수 내부에서... if문 아래쪽에다가 ctx.rotate(0.1)을 하기
-그러면 캔버스 자체가 회전을 하는데 기준이 되는 축이 0,0임!

-사각형 파티클이 회전하도록 만들기 위해서는 캔버스 가운데에 있으니까, 기준축을 캔버스 가운데로 바꿔야함
-그러기 위해서 translate를 쓰면 됨
-translate를 도형의 xy만큼 움직여준 다음에 회전을 시키면, 도형을 중심으로 돌게 됨



ctx.rotate()바로 위에 ctx.translate()로 도형 가운데로 이동시켜준 다음 rotate시켜주기
-매 프레임마다 translate와 rotate시킨 값이 계속 중첩되면서 커지기 떄문에, 아래쪽에다가 다시 그만큼 translate로 되돌려줌으로써 복구시켜주면 됨
->이렇게 하면 사각형 파티클의 0,0값을 기준으로 파티클이 회전하는 모양이 됨
-translate는 한 프레임에서 움직였다가 원위치되니까 문제가 없는데 rotate값은 누적해서 계속 더해지고 있기 떄문임

->>그래서 정상적으로 보이기 위해서 맨 마지막에 resettransform을 시켜줌
-then = now - (delta % interval)코드의 위쪽에다가 ctx.resetTransform()을 시켜주면, 살짝 기울어진 형태로 ctx.rotate가 0.1라디안만큼 적용된 것을 볼 수 있음


-ratate에 넣은 0.1을 변수로 만들어서 관리하기 위해 frame함수 바깥쪽에다가 deg변수 만들고, 0.1을 넣은 다음, rotate에 deg를 넣기
-그리고 deg를 매 프레임마다 0.1씩 더해주기
->이러면 x,y를 기준으로 회전하는 컨페티가 만들어짐


->그런데 translate축이 x,y가 아니라 translate에서 회전축을 조금 더 움직이면 좀더 자연스러운 효과가 됨
-x에 width를 더하고, y에 height를 더하고 rotate된 후에 복구할 떄도 똑같이 width와 height를 뺴주면 바뀐 축을 기준으로 회전하게 됨

->그리고 아까 주석처리한 fillRect()사인 코사인 적용한 그 코드의 주석을 풀어서 확인해보면 좀 더 자연스럽게 팔랑거리는 느낌이 됨


-그리고 프레임함수 안에서 y에다가 1씩 더해주면, 팔랑거리면서 아래로 떨어지는 애니메이션이 만들어짐





[ 콘페티 파티클 클래스 만들기 ]

-이번에는 프레임 안에서 만드는 것이 아니라 따로 파일 만들어서 분리하기

1.render함수 안에 있는 변수와 ctx 코드들 모두 지우기

2.Particle.js 파일 만들고 클래스 만들기
-export defult class Particle{
 constructor(){}
 update(){}
 draw(){}
}
만들고 draw에서 일단 빨간색 정사각형을 그리기

3.index.js로 돌아와서, 파티클들을 담을 배열 선언하기

4.콘페티 만들기 위한 함수를 init함수 아래쪽에 만들기
x,y,count를 밖에서 인자로 받아와서, for문을 돌아 콘페티 만들어서 파티클즈에 푸시로 인스턴스를 담기
-x,y를 담아서 보내기

5.이닛이 끝나면 이닛 맨 밑에다가 콘페티 생성 함수 실행하기
-콘페티 함수의 파티클들을 화면 중앙에 표시하기 위해서 x는 캔버스너비 / 2, y는 캔버스 너비 / 2, count는 일단 10개로 해서 인자로 담아서 보내기
-이제 이걸 보여주려면 프레임함수 안에서 파티클즈 배열이 업데이트와 드로우가 순차적으로 실행되어야함

6.프레임 함수로 내려와서 if아래쪽에서 forEach문으로 돌지 말고...! 나중에 지워주는 것도 고려해서.. for문을 거꾸로 돌도록 하자!
: 이떄 for문은 아래처럼 생기면 됨
for(let i = particles.length - 1; i >= 0; i--){
이 안에서 업데이트, 드로우를 하면 됨
}

-업데이트와 드로우는 다음과 같이 작성하면 됨
: particles[i].update();, particles[i].draw();

-그리고 이제 드로우 함수에 ctx를 파라미터로 보내주면 됨

7.이렇게 만든 파티클들을 원 모양으로 퍼지게 하고 그래비티와 프릭션을 부여해서 아래로 떨어지게 하면 됨
-원모양으로 퍼지게하기 위해선 vx,vy를 코사인과 사인 함수를 이용해서 만들어야 함
-파티클 이펙트를 만들 떄 생각해야할 점이, 어느 방향으로 어느 크기의 힘을 줄 것인가임
-예를 들어서 한 프레임에 파티클이 동쪽을 10px만큼 간다고 생각하면... 방향은 세타,즉 각도에 의해서 결정나고 힘은 반지름만큼이라고 생각하면 됨
-즉 vx는 반지름r 곱하기 코사인세타, vy는 r곱하기 사인세타라고 생각하면 됨


8.파티클.js에서 컨스트럭터안에서 각도값을 먼저 정해둠
-라디안을 디그리로 만들어줘야함!
: this.angle = Math.PI / 180 * randomNumBetween(0, 360)
-근데 아직 유틸에 랜덤 넘버가 정해지지 않았으니까 유틸 파일을 하나 만들기


9.유틸.js만들기
-최소값과 최대값을 인자로 받아와서 그 사이에서 랜덤값을 산출해내는 랜덤숫자함수를 만들기
-밖에서 쓰려면 앞에다가 export를 붙여야 함
-return Math.random() * (max - min) + min; 이라고 하면 됨

10.파티클.js 에서 vx, vy, 각도와 반지름을 선언해야함
-vx는 r 곱하기 코사인 세타, vy는 r곱하기 사인 세타 인것!
-> this.vx = this.r * Math.cos(this.angle); this.vy = this.r * Math.sin(this.angle);

-각도는 여기서의 단위가 리디안이라서, 디그리로 변경해줘야함! 그리고 랜덤한 값을 가져오게 하기!
: this.angle = Math.PI / 180 * randomNumBetween(0, 360);
-반지름은 일단 3으로 정하기
this.radius = 3;


11.업데이트 함수에서 this.x에 vx를 더해주고 this.y에는 vy를 더해주기
-누적해서 더해줘야 하니까 += 연산자를 사용해야 함
-



12. 이제 여기에 그래비티와 프릭션 적용하기
-this.vy밑에 this.friction을 0.97정도로 주기
-this.gravity는 0.1정도를 부여하기
-그러고나서 업데이트 함수 안에서 vy에다가 this.gravity를 매 프레임마다 더해주기
-그리고 this.friction을 this.vx,vy에 매 프레임마다 곱해주도록 하기



13. 업그레이드하기
-불꽃놀이는 0~360 사이에 랜덤값이 들어가면 되는데 콘페티는 특정 각도로 쏴줘야 함
-그럼 우선 가장 먼저 수정해줘야 할 부분이 바로?? 앵글임!

-우선 밖에서 디그리를 받아오는데, 기본값을 0으로 하기
-그러고 나서 랜덤유틸함수의 최소값 인자로 디그리 - 30을, 최대값 인자로 디그리 + 30으로 해주면!
-30도부터 30도 사이로 부채꼴 모양으로 파티클을 뿌려주게 됨!

-그리고 윈도우가 처음에 실행되자마자 콘페티가 터져서 실행되는 모습이 끊겨 보여서 확인이 어려움!
-인덱스.js에서 현재 이닛함수 하단에... 윈도우가 클릭이 될 떄마다 실행되는 것으로 바꿔주기
-이닛함수 안에 있는 콘페티 생성 함수 호출한 코드를 가져와서 이벤트 리스너(클릭)안에 콜백함수에 넣어주기


->>근데 프릭션이 너무 약해서 너무 멀리 터지는 것 같음
-그래서 프릭션을 0.89정도로 줄이기
->>그리고 그래비티도 너무 늦어서 0.5정도로 올려서 더 빨리 떨어지게 하기


->>그리고 캔버스 정중앙에서부터 시작하지 않도록 하기 위해서, 콘페티생성 함수의 인자인 x값을 센터가 아니라 index.js에서 캔버스너비 / 2를 0으로 바꿔주면! 왼쪽 벽면에서 발사가 되는 것을 알 수 있음


->>디그리값도 밖에서 안으로 보내주도록 하기
-컨페티생성함수를 호출하는 곳에서 deg를 -50으로 넣어서 가져가도록 하기
-그러면 이제 컨페티생성함수의 소괄호()에도 deg를 써주고, 그 안에서 도는 for문 안에서도! 인스턴스 새로 만들 때 마지막 인자로 deg를 가지고 들어가게 하기!
-그러고나서 particle.js에 가서 컨스트럭터의 소괄호()에 적어둔 deg의 기본값을 0으로 해두면 됨

->그러면 deg를 가변형으로? 만들게 된 것임~!



[콘페티 파티클 클래스 만들기2 ]
-각도 지정해서 특정 각도로만 나가게 만들어뒀음
-이제는 좀 더 다듬어서 더 진짜같이 만들기

1.투명도!
-현재는 파티클이 생성되고 아래로 내려가고, 바닥으로 내려가서 안보여도 계속 프레임함수 안에서 렌더링되고 있기 때문에~! 쌓이면 성능 문제될 수있음
-그러니까 이제 투명도를 0으로 천천히 만들고, 0이되면 없애주도록 하자

-먼저 오파시티를 파티클.js으 ㅣ컨스트럭어에 1로 초기화해서 넣기
-그러고나서 업데이트 함수에서 매 프레임마다 0.005씩 감소시키기
-그리고 드로우함수안에서 색상이 정해져있는데, 여기서 red로 지정되어 있는것을 rgba로 변환해주기


-그리고 보이지않아도 계속 존재하는 파티클들 제거해주기!
-인덱스.js로 가서, 프레임함수 안에서 포문 안에서... if()로 제어해주는데, i번쨰 파티클의 오파시티가 0보다 작아지면 스플라이스로 i번째를 1개 제거해주기로 함
: for(let i = particles.length - 1; i >= 0; i--){
...
if(particles[i].opacity < 0) particles.splice(i, 1);
}

->>콘솔.로그로 확인해보면 된다!
: console.log(particles.lenght);



2. 콘페티 핵심 원리를 알아보는 시간에서 배웠던 translate, rotate, width와 height의 코사인,사인함수를 이용해서 바람에 의해 팔랑거리는 애니메이션 부여했던 것 적용하기
-먼저 스스로 빙글빙글 도는 연출 줄 것임
-particle.js에서 draw함수의 fillRect()함수에서, this.width에 Math.cos을 곱해서 넣기
-마찬가지로 this.height에 Math.sin()을 곱해서 넣기
: drwa(ctx){
 ...
 ctx.fillRect(this.x, this.y, this.width*Math.cos(), this.height*Math.sin());
}
-이때 cos에 width델타를 곱해주면 좌우로 팔랑거렸고, sin에 height델타를 더해주면 상하로 팔랑팔랑 거렸음
-이게 서로 합쳐져저 원모양으로 팔랑거리게 됨

-이제 컨스트럭터 안에서 this.widthDelta와 this.heightDelta를 0으로 초기화해주기

-그리고 이 가로세로 델타들을 업데이트함수 안에서 특정 값을 계속 더해주기
-너비델타는 2씩 더해주고 높이델타도 2씩 더해주기

-그리고 드로우함수 안의 코사인 함수 소괄호 안의 단위도 변경해줘야하기 때문에, 아래처럼 써주기
-this.width * Math.cos(Math.PI / 180 * this.widthDelta)
-this.height * Math.sin(Math.PI / 180 * this.heightDelta)



->>이러면 모두 스스로 빙글빙글 도는 것처럼 나옴!
->>근데 이제 이러면 모두 다 똑같은 모양으로 돌게 되니까 부자연스러워보임
-좀더 자연스럽게 보이기 위해서 widthDelta와 heightDelta값을 각각 랜덤으로 0에서 360도 사이로 값을 바꿔주기로 함
-컨스트럭터에서 정의한 너비델타와 높이델타에 랜덤유틸함수로 0~360사이의 값을 랜덤하게 부여하기



3. 이제 translate와 rotate를 줘서 스스로 회전하는 작업에서 더 나아가, x와 y를 중심으로 조금 떨어진 상태에서 주위를 뱅글뱅글 돌며 떨어지게 만들기
-드로우 함수 최상단에서 ctx.translate로 this.x,y 만큼 이동하게 하면, x,y를 중심으로 빙글빙글 돌게 됨
-이제 여기에다가 translate의 중심축에다가 this.x에 this.width만큼 더해주면 좀 더 자연스렵게 도는 것 처럼 보임!
: ctx.translate(this.x + this.width, this.y + this.height);

-로테이트시키기
: ctx.rotate(Math.PI / 180 * this.rotation);

-rotation값이 아직 정의가 안 되어 있으므로, 컨스트럭터 안에서 0 ~ 360도 사이의 랜덤한 값으로 설정하기

-업데이트 함수에서 로테이션 변수에 계속 특정 값을 더해줘야 하는데, 이때 특정 값도 랜덤하게 받아오기 위해서 this.rotationDelta라고 정의하기
: this.rotation += this.rotationDelta;

-이때도 rotationdelta가 정의된 게 없으니까, 컨스트럭터에 가서 정의해주기
: this.rotationDelta = randomNumBetween(-1, 1);
-이렇게 하면, 어떤 파티클들은 시계반대방향으로 돌고, 어떤 것들은 시계방향으로 돌게 됨
-최대 1도씩 돌아가게 된다


-이제 ctx.translate로 로테이트 후 다시 원위치 시켜줘야 함
처음에 트랜슬레이트 줬떤 값을 그대로 반대로 적용해야 함
: ctx.translate(-this.x - this.width, -this.y - this.height);

-그리고 fillRect()함수의 뒤, 그러니까..마지막부분에서 리셋트렌스폼 해줘야 함!
: ctx.resetTransform();



->>여기서 좀 더 빙글빙글 도는 게 더 잘보이게 하고 싶다면! 트랜슬레이트로 기준점을 잡을 때 this.x에서 this.width만큼 떨어진 거리를 기준으로 회전시켰는데... 여기서 this.width와 height를 더한 값을 좀 더 크게 주면....
-this.x를 기준으로 더 멀리 트랜슬레이트 시켜서 더 크게 회전하는 느낌이 됨

->>이 값들을 더 크게 적용해보자
-이때 마찬가지로 로테이트 후 원위치로 북귀할때에도 똑같은 값을 뺴줘야 함!

-우리는 여기서 곱하기 2를 해줌
: ctx.translate(this.x + this.width * 2, this.y + this.height * 2);
ctx.rotate(...);
ctx.translate(-this.x - this.width * 2, -this.y - this.height * 2);



->이러면 더 역동적이게 됨



4. 이제 종이 사이즈를 줄여보기
-30이 아니라 12정도로 바꿔주기


5.컬러값 바꿔주기
-현재 드로우함수의 필스타일에서 rgba값을 받아서 오파시티 조정하는데... 강사님은 헥스를 쓰는 게 더 편하다고 함...
-그래서 파티클 클래스 안에서 rgb값을 헥스로 변경하려고 함

-유틸.js에서 헥스를 rgba로 변환해주는 유틸성 함수를 구글링해서 가져오셨다고 함 ㅋㅋㅋㅋㅋ
다음과 같음...
: // 컬러 헥스값을 rgba로 변환해주는 함수
export function hexToRgb(hex){  // #FF0000 or #ff0000
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16), // FF -> 255
        g: parseInt(result[2], 16), // 00 -> 0
        b: parseInt(result[3], 16)  // 00 -> 0
    } : null;

}
-정규식을 만들어서 rgb로 변환하는 것을 씀!...


-이제 파티클.js의 컨스트럭터에서 정의하면 됨
-그런데 이제 여러 컬러값 중에 랜덤으로 뿌려줘야 하기 떄문에 인풋되는 컬러를 컬러스라고 해서 배열 형대로 받아오게 함
-컨스트럭터 소괄호 안의 맨 끝에다가 colors라고 쓰면 됨
-그리고 컨스트럭터 안의 최하단에 배열 정의해주기


-컬러스는 약간..옵션같은 것이니까! 만약 따로 넣어주지 않는다면 우리가 지정해놓은 컬러로 렌더링 시키도록 하기
디폴트 컬러는 강사님이 지정한 배열로 하기로 함
: this.colors = colors || ['#ff577f', '#ff884b', '#ffd384', '#fff9b0'];

-그리고 인풋으로, 이미 들어온 컬러스값에서 랜덤으로 하나만 추출해줘야 하기 떄문에, 바로 밑에서 color 변수를 만들고, 그 안에서 배열에 담은 헥스값을 rgb로 바꿔주기
: this.color = hexToRgb(
 this.colors[Math.floor(randomNumBetween(0, this.colors.length - 1))]
);
-다음처럼 해주면, 배열에 있는 인덱스값중에서 하나를 랜덤 정수의 형태로 가져올 수 있음
-이렇게 추출된 컬러를 드로우 함수의 fillStyle에서 써주면 됨
: ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;


->>이제 클래스 밖에서 색상변경이 잘 되는지 확인해보자!
-인덱스.js의 최하단쪽에 있는 클릭했을때 콘페티 생성 함수를 호출하는 부분에서, 인자로.. colors값으로 배열을 넣고, 그 안에다가 우선 빨간색 하나만 넣어보기
: // 윈도우 클릭시 콘페티 생성 함수 호출하기
window.addEventListener('click', ()=>{
    // 콘페티 생성 함수 호출
    confetti({
        // x: canvasWidth / 2,
        x: 0,
        y: canvasHeight / 2,
        count: 10,
        deg: -50,
        colors: ['#ff0000']
    });
});


-그리고 콘페티를 생성해주는 함수를 작성한 곳으로 가서... 인자로다가 colors를 받아와 컨스트럭터로 colors를 보내주기
: // 콘페티 생성 함수
function confetti({ x, y, count, deg, colors }){
    for(let i = 0; i < count; i++){
        particles.push(new Particle(x, y, deg, colors));
    }
}



6. 마지막으로 컨페티 생성함수 호출한 곳에서... 인자로 x값을 일일이 넣어주기보다는.. 0에서 1사이, y값을 예를 들어서 0에서 1사이로 정해준다면 더 편하게 콘페티 생성 가능함
-x가 각각 0.5, 0.5면 중앙에 생성되므로 더 직관적일 것 같음
-일단 클릭이벤트건 곳에서 x: 0, y: 0.5로 해주기
-그러고나서 파티클.js로 가서, 컨스트럭터에 있는 this.x 정의한 곳에서, x에 innerWidth를 곱한 값, this.y에는 innerHeight를 곱한 값을 넣어주기
: this.x = x -> this.x = x * innerwidth;
this.y = y -> this.y = y * innerHeight;

->>이러면 똒같은 결과지만 x와 y를 0 ~ 1사이의 값을 줌으로써 보다 직관적으로 위치값을 정해서 넣을 수 있게 됨!






[ 응용하기 ]
-




