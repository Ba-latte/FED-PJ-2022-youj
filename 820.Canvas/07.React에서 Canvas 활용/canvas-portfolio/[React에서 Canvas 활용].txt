

[ 프로젝트 구조 작성 ]

-가장 많이 쓰는 리액트를 활용해서 같이 써보는 연습하기 위함
-리액트에서 캔버스 적용하는 부분 어려울 수 있기 때문


-vite라는 것을 통해서 보일러 플레이트 한번에 세팅할 것임
-터미널에 명령어 몇줄 치면 create-reat-app을 통해서 만들어지는 것처럼 보일러 플레이트가 생성됨

-vite : https://ko.vitejs.dev/guide/

-빠르게 빌드해주는 빌드도구!

-기존에 우리가 플젝 진행할 때 index.html, style.css, index.js만들고 모듈타입으로 지정하고 다른 스크립트 파일들을 임포트, 익스포트해서 연결해서 하나의 앱으로 만들어 썼었음
-물리 이펙트 하나 구현하기 위해선 꽤 많은 파일, 폴더가 생성됐음
-그래서 '웹팩'이라고 해서 많은 파일과 npm 으로 설치한 패키지 등 모든 파일을 하나로 묶어서 '번들링'해주는 빌드 툴이 생긴 것임

-이 웹팩도 파일이 많아지고 용량이 커지면 결국 병목현상이 발생하여서..하나로 묶어서 번들링하는데에 시간이 오래 걸리게 됨

-그래서 예를 들어 핫모듈 리플레이스먼트, hmr이라고 불리는 개발 모드에서 코드를 저장할 때마다 로컬에서 실시간으로 수정된 코드가 반영되도록 해주는 기능도 점점 속도가 느려질 뿐더러, 처음 앱 시작하거나 배포하기위해 빌드할 때 속도면에서 문제가 생기게 됨

-그래서 다음 세대로 만들어진 게 이 'vite'임

-es 모듈을 브라우저에서 사용하여 빠른 속도로 브라우저에서 빌드해주기 때문에 굉장히 빠르다고 함

-그래서 번들 생성할 필요 없이 매우 빠르게 구동해주고, hmr = 실시간 코드 반영도 아주 빠르게 해준다고 함

-그리고 초기에 세팅해주는 부분도, 웹팩보다는 간편하게 제공해준다고 함


-실제로 이번 프로젝트에서 사용하는 문법이 거의 없어서 그냥 터미널에서 명령어 실행시키는 정도, 폴더와 파일 구조 정도만 훑어보며 정리해보기로 함



<설치하기>
: npm create vite@latest
->하지만 수업에서 쓰는 버전 맞추기 위해 @4.0.0을 설치하도록 하기

-프로젝트 이름을 지어주기

-그리고 바닐라, 리액트, 뷰 등등 중에서 우리는 리액트 활용할것이므로 리액트 선택하기

-그리고 variant를 선택할 때에 맨 위에 있는 일반 js를 선택하기
->그러면 바로 보일러 플레이트 생성됨

-터미널에서 cd 폴더이름을 써서 해당 보일러 플레이트 파일로 들어가서 거기서 npm install을 입력하여 기본 보일러 플레이트 구조에다가 모듈 설치해주기
: npm install

-그러고 나서 패키지.json을 들어가서 확인해보면 vite가 기본적으로 필요한 디펜던시들을 자동으로 명세해줌
-npm install을 통해서 여기 나열된 패키지들을 설치하는 것임

-그리고 이렇게 준비된 보일러 플레이트를 나중에 실행하기 위해서는 터미널에 'npm run'입력 후 이 패키지.json의 "scripts"에 있는 명령어 중 하나를 써주면 됨
-디벨롭 모드는 npm run dev를 치면 되고, 빌드할때에는 npm run build를 쓰면 됨

-따라서 터미널에서 npm run dev를 쳐서 보일러 플레이트 실행하면 로컬:해당포트 에서 실행되는데, 이걸 복사해서 해당 경로로 들어가면 간단하게 보일러 플레이트 생성됨

-패키지.json을 보면 설치한 패키지 옆에 "^"가 있는데 이는 해당 버전 이상의 패키지를 설치하겠다는 뜻임
-사용자들이 이 프로젝트를 다른 시기에 새로 받아서 npm install을하면, 더 높은 버전을 설치하게돼서 의도치 않는 방향으로 나타날 수 있음
-따라서 이 '락'에서 정확한 버전 명시하여 서로의 의존성을 파악하여 패키지를 설치하기 때문에 협업하는 개발자들 사이에서 동일한 디펜던시를 가진 상태에서 프로젝트를 진행하게 만들어줌

-그리고 vite.config.js파일을 열어보면, vite가 리액트만들 위해서 나온 것이 아니고 다양한 프레임워크에서 지원해주기 때문에, 플러그인-리액트를 다운받아서 리액트를 임포트해와서 리액트를 집어넣어줘야, 리액트 용으로 사용할 수 있게됨

-그리고 패키지.json에 들어가보면 dev디펜던시라는 것도 있음
-이것은 개발,배포할 때 내부적으로 필요한 라이브러리들은 여기에 넣어주면 됨
-실제 앱이 배포될 때에는 디펜던시의 라이브러리만 배포되기 때문에 이 두개를 구분하여 넣어주면 빌드 시간과 퍼포먼스부분에 있어서 시간이 줄어들게 됨

-그리고 gitignore는 제작하기 시작한 앱을 깃허브에 올릴 때 굳이 올릴 필요가 없는 파일이나 파일 형식을 여기에 명시하면 자동적으로 필터링해서 올리지 않음!

-그 외에 나머지는 index.html이나 src폴더에 있는 파일들은 비슷함
-다만 퍼블릭 폴더는 정적엑세스를 위한 폴더임
-npm run build를 하면 우리가 만든 파일을 하나로 빌드해줌
-그러면 dist라는 폴더가 만들어지고, 이 안에서 압축된 js, html, css와 그외에 에셋들임
-그런데 public폴더에 들어있던 vite.svg만 원본 이름이고 나머지는 이름이 바껴있음
-즉, 퍼블릭 폴더는 정적인 파일들을 업로드 시켜주기 위한 파일이라고 보면 됨

-만약 public이라는 이름을 수정하고 싶다면 vite.config.js파일에 가서 추가적으로 세팅해줘야함


-우리는 퍼블릭 폴더에서 에셋 관리할 필요 없기 때문에 패스함

-실제 어플리케이션을 구동할 때에는 dist파일들로 실행됨



<필요 없는 파일 지우기>
-퍼블릭 폴더는 지금 필요 없으니까 폴더째로 지우기

-src폴더>assets의 이미지 파일도 지우기

-App.js에서 쓰인 모든 내용 삭제
-그리고 App.js에서 useState도 지금은 안 쓰니까 삭제
-App.js의 상단에 있는 임포트 구문들도 삭제

-그리고 모든 css파일들도 삭제

-main.jsx로 가서 css파일 임포트 구문도 삭제

-src경로에서 새 폴더를 만들고 style폴더 만들기
-이 안에 index.css파일 1개, reset.css파일 1개 만들기

-index.css파일은 모든 css파일의 공통적인 스타일 관리하는 역할
-reset.css는 html요소마다 들어가있는 기본적인 스타일을 초기화해주는 역할

-reset.css 파일에다가 기본 스타일 초기화해주기
-참고 사이트 : https://meyerweb.com/eric/tools/css/reset/


-그리고 index.css의 최상단에서 reset.css 임포트하기
-그리고 리셋 잘 됐나 확인 위해 html, body에 보더 줘서 테스트하기
-main.jsx에서 index.css파일 임포트 해오기

-npm run dev입력해서 열어보기

->css초기화 확인

-html파일 보면 root라는 id를 가진 div요소가 있는데, 여기에 App.jsx 컴포넌트가 들어가는 것임
-title도 바꿔주기

-main.jsx에서 root요소의 자식으로 StrictMode 모드라는 것도 들어가있는데, 이는 애플리케이션 내의 잠재적 문제 알아내기 위해 넣어주는 것임
-즉, 문제 파악하기 위한 디벨롭 모드용 컴포넌트임

-나중에 app.js에서 프로젝트를 진행하면서 보면, 콘솔창에서 2번찍힐 때가 있음
-리액트의 스트릭트 모드에서 자체 검사를 위해 한번 더 렌더링 한 것임
-이를 방지하기 위해서는 이 컴포넌트를 지워주면 됨
-실제로 프로덕션 용으로 앱을 빌드하면 앱이 1번만 실행되는데, 프로젝트 진행할 때에는 2번 발생하는게 번거로워서 삭제할 수도 있음
(아얘 지워주거나 주석처리해버려도 됨)


-useEffect는 앱 컴포넌트가 위에서 코드 순차적으로 읽어서 실행한 다음, 일어난 코드들이 useEffect안에서 실행됨
-그리고 빈 배열을 두번째 인자로 주면 맨처음 렌더링 된 후에 이 useEffect안의 코드가 1번만 실행이 되지만, 배열안에 값을 넣어주면 그 값이 변경될 떄마다 실행됨
=리렌더링 끝난 후 이어서 useEffect실행됨
=리렌더링 될 때마다 실행됨


-dist폴더는 build아직 하지 않을거니가 만들어본 것 지우기


-stytle폴더에 제네럴 역할하는 index.css와, 스타일 초기화하는 reset.css가 있음
-모든 컴포넌트 한군데에 모아줄 app.jsx와 앱의 기본 세팅 담당하는 main.jsx가 있음
-이 main.jsx 안에서 앱 컴포넌트를 받아서 index.html의 root요소에 연결해서 동작하게 됨



[ ui 구조 작업하기 ]
-기초 뼈대 작업하기

-2개의 캔버스에 다른 기술스택을 사용해서 인터렉티브하게 할 것임

-그전에 미리 캔버스 공간을 넣어두면 작업 편해서
-미리 html,css로 디자인 잡아두기로 함!



-사용할 폰트 가져오기


-스타일을 변수명으로 적용할 수 있음
-변수는 상속성을 가지고 있어서, html에 변수 선언해두면 어느곳에서나 이 변수 사용할 수 있음
-반대로 자식 엘리먼트의 css에서 선언했을 때에는 부모 엘리먼트에서 쓸 수는 없다!

-전체적 통일성 주기 위해서는 최상단인 html에 미리 초기화해주는 것이 좋음




-html, css기본 세팅하기
: html, body{
  --color-border: #938f87;
  --color-bg: #c7c288;
  --color-text: #1b1b19;

  --border01: 1px solid var(--color-border);
  --border02: 6px double var(--color-border);

  font-family: 'Fjalla One', 'Noto Sans KR', sans-serif;
  background-color: var(--color-bg);
  color: var(--color-text);

  overflow-x: hidden;
}



-이제 app.jsx로 가서 클래스명을 소문자 a로 바꿔주고 그 안에 섹션태그 만들고 클래스이름은 섹션-1로 해주기
:     <div className="app">
      <section className="section-1">
        
      </section>
    </div>
-메인 첫 화면 꽉찬 대표 엘리먼트를 이 섹션1이 담당할것임
-그리고 그 안에다가 코드 짜주기
:<header>
          <h1>Portfolio</h1>
          <ul>
            <li>instagram</li>
            <li>twitter</li>
            <li>codepen</li>
          </ul>
        </header>
        <main>
          <div>canvas</div>
        </main>



-헤더와 메인으로 나눔
-메인에 캔버스 쓸 것임

-이제 스타일 잡아주기
: .section-1{
  height: 100vh;
  /* 헤더와 메인 정렬 */
  display: flex;
  flex-direction: column;
}

.section-1 > header{
  height: 8rem;
  box-sizing: border-box;
  border-bottom: var(--border01);
  display: flex;
  justify-content: space-between;
  padding-bottom: 0.5rem;

  font-weight: bold;
}

.section-1 > header > ul{
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 2rem;
  padding-bottom: 0.5rem;
}


-고정 단위인 rem을 썼음.. 반응형으로 작업하면 이쁘겟지만..캔버스 때문에 모바일 반응형 스타일하지 않음;

-메인 스타일링하기
:.section-1 > main{
  padding: 1rem 0;
  display: flex;
  flex-grow: 1;
}
.section-1 > main > div{
  box-sizing: border-box;
  border: var(--border02);
  flex-grow: 1;
}



-이 메인 안에 캔버스 넣을 것이고 , 이걸 포함하는 리액트 컴포넌트는 다음에 작성예정!



-app.jsx로 가서 섹션-2 만들기
:       <section className="section-2">
        What is Lorem Ipsum?
      </section>



-스크래치용으로 유용하게 쓸 의미없는 문장을 만들어내는 사이트로, 만들어내기
-참고사이트 : https://www.lipsum.com/

-우리는 많이는 필요 없으니까...일단은 메인화면에 잇는 것 긁어와서 쓰기

-css스타일 잡아주기
: .section-2{
  background-color: var(--color-text);
  margin: 1rem 0;
  padding: 2rem 0;
  color: #fff;
  display: flex;
  justify-content: center;
  font-size: 9rem;
  letter-spacing: -0.5rem;
}



-약간 신문느낌이 나게 만듦
-2022, 2023 트렌드 중 하나가.. 큰 글씨 사용하는 디자인이라고 함...ㅎ
-어워드나..그런 곳에서 보면 큰 글자 형식으로 웹 디자인 많이 했음...

-2023년 트렌드는...미니멀리즘 형식으로 만들지않고 맥시멀리즘이라고..군데군데 빈 곳없이 인터렉션 만들고 움직이는 아이콘 넣는 게 트랜드래;;



-app.jsx로 돌아가서, 이번에는 section-3 태그 작성해주기
: <section className="section-3">
        <aside>
          <div className="top">

          </div>
          <div className="bottom">
            
          </div>
        </aside>
        <article>
          
        </article>
      </section>


-top와  bottom에 들어갈 텍스트도 아까 그 사이트에서 가져와서 넣기
: <div className="top">
            1914 translation by H. Rackham
          </div>
          <div className="bottom">
            <img src={} />
          </div>


-이미지는 assets에 넣어둔 화살표 이미지를 가져올것임
-상단에서 임포트로 ArrowImg라고해서 상대경로로 가져오기
: import ArrowImg from "./assets/arrow.svg";
-><img src={ArrowImg} />


-아티클에 들어갈 글도 로렘입섬에서 문장 아무거나 발췌해서 가져오기
: <article>
          Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
        </article>


-그리고 css로 가서 섹션3의 스타일도 잡아주기
: .section-3{
  min-height: 50rem;
  display: flex;
  border-top: var(--border01);
  border-bottom: var(--border01);
}

.section-3 > aside{
  width: 40%;
  border-right: var(--border01);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.section-3 > aside > .top{
  padding: 2rem 0 2rem 1rem;
  font-size: 5rem;
  letter-spacing: -0.2rem;
}
.section-3 > aside > .bottom{
  height: 10%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 2rem;
}
.section-3 > aside > .bottom > img:nth-last-child(1){
  transform: scale(-1);
}
.section-3 > article{
  width: 60%;
  padding: 0 3rem;
  display: flex;
  align-items: center;

  font-size: 2rem;
  line-height: 1.3;
}



-화살표 이미지에 스케일-1을 줘서 좌우반전을 줬음



-이제 섹션-4 작업하기
: <section className="section-4">
        <canvas></canvas>
        <aside>
          <h1>Javascript</h1>
          <h2>⭐⭐⭐⭐⭐</h2>
          <p>It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using 'Content here, content here', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for 'lorem ipsum' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).</p>
        </aside>
      </section>



-그리고 다시 css로 돌아가서 섹션4 스타일 입혀주기
: .section-4{
  padding: 5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4rem;
}
.section-4 > canvas{
  width: 50vmin;
  height: 50vmin;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.02);
  box-shadow: inset 0 0 5px 5px rgba(0, 0, 0, 0.2);
}
.section-4 > aside{
  width: 50vmin;
}
.section-4 > aside > h1{
  font-size: 4rem;
  margin-bottom: 0.5rem;
}
.section-4 > aside > h2{
  font-size: 3rem;
  margin-bottom: 2rem;
}
.section-4 > aside > p{
  font-size: 1.2rem;
  line-height: 1.4;
}


-inset으로 내부에 그림자를 줘서 안쪽으로 파인 것 같이 효과를줌




-마지막으로 푸터 작성하기
:       <footer>
        <div className="email">test@test.com</div>
      </footer>


-css로 스타일링해주기
: footer{
  position: relative;
  min-height: 75vh;
  background-color: var(--color-text);
  color: #fff;
}
footer > .email{
  position: absolute;
  bottom: 2rem;
  right: 2rem;
  font-size: 12vmin;
}


-가로사이즈를 꽉 채워서 채우고싶은데 지금 상단에 .app에 max-width가 9120픽셀로 되어 있고.... 이걸로 감싸져있기 때문에
-푸터가 그 안에서 있기 때문에 부모 요소의 .app의 가로값을 상속받게 되어서 안이쁜 것임
-그래서 바깥으로 빼주기

-근데 이렇게만하면 리턴할 때에는 1개 요소만 가능하기 떄문에 에러가 발생함
-그래서 그냥 이거 전체를 감싸는 <></>를 넣어줘서 해결하기
->얘는 리액트.프레그먼트라는 뜻임

-이렇게하면 가로가 꽉차는 검정 푸터가 생김


-이렇게보면 낡은 신문 느낌이 남



[ nudake 작업하기 ]




