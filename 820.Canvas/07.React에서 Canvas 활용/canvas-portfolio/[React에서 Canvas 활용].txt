

[ 프로젝트 구조 작성 ]

-가장 많이 쓰는 리액트를 활용해서 같이 써보는 연습하기 위함
-리액트에서 캔버스 적용하는 부분 어려울 수 있기 때문


-vite라는 것을 통해서 보일러 플레이트 한번에 세팅할 것임
-터미널에 명령어 몇줄 치면 create-reat-app을 통해서 만들어지는 것처럼 보일러 플레이트가 생성됨

-vite : https://ko.vitejs.dev/guide/

-빠르게 빌드해주는 빌드도구!

-기존에 우리가 플젝 진행할 때 index.html, style.css, index.js만들고 모듈타입으로 지정하고 다른 스크립트 파일들을 임포트, 익스포트해서 연결해서 하나의 앱으로 만들어 썼었음
-물리 이펙트 하나 구현하기 위해선 꽤 많은 파일, 폴더가 생성됐음
-그래서 '웹팩'이라고 해서 많은 파일과 npm 으로 설치한 패키지 등 모든 파일을 하나로 묶어서 '번들링'해주는 빌드 툴이 생긴 것임

-이 웹팩도 파일이 많아지고 용량이 커지면 결국 병목현상이 발생하여서..하나로 묶어서 번들링하는데에 시간이 오래 걸리게 됨

-그래서 예를 들어 핫모듈 리플레이스먼트, hmr이라고 불리는 개발 모드에서 코드를 저장할 때마다 로컬에서 실시간으로 수정된 코드가 반영되도록 해주는 기능도 점점 속도가 느려질 뿐더러, 처음 앱 시작하거나 배포하기위해 빌드할 때 속도면에서 문제가 생기게 됨

-그래서 다음 세대로 만들어진 게 이 'vite'임

-es 모듈을 브라우저에서 사용하여 빠른 속도로 브라우저에서 빌드해주기 때문에 굉장히 빠르다고 함

-그래서 번들 생성할 필요 없이 매우 빠르게 구동해주고, hmr = 실시간 코드 반영도 아주 빠르게 해준다고 함

-그리고 초기에 세팅해주는 부분도, 웹팩보다는 간편하게 제공해준다고 함


-실제로 이번 프로젝트에서 사용하는 문법이 거의 없어서 그냥 터미널에서 명령어 실행시키는 정도, 폴더와 파일 구조 정도만 훑어보며 정리해보기로 함



<설치하기>
: npm create vite@latest
->하지만 수업에서 쓰는 버전 맞추기 위해 @4.0.0을 설치하도록 하기

-프로젝트 이름을 지어주기

-그리고 바닐라, 리액트, 뷰 등등 중에서 우리는 리액트 활용할것이므로 리액트 선택하기

-그리고 variant를 선택할 때에 맨 위에 있는 일반 js를 선택하기
->그러면 바로 보일러 플레이트 생성됨

-터미널에서 cd 폴더이름을 써서 해당 보일러 플레이트 파일로 들어가서 거기서 npm install을 입력하여 기본 보일러 플레이트 구조에다가 모듈 설치해주기
: npm install

-그러고 나서 패키지.json을 들어가서 확인해보면 vite가 기본적으로 필요한 디펜던시들을 자동으로 명세해줌
-npm install을 통해서 여기 나열된 패키지들을 설치하는 것임

-그리고 이렇게 준비된 보일러 플레이트를 나중에 실행하기 위해서는 터미널에 'npm run'입력 후 이 패키지.json의 "scripts"에 있는 명령어 중 하나를 써주면 됨
-디벨롭 모드는 npm run dev를 치면 되고, 빌드할때에는 npm run build를 쓰면 됨

-따라서 터미널에서 npm run dev를 쳐서 보일러 플레이트 실행하면 로컬:해당포트 에서 실행되는데, 이걸 복사해서 해당 경로로 들어가면 간단하게 보일러 플레이트 생성됨

-패키지.json을 보면 설치한 패키지 옆에 "^"가 있는데 이는 해당 버전 이상의 패키지를 설치하겠다는 뜻임
-사용자들이 이 프로젝트를 다른 시기에 새로 받아서 npm install을하면, 더 높은 버전을 설치하게돼서 의도치 않는 방향으로 나타날 수 있음
-따라서 이 '락'에서 정확한 버전 명시하여 서로의 의존성을 파악하여 패키지를 설치하기 때문에 협업하는 개발자들 사이에서 동일한 디펜던시를 가진 상태에서 프로젝트를 진행하게 만들어줌

-그리고 vite.config.js파일을 열어보면, vite가 리액트만들 위해서 나온 것이 아니고 다양한 프레임워크에서 지원해주기 때문에, 플러그인-리액트를 다운받아서 리액트를 임포트해와서 리액트를 집어넣어줘야, 리액트 용으로 사용할 수 있게됨

-그리고 패키지.json에 들어가보면 dev디펜던시라는 것도 있음
-이것은 개발,배포할 때 내부적으로 필요한 라이브러리들은 여기에 넣어주면 됨
-실제 앱이 배포될 때에는 디펜던시의 라이브러리만 배포되기 때문에 이 두개를 구분하여 넣어주면 빌드 시간과 퍼포먼스부분에 있어서 시간이 줄어들게 됨

-그리고 gitignore는 제작하기 시작한 앱을 깃허브에 올릴 때 굳이 올릴 필요가 없는 파일이나 파일 형식을 여기에 명시하면 자동적으로 필터링해서 올리지 않음!

-그 외에 나머지는 index.html이나 src폴더에 있는 파일들은 비슷함
-다만 퍼블릭 폴더는 정적엑세스를 위한 폴더임
-npm run build를 하면 우리가 만든 파일을 하나로 빌드해줌
-그러면 dist라는 폴더가 만들어지고, 이 안에서 압축된 js, html, css와 그외에 에셋들임
-그런데 public폴더에 들어있던 vite.svg만 원본 이름이고 나머지는 이름이 바껴있음
-즉, 퍼블릭 폴더는 정적인 파일들을 업로드 시켜주기 위한 파일이라고 보면 됨

-만약 public이라는 이름을 수정하고 싶다면 vite.config.js파일에 가서 추가적으로 세팅해줘야함


-우리는 퍼블릭 폴더에서 에셋 관리할 필요 없기 때문에 패스함

-실제 어플리케이션을 구동할 때에는 dist파일들로 실행됨



<필요 없는 파일 지우기>
-퍼블릭 폴더는 지금 필요 없으니까 폴더째로 지우기

-src폴더>assets의 이미지 파일도 지우기

-App.js에서 쓰인 모든 내용 삭제
-그리고 App.js에서 useState도 지금은 안 쓰니까 삭제
-App.js의 상단에 있는 임포트 구문들도 삭제

-그리고 모든 css파일들도 삭제

-main.jsx로 가서 css파일 임포트 구문도 삭제

-src경로에서 새 폴더를 만들고 style폴더 만들기
-이 안에 index.css파일 1개, reset.css파일 1개 만들기

-index.css파일은 모든 css파일의 공통적인 스타일 관리하는 역할
-reset.css는 html요소마다 들어가있는 기본적인 스타일을 초기화해주는 역할

-reset.css 파일에다가 기본 스타일 초기화해주기
-참고 사이트 : https://meyerweb.com/eric/tools/css/reset/


-그리고 index.css의 최상단에서 reset.css 임포트하기
-그리고 리셋 잘 됐나 확인 위해 html, body에 보더 줘서 테스트하기
-main.jsx에서 index.css파일 임포트 해오기

-npm run dev입력해서 열어보기

->css초기화 확인

-html파일 보면 root라는 id를 가진 div요소가 있는데, 여기에 App.jsx 컴포넌트가 들어가는 것임
-title도 바꿔주기

-main.jsx에서 root요소의 자식으로 StrictMode 모드라는 것도 들어가있는데, 이는 애플리케이션 내의 잠재적 문제 알아내기 위해 넣어주는 것임
-즉, 문제 파악하기 위한 디벨롭 모드용 컴포넌트임

-나중에 app.js에서 프로젝트를 진행하면서 보면, 콘솔창에서 2번찍힐 때가 있음
-리액트의 스트릭트 모드에서 자체 검사를 위해 한번 더 렌더링 한 것임
-이를 방지하기 위해서는 이 컴포넌트를 지워주면 됨
-실제로 프로덕션 용으로 앱을 빌드하면 앱이 1번만 실행되는데, 프로젝트 진행할 때에는 2번 발생하는게 번거로워서 삭제할 수도 있음
(아얘 지워주거나 주석처리해버려도 됨)


-useEffect는 앱 컴포넌트가 위에서 코드 순차적으로 읽어서 실행한 다음, 일어난 코드들이 useEffect안에서 실행됨
-그리고 빈 배열을 두번째 인자로 주면 맨처음 렌더링 된 후에 이 useEffect안의 코드가 1번만 실행이 되지만, 배열안에 값을 넣어주면 그 값이 변경될 떄마다 실행됨
=리렌더링 끝난 후 이어서 useEffect실행됨
=리렌더링 될 때마다 실행됨


-dist폴더는 build아직 하지 않을거니가 만들어본 것 지우기


-stytle폴더에 제네럴 역할하는 index.css와, 스타일 초기화하는 reset.css가 있음
-모든 컴포넌트 한군데에 모아줄 app.jsx와 앱의 기본 세팅 담당하는 main.jsx가 있음
-이 main.jsx 안에서 앱 컴포넌트를 받아서 index.html의 root요소에 연결해서 동작하게 됨



[ ui 구조 작업하기 ]
-기초 뼈대 작업하기

-2개의 캔버스에 다른 기술스택을 사용해서 인터렉티브하게 할 것임

-그전에 미리 캔버스 공간을 넣어두면 작업 편해서
-미리 html,css로 디자인 잡아두기로 함!



-사용할 폰트 가져오기


-스타일을 변수명으로 적용할 수 있음
-변수는 상속성을 가지고 있어서, html에 변수 선언해두면 어느곳에서나 이 변수 사용할 수 있음
-반대로 자식 엘리먼트의 css에서 선언했을 때에는 부모 엘리먼트에서 쓸 수는 없다!

-전체적 통일성 주기 위해서는 최상단인 html에 미리 초기화해주는 것이 좋음




-html, css기본 세팅하기
: html, body{
  --color-border: #938f87;
  --color-bg: #c7c288;
  --color-text: #1b1b19;

  --border01: 1px solid var(--color-border);
  --border02: 6px double var(--color-border);

  font-family: 'Fjalla One', 'Noto Sans KR', sans-serif;
  background-color: var(--color-bg);
  color: var(--color-text);

  overflow-x: hidden;
}



-이제 app.jsx로 가서 클래스명을 소문자 a로 바꿔주고 그 안에 섹션태그 만들고 클래스이름은 섹션-1로 해주기
:     <div className="app">
      <section className="section-1">
        
      </section>
    </div>
-메인 첫 화면 꽉찬 대표 엘리먼트를 이 섹션1이 담당할것임
-그리고 그 안에다가 코드 짜주기
:<header>
          <h1>Portfolio</h1>
          <ul>
            <li>instagram</li>
            <li>twitter</li>
            <li>codepen</li>
          </ul>
        </header>
        <main>
          <div>canvas</div>
        </main>



-헤더와 메인으로 나눔
-메인에 캔버스 쓸 것임

-이제 스타일 잡아주기
: .section-1{
  height: 100vh;
  /* 헤더와 메인 정렬 */
  display: flex;
  flex-direction: column;
}

.section-1 > header{
  height: 8rem;
  box-sizing: border-box;
  border-bottom: var(--border01);
  display: flex;
  justify-content: space-between;
  padding-bottom: 0.5rem;

  font-weight: bold;
}

.section-1 > header > ul{
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 2rem;
  padding-bottom: 0.5rem;
}


-고정 단위인 rem을 썼음.. 반응형으로 작업하면 이쁘겟지만..캔버스 때문에 모바일 반응형 스타일하지 않음;

-메인 스타일링하기
:.section-1 > main{
  padding: 1rem 0;
  display: flex;
  flex-grow: 1;
}
.section-1 > main > div{
  box-sizing: border-box;
  border: var(--border02);
  flex-grow: 1;
}



-이 메인 안에 캔버스 넣을 것이고 , 이걸 포함하는 리액트 컴포넌트는 다음에 작성예정!



-app.jsx로 가서 섹션-2 만들기
:       <section className="section-2">
        What is Lorem Ipsum?
      </section>



-스크래치용으로 유용하게 쓸 의미없는 문장을 만들어내는 사이트로, 만들어내기
-참고사이트 : https://www.lipsum.com/

-우리는 많이는 필요 없으니까...일단은 메인화면에 잇는 것 긁어와서 쓰기

-css스타일 잡아주기
: .section-2{
  background-color: var(--color-text);
  margin: 1rem 0;
  padding: 2rem 0;
  color: #fff;
  display: flex;
  justify-content: center;
  font-size: 9rem;
  letter-spacing: -0.5rem;
}



-약간 신문느낌이 나게 만듦
-2022, 2023 트렌드 중 하나가.. 큰 글씨 사용하는 디자인이라고 함...ㅎ
-어워드나..그런 곳에서 보면 큰 글자 형식으로 웹 디자인 많이 했음...

-2023년 트렌드는...미니멀리즘 형식으로 만들지않고 맥시멀리즘이라고..군데군데 빈 곳없이 인터렉션 만들고 움직이는 아이콘 넣는 게 트랜드래;;



-app.jsx로 돌아가서, 이번에는 section-3 태그 작성해주기
: <section className="section-3">
        <aside>
          <div className="top">

          </div>
          <div className="bottom">
            
          </div>
        </aside>
        <article>
          
        </article>
      </section>


-top와  bottom에 들어갈 텍스트도 아까 그 사이트에서 가져와서 넣기
: <div className="top">
            1914 translation by H. Rackham
          </div>
          <div className="bottom">
            <img src={} />
          </div>


-이미지는 assets에 넣어둔 화살표 이미지를 가져올것임
-상단에서 임포트로 ArrowImg라고해서 상대경로로 가져오기
: import ArrowImg from "./assets/arrow.svg";
-><img src={ArrowImg} />


-아티클에 들어갈 글도 로렘입섬에서 문장 아무거나 발췌해서 가져오기
: <article>
          Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
        </article>


-그리고 css로 가서 섹션3의 스타일도 잡아주기
: .section-3{
  min-height: 50rem;
  display: flex;
  border-top: var(--border01);
  border-bottom: var(--border01);
}

.section-3 > aside{
  width: 40%;
  border-right: var(--border01);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.section-3 > aside > .top{
  padding: 2rem 0 2rem 1rem;
  font-size: 5rem;
  letter-spacing: -0.2rem;
}
.section-3 > aside > .bottom{
  height: 10%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 2rem;
}
.section-3 > aside > .bottom > img:nth-last-child(1){
  transform: scale(-1);
}
.section-3 > article{
  width: 60%;
  padding: 0 3rem;
  display: flex;
  align-items: center;

  font-size: 2rem;
  line-height: 1.3;
}



-화살표 이미지에 스케일-1을 줘서 좌우반전을 줬음



-이제 섹션-4 작업하기
: <section className="section-4">
        <canvas></canvas>
        <aside>
          <h1>Javascript</h1>
          <h2>⭐⭐⭐⭐⭐</h2>
          <p>It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using 'Content here, content here', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for 'lorem ipsum' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).</p>
        </aside>
      </section>



-그리고 다시 css로 돌아가서 섹션4 스타일 입혀주기
: .section-4{
  padding: 5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4rem;
}
.section-4 > canvas{
  width: 50vmin;
  height: 50vmin;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.02);
  box-shadow: inset 0 0 5px 5px rgba(0, 0, 0, 0.2);
}
.section-4 > aside{
  width: 50vmin;
}
.section-4 > aside > h1{
  font-size: 4rem;
  margin-bottom: 0.5rem;
}
.section-4 > aside > h2{
  font-size: 3rem;
  margin-bottom: 2rem;
}
.section-4 > aside > p{
  font-size: 1.2rem;
  line-height: 1.4;
}


-inset으로 내부에 그림자를 줘서 안쪽으로 파인 것 같이 효과를줌




-마지막으로 푸터 작성하기
:       <footer>
        <div className="email">test@test.com</div>
      </footer>


-css로 스타일링해주기
: footer{
  position: relative;
  min-height: 75vh;
  background-color: var(--color-text);
  color: #fff;
}
footer > .email{
  position: absolute;
  bottom: 2rem;
  right: 2rem;
  font-size: 12vmin;
}


-가로사이즈를 꽉 채워서 채우고싶은데 지금 상단에 .app에 max-width가 9120픽셀로 되어 있고.... 이걸로 감싸져있기 때문에
-푸터가 그 안에서 있기 때문에 부모 요소의 .app의 가로값을 상속받게 되어서 안이쁜 것임
-그래서 바깥으로 빼주기

-근데 이렇게만하면 리턴할 때에는 1개 요소만 가능하기 떄문에 에러가 발생함
-그래서 그냥 이거 전체를 감싸는 <></>를 넣어줘서 해결하기
->얘는 리액트.프레그먼트라는 뜻임

-이렇게하면 가로가 꽉차는 검정 푸터가 생김


-이렇게보면 낡은 신문 느낌이 남



[ nudake 작업하기 ]


-첫번째 메인페이지에 캔버스 택스트대신에 캔버스요소 채워서 만들기
-nudake라는 사이트의 메인 컨셉이 화면을 문질러서 다음 이미지가 나오게 만드는 갤러리를 말함
-명사처럼 "누데이크"라고 그냥 이름지음

-src폴더에 containers폴더 만들기
-그 안에 Nudake.jsx파일 만들기
-이 컨테이너즈안에는 특정 기능 하는 컴포넌트들을 담을 예정임

-이 Nudake.jsx는 누데이크 기능하며 캔버스 앨리먼트 리턴해주는 기능 할 것임

-누데이크.jsx에서 함수형 컴포넌트 만들기
:const Nudake = ()=>{
  return(
    <div>
      <canvas></canvas>
    </div>
  )
};

export default Nudake;
-리턴으로 캔버스를 자식으로 갖는 div요소 넣어주기
-그리고 컴포넌트 익스포트시켜주기


-이제 css파일도 하나 만들어줄건데 스타일 폴더 안에다가 똑같이 컨테이너즈 폴더 만들고 그 안에서 똑같은 이름으로 만들어주기

-그리고 방금 만든 css파일을 누데이크.jsx파일에서 임포트해오기
: import "../style/containers/Nudake.css";


-그리고 div의 클래스이름을 nudake라고 해주기
:     <div className="nudake">


-그리고 스타일 잡아주기
:.nudake{
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;

  box-sizing: border-box;
  border: 2px solid red;
}

.nudake > canvas{
  position: absolute;
}
-.nudake를 화면에 꽉차게 w100p, h100p해주고 플렉스 속성으로 정가운데에 정렬하기
-그리고 포지션 랠러티브를 주기

-그리고 누데이크>캔버스에 앱솔루트 포지션 줘서 부모 기준으로 화면에 띄우기

-이렇게 해주는 이유는, 캔버스 지우고 있을 때에 다음 이미지가 보여야하는데, 다음이미지를 캔버스 부모 요소의 배경이미지 속성을 활용할 예정이라 이렇게 함

-그리고 테스트하기위해서 누데이크에다가 보더값 주기




-다시 app.js로 돌아와서 메인 태그 안에 있는 div태그에 쓰인 캔버스 텍스트 지우기
-그리고 이 div박스 안에서 Nudake 컴포넌트 가져와서 넣어주기
: 
<main>
            <div><Nudake /></div>
          </main>


-결과를 보면 빨간 라인이 누데이크고 부모요소를 꽉 채운 게 확인됨

-이제 css에서 보더값 지워주기


-이제 캔버스 그려주면 됨


-Nudake.jsx 상단에서 useEffect실행해주기
: const Nudake = ()=>{
  
  useEffect(()=>{

  }, []);

..
}

-누데이크 컴포넌트가 처음 실행이 되고난 이후에 유즈이펙트 안에 쓰인 코드가 한번만! 실행됨
-돔들이 랜더링된 후에 캔버스가 그 다음에 그려져야하니까 이 유즈 이벡트 안에서 캔버스와 CTX같은 걸 가져와서 여기서 그려주면 됨

-그리고 두번쨰 인자로 []빈배열을 줘서, 처음 딱 한번만 이 블럭 안의 코드를 랜더링하게 만듦
-특별한 상황이 아니라면 이렇게 빈 배열을 넣어줘서 한번만 실행되게 해줘야 좋음


-이제 ctx를 가져와서 해야하는데... 이전까지는 캔버스 앨리먼트 가져올때에 쿼리셀렉터로 가져왔었지만... 만약 이 누데이크컴포넌트 안에 또다른 함수가 있고, 그 함수안에서 캔버스 엘리먼트를 불러와야한다면... 쿼리셀렉터로 불러와야함

-이렇게 매번 쿼리셀렉터로 불러오지말고, 컴포넌트 상단에서 useRef를 써서 먼저 가져와놓기
: const Nudake = ()=>{
  const canvasRef = useRef(null);
...
}
-널로 초기화해준 이유는 처음 누데이크 컴포넌트 렌더링하면서, 아직 캔버스 엘리먼트 코드가 리턴되기도 전에 상단에서 쿼리셀렉터와 같이 없는 것을 초기화시켜줄 수 없기 때문임
-그래서 우선 null값을 넣어주는 것임
-그리고 한번 위->아래로 쭉 읽으면서, 하단 리턴에서 canvasRef변수를 ref로 넣어줌으로써, canvasRef에 해당 캔버스 엘리먼트가 잘 할당됨!
-이렇게 맨 처음 렌더링이 된 후에 useEffect의 내부 코드가 읽히는데, 이게 실행되면서 .current로 해당 엘리먼트를 읽어오는 것임


-그러고 나서 리턴에 있는 캔버스 요소에  ref속성으로 canvasRef넣어주기
:   return(
    <div className="nudake">
      <canvas ref={canvasRef}></canvas>
    </div>
  )


-유즈이펙트 안에서 컨스트 캔버스 = 캔버스Ref.current라고 작성해서, 이런 방식으로 불러오는 게 좋음
:   useEffect(()=>{
    const canvas = canvasRef.current;
  }, []);



-이제 ctx값을 불러오기 위해서 아랫줄에다가 const ctx선언하기
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
...
}


-그리고 캔버스 가로,세로값을 우선 선언만 해주기
:     let canvasWidth, canvasHeight;

-그리고 리사이즈 함수를 만들고 캔버스 가로값은 부모 영역을 꽉 채워야하니까, 부모 요소인 .nudake의 보더값을 제외한 안의 영역을 넣어주면 됨
-따라서 캔버스의 부모요소 변수를 선언해주고 그 안의 client가로,세로값을 저장해주면 됨
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');
...
}

-우선 이렇게 부모 요소 변수 만들고 부모요소 가져온 다음, useEffect 내부 하단에서 resize함수 만들기
: const Nudake = ()=>{
...
    function resize(){ 
    }
  }, []);


-그러고나서, 이 리사이즈 함수 안에서 canvasWidth, height 변수에 부모요소의 client가로,세로값을 할당하기
:     function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;
    }



-캔버스의 사이즈는 2종류니까 이제 고유 사이즈값, css사이즈값 모두 이 canvasWidth와 높이를 이용해서 초기화해주기
:     function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;

      // 캔버스 고유 사이즈
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // 캔버스 CSS 사이즈
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }


-이전에는 dpr도 리사이즈할떄마다 사용했었는데, 여기에서는 dpr이 필요 없음
왜냐? 이미지만 이 요소 사이즈에 맞게 랜더링시켜주면 끝이니까

그리고 이번 예제에서는 마우스무브 할 때마다 캔버스 그리고 지울것이기 때문에 프레임 함수가 들어있는 렌더링 함수 필요 없음



-그래도 일단은 테스트하기 위해서 리사이즈 함수 아랫줄에서 프레임함수 만들기
:     function frame(){
      
    }

-그리고 이 안에서 프레임을 인자로 넣어서 재귀함수로 동작시켜주기
:    function frame(){
      requestAnimationFrame(frame);
    }
-그리고 그 아랫줄에서 fillRect로 정사각형 하나 그려주기
:     function frame(){
      requestAnimationFrame(frame);

      ctx.fillRect(100, 100, 100, 100);
    }
-그리고 프레임 화면 밖으로 나가서, resize이벤트가 발생할때마다 이 리사이즈 함수를 실행해주기
:
    function frame(){
      requestAnimationFrame(frame);

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);
  }, []);



-그리고나서 최초로 리사이즈 함수를 한번 호출해서 초기화해주기
-그리고나서 아랫줄에서 프레임함수를 최초 호출해서 초기화해주기
:  useEffect(()=>{
...
    function frame(){
      requestAnimationFrame(frame);

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);

    resize();
    requestAnimationFrame(frame);
  }, []);



-이러면 정사각형 그려지는 것 확인!
-근데 여기서 중요하게 짚고 넘어가야할 게 있음

-여기 리액트 컴포넌트에서 리퀘스트애니메이션프레임을 실행할떄 주의해야함
-리액트가 만약 다른페이지로 넘어가거나 리액트의 조건부 렌더링으로 이 누데이크 컴포넌트를 다른 컴포넌트로 교체할 때에!!!
컴포넌트가 언마운트되면서 기존 컴포넌트가 없어질 것임

-이때 우리가 재귀함수로 스스로 실행하게 만든 이 리퀘스트 애니메이션프레임은 알아서 중단되지 않음!
-따라서 컴포넌트는 알아서 언마운트되면서 없어지지만 안의 이 로직이 계속 실행되는 문제가 발생함



<예시>
-APP.js로 가서 
앱 컴포넌트 상단에서 토글 state변수를 만들기
: function App() {
  const [toggle, setToggle] = useState(false);
....
}

-그러고나서 헤더 태그의 h1에 있는 로고 글자를 클릭하면 이 토글이 t/f로 계속 바뀌는 클릭이벤트 넣어주기
:           <header>
            <h1 onClick={()=>setToggle(state => !state)}>Portfolio</h1>
...
</header>

-이제 이걸 콘솔창에서 확인해봤을 때 
function App() {
  const [toggled , setToggle] = useState(false);

  console.log(toggled);
->> 계속 t/f바뀌게 됨

-이제 메인태그의 div안에서 toggled state변수가 true가 되면 'toggled' 텍스트가 렌더링되고, false일떄엔 <Nudake/>컴포넌트가 보이게 해주기
:  <main>
            <div>{toggled ? "toggled" : <Nudake />}</div>
          </main>



-이렇게 한 뒤에 h1태그 클릭해보면.. 알아서 글자가 출력되거나 캔버스가 출력됨
번갈아가면서!

-이 toggled텍스트가  출력된다는 뜻 = 지금 돔 트리 구조 안에서 누데이크와 그 안의 캔버스가 언마운트돼서 존재하지 않는 상태가 되었단 뜻
-반대로 돔트리에 존재하고, 텍스트는 조건부 렌더링에 의해 안보이게 됨


-다시 누데이크.jsx로 돌아가서, 프레임 함수 안에서 콘솔.count("프레임")으로 프레임 함수가 호출되는 횟수를 확인해보기
:   function frame(){
      requestAnimationFrame(frame);
      console.count("frame");
-=>>처음에 프레임함수가 재귀함수로써 계속 실행되다가 h1클릭해서 toggled가 ture가 되면 누데이크 컴포넌트는 언마운트되면서 존재하지 않게 되는데, 그래도 콘솔창에는.. 사라지지 않고 계속 돌아가고 있는 게 확인됨!!!!


-따라서 리액트에서 리퀘스트애니메이션 프레임이나 셋인터벌과 같은 함수를 사용할 때에는 꼭 컴포넌트가 언마운트될 때 클린업 잊지 말고 시켜줘야함!!!!
-안그러면 계속 언마운트/마운트 되면서 중첩되어 재귀함수가 실행되면서 퍼포먼스 이슈가 발생함 ㅠㅠ



-이제 누데이크.jsx파일에서 useEffect하단에다가 리턴()=>{} 함수를 써주기
: useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');

    let canvasWidth, canvasHeight;

    function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;

      // 캔버스 고유 사이즈
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // 캔버스 CSS 사이즈
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }

    function frame(){
      requestAnimationFrame(frame);
      console.count("frame");

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);

    resize();
    requestAnimationFrame(frame);

    return ()=>{

    }
  }, []);
-이 부분은 컴포넌트가 언마운트될 떄 실행되는 부분임
-여기다가 캔슬애니메이션프레임(*)함수를 써서 현재 리퀘스트 애니메이션의 id값을 인자로 주면, 지금 재귀로 돌아가는 프레임함수가 멈추게 됨!!

-프레임함수 바로 위에다가 let으로 frameID를 초기화해주고, 이 프레임id 변수에 리퀘스트애니메이션프레임 재귀함수의 리턴값을 저장해주면!
:     // 프레임 ID
    let frameId;

    function frame(){
      frameId = requestAnimationFrame(frame);
      console.count("frame");

      ctx.fillRect(100, 100, 100, 100);
    }

-매 프레임마다 현재 리퀘스트 애니메이션 프래임 함수의 id값이 저장이 됨
-이 아이디 값을 캔슬 애니메이션 프레임의 인자로 넣어주기
:    // 프레임 ID
    let frameId;

    function frame(){
      frameId = requestAnimationFrame(frame);
      console.count("frame");

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);

    resize();
    requestAnimationFrame(frame);

    return ()=>{
      cancelAnimationFrame(frameId);
    }
  }, []);
그러면 컴포넌트가 언마운트 될 때 이게 캔슬됨!



->이제 h1요소를 클릭해서 토글해보면!!!! 애니메이션 함수가 캔슬되면서 멈춘다!
->그리고 다시 클릭해서 실행해보면 멈춘 그 순서부터 다시 실행되는게 보인다!



-컴포넌트가 언마운트 될 때에는
1.앱.js에서 지금처럼 스테이트값에 따라서 컴포넌트를 조건부 렌더링 시켜줄떄
2.리액트 라우터 돔을 통해서 다른 주소로 넘어가면 현재 컴포넌트가 언마운트가 될 텐데, 이때도 이 유즈이펙트 안의 리턴함수 실행되면서 언마운트가 됨

-그리고 현재 로직에서 클린업 시켜줘야할 한가지가 있음!
-바로 윈도우 애드이벤트 리스너로 등록한 리사이즈함수임
-이것도 마찬가지로 윈도우의 리사이즈 이벤트를 한번 추가시켜줬다고 한들, 컴포넌트가 어마운트될떄 알아서 같이 삭제되지 않기 때문에!!! 우리가 캔슬시켜줬던것처럼 클린업시켜줘야함

-따라서 리턴 안에다가 윈도우.리무브이벤트리스너"리사이즈",리사이즈함수 를 써서 클린업 시켜주기
:     // Nudake 컴포넌트가 언마운트 될 때 해당 기능들 클린업 시키기
    return ()=>{
      // 리사이즈 함수
      window.removeEventListener("resize", resize);
      // 애니메이션프레임 함수
      cancelAnimationFrame(frameId);
    }





-이제 테스트하기 위해서 만들어두었던 app.jsx의 클릭 이벤트 지워주기~~
-toggled state변수 지우기
-콘솔.로그(toggled)도 지우기
-리턴 부분에서 삼항연산자 써서 조건부 렌더링 시킨것도 지우기~


-여기서 잠깐!!
-아까 윈도우로 에드이벤트리스너로 리사이즈 등록할때에는 유즈이펙트 안에서 꼭 클린업 시켜줘써야했는데.. 온클릭 이벤트는...클린업 왜 안시켜줌??
->> on과 클릭으로 시작하는 onClick이벤트는 리액트 문법으로써, 자체적으로 이 앨리먼트에다가 클릭이벤트 심어주고 언마운트 될때 알아서 클린업됨!
-그래서 신경 안써도 되는 것임



-이번 누데이크 캔버스에서는 움직이는 캔버스를 예제에 활용하지 않기 때문에 이 프레임 함수 지워주면 됨


-하지만 지우기 전에, 이해를 위해서 잠깐 활용해보기로 함




<<연습, 테스트 겸 써보기 : 리액트에서 프레임함수 써보기>>
-이 까만 정사각형 움직여 볼것임

-x,y를 100으로 상수값 주는 게 아님
-프레임 함수 밖에서 x,y를 0으로 초기화하고
-vx, vy를 20으로 초기화
-사이즈를 200으로 초기화시켜주기
:     let x = 0;
    let y = 0;
    let vx = 20;
    let vy = 20;
    let size = 200;

    function frame(){
...
}


-그리고 프레임 함수 안에다가 다음과 같이 코드 작성하기
:     function frame(){
      frameId = requestAnimationFrame(frame);

      if(x < 0){
        x = 0;
        vx *= -1;
      }
      else if(x > canvasWidth - size){
        x = canvasWidth - size;
        vx *= -1;
      }
      else if(y < 0){
        y = 0;
        vy *= -1;
      }
      else if(y > canvasHeight - size){
        y = canvasHeight - size;
        vy *= -1;
      }

      ctx.fillRect(100, 100, 100, 100);
    }


-즉, x가 0보다 작거나 캔버스 가로값-상자크기보다 클때에는, 즉 박스의 오른쪽 면이 캔버스의 오른쪽 끝에 닿을 때 x를 0으로 바꾸고 속도를 반대방향으로바꾸는 것임
-마찬가지로y도 그렇게 해줌

-그리고 x에 vx를 더하고 y에는vy를 더해주기
:      x += vx;
      y += vy;


-그리고 fillRect에 100이라고넣은 상수들을 지우고 x, y size, size를 넣기
:       ctx.fillRect(x, y, size, size);

-그리고 프레임함수 블럭 상단에서 clearRect()로 화면 지워주기
: function frame(){
      frameId = requestAnimationFrame(frame);

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      if(x < 0){
        x = 0;
        vx *= -1;
      }
      else if(x > canvasWidth - size){
        x = canvasWidth - size;
        vx *= -1;
      }
      else if(y < 0){
        y = 0;
        vy *= -1;
      }
      else if(y > canvasHeight - size){
        y = canvasHeight - size;
        vy *= -1;
      }

      x += vx;
      y += vy;

      ctx.fillRect(x, y, size, size);
    }



-이러면 막 움직임
-이게 바로 리액트에서 유즈 이펙트 안에서 캔버스를 애니메이션 시키는 방법임!
-js에서 클래스 쓴것처럼 여기도 클래스 파일 만들고 이 컴포넌트 안으로 임포트해서 사용해도 됨

-if문을 클래스의 업데이트 메서드 안에서 정의하면 됨
-맨아래 fillRect는 드로우 메서드로 이전에 만든것처럼 해도 됨


-이 테스트용으로 작성한코드 싹 다 지우고 아래처럼 남기기
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');

    let canvasWidth, canvasHeight;

    function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;

      // 캔버스 고유 사이즈
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // 캔버스 CSS 사이즈
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }

    // 리사이즈 이벤트 등록하기
    window.addEventListener("resize", resize);
    // 리사이즈 함수 최초 호출
    resize();

    // Nudake 컴포넌트가 언마운트 될 때 해당 기능들 클린업 시키기
    return ()=>{
      // 리사이즈 함수
      window.removeEventListener("resize", resize);
    }
  }, []);





[ 캔버스 지우는 기능 만들기 ]
-지울 이미지를 먼저 그리고 그걸 지우는 것임

-어셋 폴더에 이미지 3개 가져와서 넣기

-그리고 Nudake.jsx폴더에서 상단에서 이미지 3개 임포트로 각각 불러오기
: import image1 from "../assets/nudake-1.jpg";
import image2 from "../assets/nudake-2.jpg";
import image3 from "../assets/nudake-3.jpg";

-그리고 useEffect안에서 ctx밑에 const imageSrcs라는 변수를 만들고 배열에 이미지를 순서대로 넣어주기
-이미지 경로를 이렇게 순서대로 배열에 넣은 이유는 나중에 이미지를 문질러서 계속 지우면, 마지막 이미지에서 처음 이미지로 마치 이미지 갤러리처럼 무한히 반복되어야하기 때문에, 이렇게 미리 배열에 담아둔 것임
-이 배열에서 현재 이미지의 인덱스번호를 참조해줄 변수를 바로 아래에다가 currIndex를 만들고 0으로 초기화해주기
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');

    // 이미지 주소 담은 배열
    const imageSrcs = [image1, image2, image3];
    // 이미지 인덱스번호 참조
    let currIndex = 0;
...
}


-그리고 리사이즈 함수에서 리사이즈시 드로우이미지라는 이름의 함수를 실해해주도록 하고, 바로 아래에다가 드로우이미지라는 함수를 선언해주기
:     function resize(){
      // 이미지 그리기
      drawImage();
    }
    function drawImage(){
      
    }



-먼저 이미지 그리기 전에 전체 캔버스를 한번 지워주기
:       ctx.clearRect(0, 0, canvasWidth, canvasHeight);
-그러고 나서 뉴 이미지로 새로운 이미지 인스턴스 생성한 다음 이미지 변수에 넣기
-그리고 이미지.src에 이미지주소 배열의 현재 인덱스 번호번째에 담겨있는 이미지경로를 담아주기
:       // 이미지 생성
      const image = new Image();
      // 현재 인덱스 번호에 담긴 경로를 저장하기
      image.src = imageSrcs[currIndex];



-바로 여기서 ctx.드로우이미지해서 인자로 이미지, 0, 0, 캔버스가로값, 캔버스 높이값을 넣어서 이미지를 그리기
:       // 캔버스에 그리기
      ctx.drawImage(image, 0, 0, canvasWidth, canvasHeight);


->>이미지가 안 그려지는 이유!!
->>이미지를 src에 담아줘서 이미지가 불러오는 것은 useEffect에서 진행하기 때문에 비동기적으로 처리됨->그런데 바로 아랫줄에서 드로우 이미지로 이미지를 0,0부터 그리는 코드를 넣었기 때문에 이미지가 로드되기도 전에 드로우를 요청해버려서 이미지가 다 읽어오기도 전에 그려버리기 때문임!

-->>우리가 이전에 다른 플젝했을 때 이미지 필요한 경우에 미리 html의 바디 안에 이미지를 이미지태그로 넣고 asset이미지로 선언하고 디스플레이를 넌으로 해서 숨겨놨어서, 이미지는 이미 돔에 로드 된 상태인 것임! 그래서 비동기적으로 기다려줄 필요가 없어서 상관 없었음

-하지만 현재에는 이미지를 따로 불러오지 않았기 때문에 두 순서가 유기적으로 연결되어서 진행되는 것이 아니라 따로 발생해서 엇박자로 연결된 것임

-그래서 src에다가 이미지의 경로를 담는 코드 바로 아래에다가 이미지가 온 로드 시에 ctx에 드로우이미지하는 코드를 onload라는 글로벌이벤트헨들러에 담아주면 이미지가 로드가 끝난 후에 드로우 이미지가 되어서 잘 나오게 됨!
:       // 캔버스에 그리기
      image.onload = ()=>{
        ctx.drawImage(image, 0, 0, canvasWidth, canvasHeight);
      };



-우선 여기에서 마우스를 문질러서 지우는 코드 작업부도 하기 시작함!

-그러기 위해서는 마우스 이벤트를 먼저 등록해야함

-드로우 이미지 바로 아래에다가 온마우스다운 함수를 선언하고, 또 온 마우스 업 함수, 온 마우스 무브 함수를 순선대로 선언해주기
-그리고 각각 콘솔로그를 담아보기
:     function onMouseDown(){
      console.log('onMouseDown');
    }
    function onMouseUp(){
      console.log('onMouseUp');
    }
    function onMouseMove(){
      console.log('onMouseMove');
    }


-그러고나서 아래에다가 윈도우가 아니라 캔버스에 애드이벤트리스너로 각 이벤트 등록해주기
:     // 캔버스에 이벤트 등록
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('mousemove', onMouseMove);


-그리고 마찬가지로, 미리 클린업해주기 위해서 리턴에다가 리사이즈 이벤트를 제거해준것처럼, 리턴에서 리무브이벤트 리스너 추가해주기
:     // Nudake 컴포넌트가 언마운트 될 때 해당 기능들 클린업 시키기
    return ()=>{
      // 캔버스에 등록된 이벤트
      canvas.removeEventListener('mousedown', onMouseDown);
      canvas.removeEventListener('mouseup', onMouseUp);
      canvas.removeEventListener('mousemove', onMouseMove);
      // 리사이즈 함수
      window.removeEventListener("resize", resize);
    }



-잘 찍히는 것 같은데 문제가 하나 있음
-바로 마우스 다운하면 그떄서야 무브 함수가 실행되고, 마우스업하면 무브함수가 멈춰야하는데, 마우스가 움직이기만해도 무브함수가 실행됨
-이걸 막아줘야함
-그러기 위해서 상단에, 커런트 인덱스 변수 아랫줄에다가 isMouseDonw변수를 만들고 flase로 초기화해주기
:     // 마우스다운 감지 변수
    let isMouseDown = false;


-온마우스다운 함수에서 if문으로, 만약 isMouseDown이 true라면 들어오지 못하게 리턴시키기
-그리고 그 아랫줄에서 = false라서 들어온 경우, isMouseDown을 true로 바꿔주기
:     function onMouseDown(){
      if(isMouseDown) return;
      isMouseDown = true;
      console.log('onMouseDown');
    }


-그리고 온마우스업에다가는 isMouseDown을 false로 초기해주기
:     function onMouseUp(){
      isMouseDown = false;
      console.log('onMouseUp');
    }


-그리고 온마우스무브에는 if문으로, isMouseDown이 false라면 못 들어오게 리턴시키기
:     function onMouseMove(){
      if(!isMouseDown) return;
      console.log('onMouseMove');
    }



-->>이러면, 마우스가 다운일때만 무브함수가 실행됨!
-마우스가 업되면 무브함수 실행되지 않음!
-그런데 이 방법을 또 한가지 다른 방법으로 똑같은 결과 만들어 줄 수 있음

-이런 isMouseDown이라는 변수 없이 사용할 수 있는 방법은, 바로 마우스다운 이벤트만 등록시켜주고 그 외의 나머지는 마우스 다운이 일어났을 때에 실행되는 온마우스다운 함수안에서 무브, 업 이벤트를 등록시키는 것임!
: ((아래 코드 삭제))
    // canvas.addEventListener('mouseup', onMouseUp);
    // canvas.addEventListener('mousemove', onMouseMove);

: ((아래 코드 onMouseDown() 함수 블록안에서 추가))
    function onMouseDown(){
      if(isMouseDown) return;
      isMouseDown = true;
      console.log('onMouseDown');

      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mousemove', onMouseMove);
    }


-마찬가지로 클린업도, 마우스 업과 무브는 마우스업이 일어났을 때에 마우스 다운을 제외한 나머지, 마우스다운에서 등록했던 이벤트를 제거해주면!! 마우스 다운을 통해서만 마우스업과 무브이벤트에 접근할 수 있기 때문에 이전과 같은 효과를 줄 수 있음!
: ((아래 코드 제거))
    return ()=>{
      // 캔버스에 등록된 이벤트
      canvas.removeEventListener('mousedown', onMouseDown);
      // canvas.removeEventListener('mouseup', onMouseUp);
      // canvas.removeEventListener('mousemove', onMouseMove);
      // 리사이즈 함수
      window.removeEventListener("resize", resize);
    }



((아래 코드 onMouseUp() 함수에다가 추가하기))
    function onMouseUp(){
      isMouseDown = false;
      console.log('onMouseUp');

      // 마우스업 이벤트가 발생할 때에만 마우스업, 마우스무브 이벤트 제거
      canvas.removeEventListener('mouseup', onMouseUp);
      canvas.removeEventListener('mousemove', onMouseMove);
    }



-그리고 이제 isMouseDown변수 필요 없으니까 변수부터 변수 사용한 코드까지 모두 지워주기
-결과
:     function onMouseDown(){
      console.log('onMouseDown');

      // 마우스다운 이벤트가 발생할 때에만 마우스업, 마우스무브 이벤트 등록
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mousemove', onMouseMove);
    }
    function onMouseUp(){
      console.log('onMouseUp');

      // 마우스업 이벤트가 발생할 때에만 마우스업, 마우스무브 이벤트 제거
      canvas.removeEventListener('mouseup', onMouseUp);
      canvas.removeEventListener('mousemove', onMouseMove);
    }
    function onMouseMove(){
      console.log('onMouseMove');
    }



-이렇게 하면 아까보다 더 간결하게 코드 작성할 수 있음!

-이제 마우스무브 이벤트 등록을 잘 했으니까, 무브시에 캔버스 지워지는 모습을 만들면 됨
-지우는 로직은 조금 특이함!
-정확히는 지우는 게 아니라 그 이미지 위에 반대로 그려주는 거라고 생각하면 됨!



-먼저 마우스 무브 함수 안에 drawCircles라는 함수를 만들고 이벤트 전달하기
    function onMouseMove(){
      console.log('onMouseMove');
      // 원 그리기
      drawCircles(e);
    }
-그리고 온마우스무브함수 아래에다가 darwCircles라는 함수 선언하고 이벤트 받기
    // 지우개역할의 원 그리기 함수
    function drawCircles(e){
      
    }

-그리고 이 함수 안에서는 맨날 ctx로 파티클 공을 arc를 통해 그렸던 것처럼 똑같이 그려줄 것임

-먼저 ctx.beginPath로 패스 그리는 것 알려주기
-그리고 arc로, x,y는 캔버스 위의 내 마우스 좌표를 넣어줘야 하니까 'e.offetX,Y'를 넣어주기
-그리고 반지름은 50, 호는 0부터 360로 그려줘서 원형 그리기
-그리고 fill을 해서 안에 기본값인 검은색으로 채워주기
-그리고 closePath로 패스를 닫아주면 공이 그려짐
:     // 지우개역할의 원 그리기 함수
    function drawCircles(e){
      ctx.beginPath();
      ctx.arc(e.offsetX, e.offsetY, 50, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }

-이렇게 하면 이미지 위에 검정색원이 겹겹이 쌓이면서 그려지는 것임
-바로 여기서 ctx의 글로벌컴포사이트오퍼레이션??을 쓴대;;;;;
-비긴패스를 하기 전에 상단에 ctx.globalCompositeOperation = 'destination-out'을 해주면, 그림을 지워주는 효과가 들어감!
:     function drawCircles(e){
      // 지워주는 효과 넣기
      ctx.globalCompositeOperation = 'destination-out';
      // 원 만들기
      ctx.beginPath();
      ctx.arc(e.offsetX, e.offsetY, 50, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }


-구글에서 검색해보면^^... MDN문서 들어가보면... 중간에 데스티네이션아웃에 대한 설명이 있는데.. 간단히 말하면 이 존재하는 컨텐츠위에 검은색 공이 그려지면, 기존그림을 기준으로 차집합처럼 보이게 만들어주는 효과임....
-그러니까..마우스무브한번 하면 이미지위에 공 하나가 그려지고 그부분만큼 데스티네이션 한  상태에서 또 그 상태를 기존 이미지로 잡고 또 그 위에 공 하나가 그려지면 또 그 부분만 까만 공이 그려지게 되고 그러면 차집합되면서 지우개처럼 지우는 효과가 되는 것임

-기능적으로 글로벌컴퍼사이트오퍼레이션의 디폴트값은 소스오버라는 것인데, 이는 기존그림 위에 새 콘텐츠를 그려서 위에서 덮어씌우는 상태임





-이렇게 캔버스에 공 그리는 작업했는데, 보완해줘야하는 부분이 있음
-가장먼저.... 이 공을 전체 화면으로 봤을때, 마우스를 살살 문지르면 별로 크게 문제 없어보이는데, 근데 만약 마우스를 빠르게 이동할때에는 공의 형태가 뚜렷하게 보이면서 선분이 아니라 점이되어버림 ㅠㅠ

-이 원리를 살펴보기
-두 공이 서로 떨어져서 그려져 있는 상태임
-마우스를 엄청 빠르게 움직이면 마우스무브가 호출되는 사이에 마우스가 너무 멀리 떨어져서 간격이 커질 떄가 있음
-우리가 원하는 것은 이전 마우스의 좌표와 다음 마우스무브했을 때의 그 간극을 촘촘히 매꿔주는 것!임

-우리는 공을 원하는게 아니라 이 공들의 x,y좌표를 알아서 ctx.arc메서드로 공을 그려주기만 하면됨...
-그러니까 이전 위치인 prevPos와 지금 마우스 위치인 newPos의 x, y좌표값을 알아내서 일정한 갯수만큼 좌표를 사이에 넣어주면 됨!
즉, prevPos={x: 100, y:100}이고 nextPos={x:150, y:150}이라 했을 때, 이 이전x와 다음x좌표 사이에 어떤 갯수만큼의 x좌표를 넣어주면! 그 좌표를 따라서 원을 그릴 수 있고, 그것이 연결되면 선분이 되는 것임!



-그러기 위해서는 이전x와 다음x 사이의 거리를 피타고라스 정의로 구해야 함!
-우선은 쉽게 이해하기 위해서 이전x와 다음x 사이에 점을 3개를 넣고 이 5개의 점 사이의 거리를 dist = 5라고 가정해뒀음
-즉, 한 점과 한 점 사이의 거리는 dist = 1인 것임
-그럼 이 이전x와 다음x사이의 첫번째 점과, 이전x와의 각도를 알아야함
-두 점사이의 각도를 세타라고 했을 때, 어느 점들을 비교해봐도 모두 똑같은 각도를 가지게 될 것임!
-그러면 우리는 이전x와 다음x을 이용해서 각도를 구한 다음에, 
-이전x부터 다음x까지 점들에 인덱스번호를 0부터 매겨주면
: x = prevPos.x + Math.cos(세타)*i
이런 식을 만들 수 있음
-Math.cos(세타) * i번째인덱스번호를 하면 0번째 점과 1번째 점을 잇는 선분을 빗변으로 한 직각 삼각형의 아랫변(가로)값을 구할 수 있음!

-마찬가지로 y = prevPos.y + Math.sin(세타) * i라고 하면, 
-높이를 구할 수 있음


-마찬가지로 같은 세타값을 가지고 i대신 2를 넣어서 구할 수 있음
-마찬가지로 같은 공식으로 이전x와 다음x사이를 구할 수 있음!


-먼저 두 점 사이의 거리와 두점사이의 각도를 구하는 함수는 유틸리티성 함수이다보니까 따로 유틸.js로 빼서 정의해주기로 함
-src폴더 안에 새로운 폴더로 utils라는 폴더를 만들고 거기에 utils.js라는 파일 만들기
-그리고 그 안에 getDistance()라는 함수 선언하고 익스포트해주기
-그리고 인자로 p1, p2를 넣고
-p1과 p2사이의 x좌표 차이값을 dx변수에 담기
-그리고 p1과 p2사이의 y좌표 차이값을 dy변수에 담기
: export function getDistance(p1, p2){
  const dx = p2.x - p1.x;
  const dy = p2.y - p2.y;
}

-그리고 피타고라스 정의를 이용해서 리턴하기
: export function getDistance(p1, p2){
  const dx = p2.x - p1.x;
  const dy = p2.y - p2.y;

  // 피타고라스 정의로 거리 구해서 리턴
  return Math.sqrt(dx*dx + dy*dy);
}


-이렇게 하면 두점사이의 거리를 리턴해줌


-그리고 getAngle함수를 선언하고 익스포트해주기
-그리고 p1, p2라는 인자를 받고
-똑같이 x,y의 거리차이를 저장하고
-Math의 a탄젠트2로 두 점사이의 거리차이를 dy, dx값을 순서대로 넣으면 두 점사이의 절대적인 각도를 구해줌
-이를 리턴시키기
: export function getAngle(p1, p2){
  const dx = p2.x - p1.x;
  const dy = p2.y - p2.y;

  // 탄젠트 이용해서 두 점사이의 절대적인 각도 구해서 리턴
  return Math.atan2(dy, dx);
}


-사실 이 매스 a탄젠트2로 두 점 사이의 절대각도를 구하는 부분은 거의 모든 부분에서 공식처럼 사용되고 있기 때문에...이 '에이탄젠트투'를 쓰면 두 점사이의 각도를 구할 수 있다는 것은 외워두면 좋음!!

-이렇게 해두고 다시 Nudake.jsx로 돌아가기
-그리고 이제 이전점과 다음점을 구해서 변수에 담기
-currIndex변수 아랫줄에다가 이전 점인 prevPos를 x는 0 y는 0이라고 초기화해주기
:     // 이미지 인덱스번호 참조
    let currIndex = 0;
    
    // 이전 점의 위치
    let prevPos = {x: 0, y: 0};


-그리고 맨 처음에 마우스 다운이 일어낫을 때, 마우스가 다운된 위치의 x,y값을 prevPos에 넣어줘야함
-이벤트값에서 offsetx,y를 받아와서 prevPos변수의 x,y에 넣어주기
:     function onMouseDown(e){
      console.log('onMouseDown');

      // 마우스다운 이벤트가 발생할 때에만 마우스업, 마우스무브 이벤트 등록
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mousemove', onMouseMove);

      // 마우스다운 발생한 위치값 넣어주기
      prevPos = {x: e.offsetX, y: e.offsetY};
    }



-이제 마우스무브시 드로우서클하는 함수의 최상단에 nextPos변수를 선언하고 마우스무브가 발생하는 위치값을 넣어주기
:     // 지우개역할의 원 그리기 함수
    function drawCircles(e){
      // 마우스 위치값 넣기
      const nextPos = {x: e.offsetX, y: e.offsetY};
...
}




-그리고나서 다음 마우스무브가 일어났을 때에는 현재의 다음점이 이전Pos가 되어야 하니까, 원 그려주는 함수 제일 하단에는 prevPos에 nextPos값을 넣어주면 됨
-그러면 처음에 들어간 위치값이 다음Pos값이었다가 이전Pos값이 됨
:       // 지금 위치값을 이전위치값으로 바꾸기
      prevPos = nextPos;
    }


-그러고나서 넥스트포스 아랫줄에서 dist를 구하면 됨
:     function drawCircles(e){
      // 마우스 위치값 넣기
      const nextPos = {x: e.offsetX, y: e.offsetY};
      // 거리 구하기
      const dist = getDistance(prevPos, nextPos);
...
}

-인자로 이전점과 다음점을 보내줘서 dist값을 구해주기

-마찬가지로 angle도 getAngle을 임포트해와서 이전점과 다음점을 인자로 넣어서 앵글도 구해주기
:       // 각도 구하기
      const angle = getAngle(prevPos, nextPos);



-그 다음에는 for문을 돌면서 i는 dist까지 i++하면서 반복해서 채워주기
-예를 들어서 dist가 5면 5개를 그려서 채워줄것임
-dist가 100이면 이전점과 다음점 사이에 점을 100개 그려서 채워주는 것임

-이 안에서 x, y 구하기
      // 구한 거리만큼 반복해서 이전위치와 다음위치 사이에 원 그려넣기
      for(let i = 0; i < dist; i++){
        // x좌표 구하기
        const x = prevPos.x + Math.cos(angle) * i;
        // y좌표 구하기
        const y = prevPos.y + Math.sign(angle) * i;
      }



-그리고 아까 원 그려주는 코드를 이 for반복문 안으로 옮겨주고, ctx.arc()의 x,y인자를 구해준 x,y변수를 넣어주면 됨
:       for(let i = 0; i < dist; i++){
        // x좌표 구하기
        const x = prevPos.x + Math.cos(angle) * i;
        // y좌표 구하기
        const y = prevPos.y + Math.sign(angle) * i;

        // 지워주는 효과 넣기
        ctx.globalCompositeOperation = 'destination-out';
        // 원 만들기
        ctx.beginPath();
        ctx.arc(x, y, 50, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }



->>이렇게하면 아무리 마우스를 빠르게 움직여도 선분으로 나타나짐!
-for문을 dist까지 1씩 돌면서 더하기 때문에 거의 1픽셀마다 원이 하나씩 그려지기 때문임

-그런데 마우스가 리브되면 마우스무브가 캔슬되지 않은 상태로 떠난 거라서 계속 마우스무브 상태가 남아있음
-따라서, 마우스 리브도 등록하여서 마우스가 캔버스에서 떠나면 무브상태가 끊기도록 만들어주기



-마우스업 함수블록 안에 마우스리브 이벤트를 리무브 시켜주고, 똑같이 마우스다운 함수 블록안에서 마우스 리브 이벤트를 애드해주기
: 

-즉, 마우스 다운 이벤트가 발생하면 마우스다운 함수를 호출하고, 이 함수가 호출되면 마우스업, 마우스립, 마우스무브 이벤트를 감지하게 한다
-마우스가 캔버스에서 벗어날때 즉, 마우스리브이벤트가 발생하면 마우스 업! 함수를 호출하도록 해서 지우기를 멈추게 하는 것이다

-마우스업 함수가 호출되면, 지우는 행동이 끝난 것이므로, 계속 감지해오고 있던 마우스업, 마우스리브, 마우스무브 이벤트를 더이상 감지하지 않도록 막아준다
-마우스리브 이벤트가 감지되면 마우스업함수가 호출되도록 한 것을 여기에서 리무브 시켜줘야한다





[ 캔버스 지운 영역 계산하기 ]
-글로벌 컴퍼사이트오퍼레이션으로 몇퍼센트 정도 구멍을 뚫는지 체크한 후에 그 퍼센트를 넘으면 다음 화면으로 전환되게 함


<<빈 html페이지로 따라해보기>>
-현재 캔버스에 그려진 상태를 이미지데이터로 추출해줄수 있는 메서드
-ctx.getImageData()
-x, y, width, height 순으로 인자를 넣음
-사각형으로 영역을 잡아서 이미지 데이터를 추출해오는 방식임

-오브젝트 형식으로 데이터가 들어옴
-12개의 값이 어레이에 담김.
-1픽셀을 배열에서 r,g,b,a 하나씩 순서대로 넣기 때문에 1픽세를 나타내기 위해서는 4개의 공간이 필요함

-투명하게 지워지는 것 확인하기 위해서는 r,g,b다음의 a! 4배수 간격으로 떨어진 이 a를 체크하면 얼마나 지워졌는지 확인할 수 있음

-투명한 부분이 얼마나 있는지 확인하기 위해서 count변수가 필요함

-for문을 돌면서 투명도가 0인 애들 뽑아내면 됨
-그런데 그냥 i++ 이라고해서 1씩 누적해서 더해주는 것이 아니라, 4의 배수를 더해주면 됨
-이 4를 gap이라는 변수에 담아서 변수화해서 씀
for(let i = 0; i ctx.getIageData.data.length; i += gap){
  ...
}
->콘솔에 i를 찍어보면 "0, 4, 8, ..."순으로 찍히고 있음
-하지만 알파값은 0+3, 4+3, 8+3 위치에 있음
-따라서 i+3을해서 콘솔에 찍어보면 3, 7, 11이 찍힘

-그리고 length도 길이 전체라고하는 게 아니라 -3을 해줘야 정확히 필요한 만큼만 반복함
-그리고 for문 블럭 안에서 if로 조건에 맞춰서 코드 작성하기
-getImageData의 data배열의 인덱스번호가 i+3인 애들이 0이라면 = 투명하다면, 투명도를 체크하는 count변수에 1을 누적해서 더해준다


-전체 픽셀 3픽셀 중에서 카운트를해주면 원하는 퍼센테이지를 구할 수 있음
-전체 갯수 3픽셀의 "3"을구해야하는데, total이라 변수 만들고 이 ctx.getImageData.data.length를 gap(rgba의 a를 구하는 배수)로 나누면 전체 픽셀을 구할 수 있음


-그러고나서 카운트 나우기 총 픽셀수를 해주면, 전체 픽셀에서 투명한 픽셀을 퍼센트로 구할 수 있음

-이걸 좀더 직관적으로 보여주기 위해 백분율로 구해주면 됨
-즉, Math.round()를 써서 반올림해주는데, 이 소괄호 안에서 카운트 나누기 토탈 픽셀수 * 100을 해주면 됨
-이러면 0에서 100사이의 값이 나오게 되고, 소숫점은 반올림하여 정수로만 나타나게 됨!





<<이제 코드로 돌아와서 작성하기>>
-전체 이미지의 픽셀 중에서 투명하게 변한 픽셀의 수를 체크하는 함수를 유틸.js에서 만들도록 함
-utils.js파일 열어서 getScrupedPercent(){}라는 함수 만들고 익스포트하기
-인자로는 ctx, width, height를 받아오기
-pixels라는 변수를 만들고 이미지데이터를 가져와서 저장하기
-그리고 알파값만을 체크하는 변수인 gap은 우선 임의로 32라고 지정하기
: // 문질러서 투명해지는 퍼센트 구하기 함수
export function getScrupedPercent(ctx, width, height){
  // 이미지 데이터 (각 픽셀의 rgba값) 가져와서 저장
  const pixels = ctx.getImageData(0, 0, width, height);
  // a값만 체크하기 위해 배수 지정
  const gap = 32;
}
-왜냐면, 캔버스가 3x1픽셀이 아니라 1000x1000픽셀이라면 총 백만개의 픽셀이 있을테고;
-그러면 저 pixels에는... 총 사백만개의 데이터 array가 있을 것임..
-이 사백만개를 다 돌면 퍼포먼스상에 이슈가 발생할 수 있음
-그래서 적당히 듬성듬성 체크하는 것임
-전에는 1픽셀당 검사를 했지만 이번에는 8픽셀 당 1번씩만 검색하는 것임
-이미지 파일이 크니까 적당히 걸러서 검사하는 것임

-그리고 total은 legth / gap 으로 구하고 count는 우선 0으로 초기화해두기
:   // 총 픽셀 수
  const total = pixels.data.length / gap;
  // 투명해진 픽셀 수
  let count = 0;


-그리고 gap의 배수만큼 rgba가 하나씩 들어간 데이터 배열을 돌면서, 만약 이 데이터 배열의 i+3번째인 알파 값이 0이라면, 즉 투명하다면, count변수에 1을 누적해서 더해줘서 카운트가 증가하도록 만들기
:   for(let i = 0; i < pixels.data.length - 3; i += gap){
    if(pixels.data[i+3] === 0) count++;
  }


-그리고 이렇게 구한 값을 이용해서 백분율로 나타내고, 이를 리턴해주기
:   // 백분율로 나타내서 리턴하기
  return Math.round(count / total * 100);



-이제 누데이크.js로 돌아가서, 마우스무브 이벤트가 발생시 실행되는 onMouseMove함수 블록 하단에서 checkPercent()함수 실행하도록 만들어서, 드로우서클즈로 공을 그리고 데스티네이션-아웃으로 빈 구멍 뚫은 다음에 퍼센트를 체크하도록 하기
:     function onMouseMove(e){
      console.log('onMouseMove');
      // 원 그리기
      drawCircles(e);
      // 투명도 체크하기
      checkPercent();
    }
-이제 이 checkPercent()함수는 drawCircles()함수 아랫줄에서 작성하기
:     // 투명도 체크하는 함수
    function checkPercent(){
      const percent = getScrupedPercent(ctx, canvasWidth, canvasHeight);
    }
-getScrupedPercent함수를 유틸.js에서 임포트해와서 쓰면 됨



-실시간으로 이 몇백만개 이상의 배열을 마우스무브 할 때마다 실시간 체크하면 퍼포먼스에 무리갈 수 있음
-이 체크퍼센트 함수를 지연시켜서 실행되도록 할 예정임
-퍼포먼스 모니터 확인해보면 cpu가 엄청 사용되는게 보임 ㅠㅠ
-쓰로트? 라는 것에 대해 개념 설명...


-throttle(callback, 밀리초)함수를 쓰면 세팅해놓은 밀리초동안 들어오는 요청은 무시하다가 정해놓은 밀리초가 지나면 다시 마우스무브 이벤트가 재생됨
-즉, 수없이 들어오는 이벤트를 일정 간격마다 한번씩만 실행해준다고 보면 됨
-퍼포먼스를 위해 만들어진 유틸리티성 함수임

-이 스로틀을 직접 구현하는공식은 인터넷 찾아보면 많이 있음
-우리는 스로틀 제공해주는 라이브러리를 가져다가 쓸 예정임
-이런 유틸리티성 함수를 모아둔 라이브러리 "로다쉬"라고 있음
: npm install lodash



-누데이크.jsx의 상단에서 임포트 해주기
: import lodash from "lodash";

-여기서의 팁!
-임포트 코스트 라는 vs의 확장 익스텐션을 통해서 임포트해서 쓰는 라이브러리의 용량을 체크할 수 있음
(Import Cost, hyrious에서 만듦)
-용량이 엄청 큰 게 보임
-사실, 이 로다쉬는 엄청 많은 유틸리티를 제공하는 무거운 라이브러리임
-우리는 그중에서 몇가지만 사용하고 싶은 것이라 용량이 무거운 것이 좀 거슬림
-이럴 경우에는 특정 경로의 특정 부분만 임포트해오면 됨
: import throttle from "lodash/throttle";


-이렇게 용량 체크하며 만들면 가벼운 앱 만드는데 도움이 됨
-이 임포트에 관련된 익스텐션 써보는 거 좋음
-그리고 임포트해올때에는 필요 부분만 잘라서 가져오는 것을 추천함


-이제 checkPercent 함수를 throttle을 활용해서 변형하기
:     // 투명도 체크하는 함수
    const checkPercent = throttle(()=>{
      const percent = getScrupedPercent(ctx, canvasWidth, canvasHeight);
      console.log(percent);
    }, 500);


-이렇게하면 몇백만개를 체크하는 이 함수를 0.5초마다 한번씩 실행하도록 코드를 바꾼 것임
-다시 콘솔로 퍼포먼스 확인해보면...  cpu사용량이 확실히 줄어든 것을 확인 가능함
-콘솔 로그도 0.5초마다 한번씩 찍히는 것으로 나옴


-이런식으로 일초에 수십번씩 호출되는 함수를 throttle을 사용해서 지연시켜주면 보다나은 퍼포먼스를 보여줄 수 있음












