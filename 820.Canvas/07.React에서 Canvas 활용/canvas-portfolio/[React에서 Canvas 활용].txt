

[ 프로젝트 구조 작성 ]

-가장 많이 쓰는 리액트를 활용해서 같이 써보는 연습하기 위함
-리액트에서 캔버스 적용하는 부분 어려울 수 있기 때문


-vite라는 것을 통해서 보일러 플레이트 한번에 세팅할 것임
-터미널에 명령어 몇줄 치면 create-reat-app을 통해서 만들어지는 것처럼 보일러 플레이트가 생성됨

-vite : https://ko.vitejs.dev/guide/

-빠르게 빌드해주는 빌드도구!

-기존에 우리가 플젝 진행할 때 index.html, style.css, index.js만들고 모듈타입으로 지정하고 다른 스크립트 파일들을 임포트, 익스포트해서 연결해서 하나의 앱으로 만들어 썼었음
-물리 이펙트 하나 구현하기 위해선 꽤 많은 파일, 폴더가 생성됐음
-그래서 '웹팩'이라고 해서 많은 파일과 npm 으로 설치한 패키지 등 모든 파일을 하나로 묶어서 '번들링'해주는 빌드 툴이 생긴 것임

-이 웹팩도 파일이 많아지고 용량이 커지면 결국 병목현상이 발생하여서..하나로 묶어서 번들링하는데에 시간이 오래 걸리게 됨

-그래서 예를 들어 핫모듈 리플레이스먼트, hmr이라고 불리는 개발 모드에서 코드를 저장할 때마다 로컬에서 실시간으로 수정된 코드가 반영되도록 해주는 기능도 점점 속도가 느려질 뿐더러, 처음 앱 시작하거나 배포하기위해 빌드할 때 속도면에서 문제가 생기게 됨

-그래서 다음 세대로 만들어진 게 이 'vite'임

-es 모듈을 브라우저에서 사용하여 빠른 속도로 브라우저에서 빌드해주기 때문에 굉장히 빠르다고 함

-그래서 번들 생성할 필요 없이 매우 빠르게 구동해주고, hmr = 실시간 코드 반영도 아주 빠르게 해준다고 함

-그리고 초기에 세팅해주는 부분도, 웹팩보다는 간편하게 제공해준다고 함


-실제로 이번 프로젝트에서 사용하는 문법이 거의 없어서 그냥 터미널에서 명령어 실행시키는 정도, 폴더와 파일 구조 정도만 훑어보며 정리해보기로 함



<설치하기>
: npm create vite@latest
->하지만 수업에서 쓰는 버전 맞추기 위해 @4.0.0을 설치하도록 하기

-프로젝트 이름을 지어주기

-그리고 바닐라, 리액트, 뷰 등등 중에서 우리는 리액트 활용할것이므로 리액트 선택하기

-그리고 variant를 선택할 때에 맨 위에 있는 일반 js를 선택하기
->그러면 바로 보일러 플레이트 생성됨

-터미널에서 cd 폴더이름을 써서 해당 보일러 플레이트 파일로 들어가서 거기서 npm install을 입력하여 기본 보일러 플레이트 구조에다가 모듈 설치해주기
: npm install

-그러고 나서 패키지.json을 들어가서 확인해보면 vite가 기본적으로 필요한 디펜던시들을 자동으로 명세해줌
-npm install을 통해서 여기 나열된 패키지들을 설치하는 것임

-그리고 이렇게 준비된 보일러 플레이트를 나중에 실행하기 위해서는 터미널에 'npm run'입력 후 이 패키지.json의 "scripts"에 있는 명령어 중 하나를 써주면 됨
-디벨롭 모드는 npm run dev를 치면 되고, 빌드할때에는 npm run build를 쓰면 됨

-따라서 터미널에서 npm run dev를 쳐서 보일러 플레이트 실행하면 로컬:해당포트 에서 실행되는데, 이걸 복사해서 해당 경로로 들어가면 간단하게 보일러 플레이트 생성됨

-패키지.json을 보면 설치한 패키지 옆에 "^"가 있는데 이는 해당 버전 이상의 패키지를 설치하겠다는 뜻임
-사용자들이 이 프로젝트를 다른 시기에 새로 받아서 npm install을하면, 더 높은 버전을 설치하게돼서 의도치 않는 방향으로 나타날 수 있음
-따라서 이 '락'에서 정확한 버전 명시하여 서로의 의존성을 파악하여 패키지를 설치하기 때문에 협업하는 개발자들 사이에서 동일한 디펜던시를 가진 상태에서 프로젝트를 진행하게 만들어줌

-그리고 vite.config.js파일을 열어보면, vite가 리액트만들 위해서 나온 것이 아니고 다양한 프레임워크에서 지원해주기 때문에, 플러그인-리액트를 다운받아서 리액트를 임포트해와서 리액트를 집어넣어줘야, 리액트 용으로 사용할 수 있게됨

-그리고 패키지.json에 들어가보면 dev디펜던시라는 것도 있음
-이것은 개발,배포할 때 내부적으로 필요한 라이브러리들은 여기에 넣어주면 됨
-실제 앱이 배포될 때에는 디펜던시의 라이브러리만 배포되기 때문에 이 두개를 구분하여 넣어주면 빌드 시간과 퍼포먼스부분에 있어서 시간이 줄어들게 됨

-그리고 gitignore는 제작하기 시작한 앱을 깃허브에 올릴 때 굳이 올릴 필요가 없는 파일이나 파일 형식을 여기에 명시하면 자동적으로 필터링해서 올리지 않음!

-그 외에 나머지는 index.html이나 src폴더에 있는 파일들은 비슷함
-다만 퍼블릭 폴더는 정적엑세스를 위한 폴더임
-npm run build를 하면 우리가 만든 파일을 하나로 빌드해줌
-그러면 dist라는 폴더가 만들어지고, 이 안에서 압축된 js, html, css와 그외에 에셋들임
-그런데 public폴더에 들어있던 vite.svg만 원본 이름이고 나머지는 이름이 바껴있음
-즉, 퍼블릭 폴더는 정적인 파일들을 업로드 시켜주기 위한 파일이라고 보면 됨

-만약 public이라는 이름을 수정하고 싶다면 vite.config.js파일에 가서 추가적으로 세팅해줘야함


-우리는 퍼블릭 폴더에서 에셋 관리할 필요 없기 때문에 패스함

-실제 어플리케이션을 구동할 때에는 dist파일들로 실행됨



<필요 없는 파일 지우기>
-퍼블릭 폴더는 지금 필요 없으니까 폴더째로 지우기

-src폴더>assets의 이미지 파일도 지우기

-App.js에서 쓰인 모든 내용 삭제
-그리고 App.js에서 useState도 지금은 안 쓰니까 삭제
-App.js의 상단에 있는 임포트 구문들도 삭제

-그리고 모든 css파일들도 삭제

-main.jsx로 가서 css파일 임포트 구문도 삭제

-src경로에서 새 폴더를 만들고 style폴더 만들기
-이 안에 index.css파일 1개, reset.css파일 1개 만들기

-index.css파일은 모든 css파일의 공통적인 스타일 관리하는 역할
-reset.css는 html요소마다 들어가있는 기본적인 스타일을 초기화해주는 역할

-reset.css 파일에다가 기본 스타일 초기화해주기
-참고 사이트 : https://meyerweb.com/eric/tools/css/reset/


-그리고 index.css의 최상단에서 reset.css 임포트하기
-그리고 리셋 잘 됐나 확인 위해 html, body에 보더 줘서 테스트하기
-main.jsx에서 index.css파일 임포트 해오기

-npm run dev입력해서 열어보기

->css초기화 확인

-html파일 보면 root라는 id를 가진 div요소가 있는데, 여기에 App.jsx 컴포넌트가 들어가는 것임
-title도 바꿔주기

-main.jsx에서 root요소의 자식으로 StrictMode 모드라는 것도 들어가있는데, 이는 애플리케이션 내의 잠재적 문제 알아내기 위해 넣어주는 것임
-즉, 문제 파악하기 위한 디벨롭 모드용 컴포넌트임

-나중에 app.js에서 프로젝트를 진행하면서 보면, 콘솔창에서 2번찍힐 때가 있음
-리액트의 스트릭트 모드에서 자체 검사를 위해 한번 더 렌더링 한 것임
-이를 방지하기 위해서는 이 컴포넌트를 지워주면 됨
-실제로 프로덕션 용으로 앱을 빌드하면 앱이 1번만 실행되는데, 프로젝트 진행할 때에는 2번 발생하는게 번거로워서 삭제할 수도 있음
(아얘 지워주거나 주석처리해버려도 됨)


-useEffect는 앱 컴포넌트가 위에서 코드 순차적으로 읽어서 실행한 다음, 일어난 코드들이 useEffect안에서 실행됨
-그리고 빈 배열을 두번째 인자로 주면 맨처음 렌더링 된 후에 이 useEffect안의 코드가 1번만 실행이 되지만, 배열안에 값을 넣어주면 그 값이 변경될 떄마다 실행됨
=리렌더링 끝난 후 이어서 useEffect실행됨
=리렌더링 될 때마다 실행됨


-dist폴더는 build아직 하지 않을거니가 만들어본 것 지우기


-stytle폴더에 제네럴 역할하는 index.css와, 스타일 초기화하는 reset.css가 있음
-모든 컴포넌트 한군데에 모아줄 app.jsx와 앱의 기본 세팅 담당하는 main.jsx가 있음
-이 main.jsx 안에서 앱 컴포넌트를 받아서 index.html의 root요소에 연결해서 동작하게 됨



[ ui 구조 작업하기 ]
-기초 뼈대 작업하기

-2개의 캔버스에 다른 기술스택을 사용해서 인터렉티브하게 할 것임

-그전에 미리 캔버스 공간을 넣어두면 작업 편해서
-미리 html,css로 디자인 잡아두기로 함!



-사용할 폰트 가져오기


-스타일을 변수명으로 적용할 수 있음
-변수는 상속성을 가지고 있어서, html에 변수 선언해두면 어느곳에서나 이 변수 사용할 수 있음
-반대로 자식 엘리먼트의 css에서 선언했을 때에는 부모 엘리먼트에서 쓸 수는 없다!

-전체적 통일성 주기 위해서는 최상단인 html에 미리 초기화해주는 것이 좋음




-html, css기본 세팅하기
: html, body{
  --color-border: #938f87;
  --color-bg: #c7c288;
  --color-text: #1b1b19;

  --border01: 1px solid var(--color-border);
  --border02: 6px double var(--color-border);

  font-family: 'Fjalla One', 'Noto Sans KR', sans-serif;
  background-color: var(--color-bg);
  color: var(--color-text);

  overflow-x: hidden;
}



-이제 app.jsx로 가서 클래스명을 소문자 a로 바꿔주고 그 안에 섹션태그 만들고 클래스이름은 섹션-1로 해주기
:     <div className="app">
      <section className="section-1">
        
      </section>
    </div>
-메인 첫 화면 꽉찬 대표 엘리먼트를 이 섹션1이 담당할것임
-그리고 그 안에다가 코드 짜주기
:<header>
          <h1>Portfolio</h1>
          <ul>
            <li>instagram</li>
            <li>twitter</li>
            <li>codepen</li>
          </ul>
        </header>
        <main>
          <div>canvas</div>
        </main>



-헤더와 메인으로 나눔
-메인에 캔버스 쓸 것임

-이제 스타일 잡아주기
: .section-1{
  height: 100vh;
  /* 헤더와 메인 정렬 */
  display: flex;
  flex-direction: column;
}

.section-1 > header{
  height: 8rem;
  box-sizing: border-box;
  border-bottom: var(--border01);
  display: flex;
  justify-content: space-between;
  padding-bottom: 0.5rem;

  font-weight: bold;
}

.section-1 > header > ul{
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 2rem;
  padding-bottom: 0.5rem;
}


-고정 단위인 rem을 썼음.. 반응형으로 작업하면 이쁘겟지만..캔버스 때문에 모바일 반응형 스타일하지 않음;

-메인 스타일링하기
:.section-1 > main{
  padding: 1rem 0;
  display: flex;
  flex-grow: 1;
}
.section-1 > main > div{
  box-sizing: border-box;
  border: var(--border02);
  flex-grow: 1;
}



-이 메인 안에 캔버스 넣을 것이고 , 이걸 포함하는 리액트 컴포넌트는 다음에 작성예정!



-app.jsx로 가서 섹션-2 만들기
:       <section className="section-2">
        What is Lorem Ipsum?
      </section>



-스크래치용으로 유용하게 쓸 의미없는 문장을 만들어내는 사이트로, 만들어내기
-참고사이트 : https://www.lipsum.com/

-우리는 많이는 필요 없으니까...일단은 메인화면에 잇는 것 긁어와서 쓰기

-css스타일 잡아주기
: .section-2{
  background-color: var(--color-text);
  margin: 1rem 0;
  padding: 2rem 0;
  color: #fff;
  display: flex;
  justify-content: center;
  font-size: 9rem;
  letter-spacing: -0.5rem;
}



-약간 신문느낌이 나게 만듦
-2022, 2023 트렌드 중 하나가.. 큰 글씨 사용하는 디자인이라고 함...ㅎ
-어워드나..그런 곳에서 보면 큰 글자 형식으로 웹 디자인 많이 했음...

-2023년 트렌드는...미니멀리즘 형식으로 만들지않고 맥시멀리즘이라고..군데군데 빈 곳없이 인터렉션 만들고 움직이는 아이콘 넣는 게 트랜드래;;



-app.jsx로 돌아가서, 이번에는 section-3 태그 작성해주기
: <section className="section-3">
        <aside>
          <div className="top">

          </div>
          <div className="bottom">
            
          </div>
        </aside>
        <article>
          
        </article>
      </section>


-top와  bottom에 들어갈 텍스트도 아까 그 사이트에서 가져와서 넣기
: <div className="top">
            1914 translation by H. Rackham
          </div>
          <div className="bottom">
            <img src={} />
          </div>


-이미지는 assets에 넣어둔 화살표 이미지를 가져올것임
-상단에서 임포트로 ArrowImg라고해서 상대경로로 가져오기
: import ArrowImg from "./assets/arrow.svg";
-><img src={ArrowImg} />


-아티클에 들어갈 글도 로렘입섬에서 문장 아무거나 발췌해서 가져오기
: <article>
          Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
        </article>


-그리고 css로 가서 섹션3의 스타일도 잡아주기
: .section-3{
  min-height: 50rem;
  display: flex;
  border-top: var(--border01);
  border-bottom: var(--border01);
}

.section-3 > aside{
  width: 40%;
  border-right: var(--border01);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.section-3 > aside > .top{
  padding: 2rem 0 2rem 1rem;
  font-size: 5rem;
  letter-spacing: -0.2rem;
}
.section-3 > aside > .bottom{
  height: 10%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 2rem;
}
.section-3 > aside > .bottom > img:nth-last-child(1){
  transform: scale(-1);
}
.section-3 > article{
  width: 60%;
  padding: 0 3rem;
  display: flex;
  align-items: center;

  font-size: 2rem;
  line-height: 1.3;
}



-화살표 이미지에 스케일-1을 줘서 좌우반전을 줬음



-이제 섹션-4 작업하기
: <section className="section-4">
        <canvas></canvas>
        <aside>
          <h1>Javascript</h1>
          <h2>⭐⭐⭐⭐⭐</h2>
          <p>It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using 'Content here, content here', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for 'lorem ipsum' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).</p>
        </aside>
      </section>



-그리고 다시 css로 돌아가서 섹션4 스타일 입혀주기
: .section-4{
  padding: 5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4rem;
}
.section-4 > canvas{
  width: 50vmin;
  height: 50vmin;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.02);
  box-shadow: inset 0 0 5px 5px rgba(0, 0, 0, 0.2);
}
.section-4 > aside{
  width: 50vmin;
}
.section-4 > aside > h1{
  font-size: 4rem;
  margin-bottom: 0.5rem;
}
.section-4 > aside > h2{
  font-size: 3rem;
  margin-bottom: 2rem;
}
.section-4 > aside > p{
  font-size: 1.2rem;
  line-height: 1.4;
}


-inset으로 내부에 그림자를 줘서 안쪽으로 파인 것 같이 효과를줌




-마지막으로 푸터 작성하기
:       <footer>
        <div className="email">test@test.com</div>
      </footer>


-css로 스타일링해주기
: footer{
  position: relative;
  min-height: 75vh;
  background-color: var(--color-text);
  color: #fff;
}
footer > .email{
  position: absolute;
  bottom: 2rem;
  right: 2rem;
  font-size: 12vmin;
}


-가로사이즈를 꽉 채워서 채우고싶은데 지금 상단에 .app에 max-width가 9120픽셀로 되어 있고.... 이걸로 감싸져있기 때문에
-푸터가 그 안에서 있기 때문에 부모 요소의 .app의 가로값을 상속받게 되어서 안이쁜 것임
-그래서 바깥으로 빼주기

-근데 이렇게만하면 리턴할 때에는 1개 요소만 가능하기 떄문에 에러가 발생함
-그래서 그냥 이거 전체를 감싸는 <></>를 넣어줘서 해결하기
->얘는 리액트.프레그먼트라는 뜻임

-이렇게하면 가로가 꽉차는 검정 푸터가 생김


-이렇게보면 낡은 신문 느낌이 남



[ nudake 작업하기 ]


-첫번째 메인페이지에 캔버스 택스트대신에 캔버스요소 채워서 만들기
-nudake라는 사이트의 메인 컨셉이 화면을 문질러서 다음 이미지가 나오게 만드는 갤러리를 말함
-명사처럼 "누데이크"라고 그냥 이름지음

-src폴더에 containers폴더 만들기
-그 안에 Nudake.jsx파일 만들기
-이 컨테이너즈안에는 특정 기능 하는 컴포넌트들을 담을 예정임

-이 Nudake.jsx는 누데이크 기능하며 캔버스 앨리먼트 리턴해주는 기능 할 것임

-누데이크.jsx에서 함수형 컴포넌트 만들기
:const Nudake = ()=>{
  return(
    <div>
      <canvas></canvas>
    </div>
  )
};

export default Nudake;
-리턴으로 캔버스를 자식으로 갖는 div요소 넣어주기
-그리고 컴포넌트 익스포트시켜주기


-이제 css파일도 하나 만들어줄건데 스타일 폴더 안에다가 똑같이 컨테이너즈 폴더 만들고 그 안에서 똑같은 이름으로 만들어주기

-그리고 방금 만든 css파일을 누데이크.jsx파일에서 임포트해오기
: import "../style/containers/Nudake.css";


-그리고 div의 클래스이름을 nudake라고 해주기
:     <div className="nudake">


-그리고 스타일 잡아주기
:.nudake{
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;

  box-sizing: border-box;
  border: 2px solid red;
}

.nudake > canvas{
  position: absolute;
}
-.nudake를 화면에 꽉차게 w100p, h100p해주고 플렉스 속성으로 정가운데에 정렬하기
-그리고 포지션 랠러티브를 주기

-그리고 누데이크>캔버스에 앱솔루트 포지션 줘서 부모 기준으로 화면에 띄우기

-이렇게 해주는 이유는, 캔버스 지우고 있을 때에 다음 이미지가 보여야하는데, 다음이미지를 캔버스 부모 요소의 배경이미지 속성을 활용할 예정이라 이렇게 함

-그리고 테스트하기위해서 누데이크에다가 보더값 주기




-다시 app.js로 돌아와서 메인 태그 안에 있는 div태그에 쓰인 캔버스 텍스트 지우기
-그리고 이 div박스 안에서 Nudake 컴포넌트 가져와서 넣어주기
: 
<main>
            <div><Nudake /></div>
          </main>


-결과를 보면 빨간 라인이 누데이크고 부모요소를 꽉 채운 게 확인됨

-이제 css에서 보더값 지워주기


-이제 캔버스 그려주면 됨


-Nudake.jsx 상단에서 useEffect실행해주기
: const Nudake = ()=>{
  
  useEffect(()=>{

  }, []);

..
}

-누데이크 컴포넌트가 처음 실행이 되고난 이후에 유즈이펙트 안에 쓰인 코드가 한번만! 실행됨
-돔들이 랜더링된 후에 캔버스가 그 다음에 그려져야하니까 이 유즈 이벡트 안에서 캔버스와 CTX같은 걸 가져와서 여기서 그려주면 됨

-그리고 두번쨰 인자로 []빈배열을 줘서, 처음 딱 한번만 이 블럭 안의 코드를 랜더링하게 만듦
-특별한 상황이 아니라면 이렇게 빈 배열을 넣어줘서 한번만 실행되게 해줘야 좋음


-이제 ctx를 가져와서 해야하는데... 이전까지는 캔버스 앨리먼트 가져올때에 쿼리셀렉터로 가져왔었지만... 만약 이 누데이크컴포넌트 안에 또다른 함수가 있고, 그 함수안에서 캔버스 엘리먼트를 불러와야한다면... 쿼리셀렉터로 불러와야함

-이렇게 매번 쿼리셀렉터로 불러오지말고, 컴포넌트 상단에서 useRef를 써서 먼저 가져와놓기
: const Nudake = ()=>{
  const canvasRef = useRef(null);
...
}
-널로 초기화해준 이유는 처음 누데이크 컴포넌트 렌더링하면서, 아직 캔버스 엘리먼트 코드가 리턴되기도 전에 상단에서 쿼리셀렉터와 같이 없는 것을 초기화시켜줄 수 없기 때문임
-그래서 우선 null값을 넣어주는 것임
-그리고 한번 위->아래로 쭉 읽으면서, 하단 리턴에서 canvasRef변수를 ref로 넣어줌으로써, canvasRef에 해당 캔버스 엘리먼트가 잘 할당됨!
-이렇게 맨 처음 렌더링이 된 후에 useEffect의 내부 코드가 읽히는데, 이게 실행되면서 .current로 해당 엘리먼트를 읽어오는 것임


-그러고 나서 리턴에 있는 캔버스 요소에  ref속성으로 canvasRef넣어주기
:   return(
    <div className="nudake">
      <canvas ref={canvasRef}></canvas>
    </div>
  )


-유즈이펙트 안에서 컨스트 캔버스 = 캔버스Ref.current라고 작성해서, 이런 방식으로 불러오는 게 좋음
:   useEffect(()=>{
    const canvas = canvasRef.current;
  }, []);



-이제 ctx값을 불러오기 위해서 아랫줄에다가 const ctx선언하기
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
...
}


-그리고 캔버스 가로,세로값을 우선 선언만 해주기
:     let canvasWidth, canvasHeight;

-그리고 리사이즈 함수를 만들고 캔버스 가로값은 부모 영역을 꽉 채워야하니까, 부모 요소인 .nudake의 보더값을 제외한 안의 영역을 넣어주면 됨
-따라서 캔버스의 부모요소 변수를 선언해주고 그 안의 client가로,세로값을 저장해주면 됨
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');
...
}

-우선 이렇게 부모 요소 변수 만들고 부모요소 가져온 다음, useEffect 내부 하단에서 resize함수 만들기
: const Nudake = ()=>{
...
    function resize(){ 
    }
  }, []);


-그러고나서, 이 리사이즈 함수 안에서 canvasWidth, height 변수에 부모요소의 client가로,세로값을 할당하기
:     function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;
    }



-캔버스의 사이즈는 2종류니까 이제 고유 사이즈값, css사이즈값 모두 이 canvasWidth와 높이를 이용해서 초기화해주기
:     function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;

      // 캔버스 고유 사이즈
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // 캔버스 CSS 사이즈
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }


-이전에는 dpr도 리사이즈할떄마다 사용했었는데, 여기에서는 dpr이 필요 없음
왜냐? 이미지만 이 요소 사이즈에 맞게 랜더링시켜주면 끝이니까

그리고 이번 예제에서는 마우스무브 할 때마다 캔버스 그리고 지울것이기 때문에 프레임 함수가 들어있는 렌더링 함수 필요 없음



-그래도 일단은 테스트하기 위해서 리사이즈 함수 아랫줄에서 프레임함수 만들기
:     function frame(){
      
    }

-그리고 이 안에서 프레임을 인자로 넣어서 재귀함수로 동작시켜주기
:    function frame(){
      requestAnimationFrame(frame);
    }
-그리고 그 아랫줄에서 fillRect로 정사각형 하나 그려주기
:     function frame(){
      requestAnimationFrame(frame);

      ctx.fillRect(100, 100, 100, 100);
    }
-그리고 프레임 화면 밖으로 나가서, resize이벤트가 발생할때마다 이 리사이즈 함수를 실행해주기
:
    function frame(){
      requestAnimationFrame(frame);

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);
  }, []);



-그리고나서 최초로 리사이즈 함수를 한번 호출해서 초기화해주기
-그리고나서 아랫줄에서 프레임함수를 최초 호출해서 초기화해주기
:  useEffect(()=>{
...
    function frame(){
      requestAnimationFrame(frame);

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);

    resize();
    requestAnimationFrame(frame);
  }, []);



-이러면 정사각형 그려지는 것 확인!
-근데 여기서 중요하게 짚고 넘어가야할 게 있음

-여기 리액트 컴포넌트에서 리퀘스트애니메이션프레임을 실행할떄 주의해야함
-리액트가 만약 다른페이지로 넘어가거나 리액트의 조건부 렌더링으로 이 누데이크 컴포넌트를 다른 컴포넌트로 교체할 때에!!!
컴포넌트가 언마운트되면서 기존 컴포넌트가 없어질 것임

-이때 우리가 재귀함수로 스스로 실행하게 만든 이 리퀘스트 애니메이션프레임은 알아서 중단되지 않음!
-따라서 컴포넌트는 알아서 언마운트되면서 없어지지만 안의 이 로직이 계속 실행되는 문제가 발생함



<예시>
-APP.js로 가서 
앱 컴포넌트 상단에서 토글 state변수를 만들기
: function App() {
  const [toggle, setToggle] = useState(false);
....
}

-그러고나서 헤더 태그의 h1에 있는 로고 글자를 클릭하면 이 토글이 t/f로 계속 바뀌는 클릭이벤트 넣어주기
:           <header>
            <h1 onClick={()=>setToggle(state => !state)}>Portfolio</h1>
...
</header>

-이제 이걸 콘솔창에서 확인해봤을 때 
function App() {
  const [toggled , setToggle] = useState(false);

  console.log(toggled);
->> 계속 t/f바뀌게 됨

-이제 메인태그의 div안에서 toggled state변수가 true가 되면 'toggled' 텍스트가 렌더링되고, false일떄엔 <Nudake/>컴포넌트가 보이게 해주기
:  <main>
            <div>{toggled ? "toggled" : <Nudake />}</div>
          </main>



-이렇게 한 뒤에 h1태그 클릭해보면.. 알아서 글자가 출력되거나 캔버스가 출력됨
번갈아가면서!

-이 toggled텍스트가  출력된다는 뜻 = 지금 돔 트리 구조 안에서 누데이크와 그 안의 캔버스가 언마운트돼서 존재하지 않는 상태가 되었단 뜻
-반대로 돔트리에 존재하고, 텍스트는 조건부 렌더링에 의해 안보이게 됨


-다시 누데이크.jsx로 돌아가서, 프레임 함수 안에서 콘솔.count("프레임")으로 프레임 함수가 호출되는 횟수를 확인해보기
:   function frame(){
      requestAnimationFrame(frame);
      console.count("frame");
-=>>처음에 프레임함수가 재귀함수로써 계속 실행되다가 h1클릭해서 toggled가 ture가 되면 누데이크 컴포넌트는 언마운트되면서 존재하지 않게 되는데, 그래도 콘솔창에는.. 사라지지 않고 계속 돌아가고 있는 게 확인됨!!!!


-따라서 리액트에서 리퀘스트애니메이션 프레임이나 셋인터벌과 같은 함수를 사용할 때에는 꼭 컴포넌트가 언마운트될 때 클린업 잊지 말고 시켜줘야함!!!!
-안그러면 계속 언마운트/마운트 되면서 중첩되어 재귀함수가 실행되면서 퍼포먼스 이슈가 발생함 ㅠㅠ



-이제 누데이크.jsx파일에서 useEffect하단에다가 리턴()=>{} 함수를 써주기
: useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');

    let canvasWidth, canvasHeight;

    function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;

      // 캔버스 고유 사이즈
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // 캔버스 CSS 사이즈
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }

    function frame(){
      requestAnimationFrame(frame);
      console.count("frame");

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);

    resize();
    requestAnimationFrame(frame);

    return ()=>{

    }
  }, []);
-이 부분은 컴포넌트가 언마운트될 떄 실행되는 부분임
-여기다가 캔슬애니메이션프레임(*)함수를 써서 현재 리퀘스트 애니메이션의 id값을 인자로 주면, 지금 재귀로 돌아가는 프레임함수가 멈추게 됨!!

-프레임함수 바로 위에다가 let으로 frameID를 초기화해주고, 이 프레임id 변수에 리퀘스트애니메이션프레임 재귀함수의 리턴값을 저장해주면!
:     // 프레임 ID
    let frameId;

    function frame(){
      frameId = requestAnimationFrame(frame);
      console.count("frame");

      ctx.fillRect(100, 100, 100, 100);
    }

-매 프레임마다 현재 리퀘스트 애니메이션 프래임 함수의 id값이 저장이 됨
-이 아이디 값을 캔슬 애니메이션 프레임의 인자로 넣어주기
:    // 프레임 ID
    let frameId;

    function frame(){
      frameId = requestAnimationFrame(frame);
      console.count("frame");

      ctx.fillRect(100, 100, 100, 100);
    }

    window.addEventListener("resize", resize);

    resize();
    requestAnimationFrame(frame);

    return ()=>{
      cancelAnimationFrame(frameId);
    }
  }, []);
그러면 컴포넌트가 언마운트 될 때 이게 캔슬됨!



->이제 h1요소를 클릭해서 토글해보면!!!! 애니메이션 함수가 캔슬되면서 멈춘다!
->그리고 다시 클릭해서 실행해보면 멈춘 그 순서부터 다시 실행되는게 보인다!



-컴포넌트가 언마운트 될 때에는
1.앱.js에서 지금처럼 스테이트값에 따라서 컴포넌트를 조건부 렌더링 시켜줄떄
2.리액트 라우터 돔을 통해서 다른 주소로 넘어가면 현재 컴포넌트가 언마운트가 될 텐데, 이때도 이 유즈이펙트 안의 리턴함수 실행되면서 언마운트가 됨

-그리고 현재 로직에서 클린업 시켜줘야할 한가지가 있음!
-바로 윈도우 애드이벤트 리스너로 등록한 리사이즈함수임
-이것도 마찬가지로 윈도우의 리사이즈 이벤트를 한번 추가시켜줬다고 한들, 컴포넌트가 어마운트될떄 알아서 같이 삭제되지 않기 때문에!!! 우리가 캔슬시켜줬던것처럼 클린업시켜줘야함

-따라서 리턴 안에다가 윈도우.리무브이벤트리스너"리사이즈",리사이즈함수 를 써서 클린업 시켜주기
:     // Nudake 컴포넌트가 언마운트 될 때 해당 기능들 클린업 시키기
    return ()=>{
      // 리사이즈 함수
      window.removeEventListener("resize", resize);
      // 애니메이션프레임 함수
      cancelAnimationFrame(frameId);
    }





-이제 테스트하기 위해서 만들어두었던 app.jsx의 클릭 이벤트 지워주기~~
-toggled state변수 지우기
-콘솔.로그(toggled)도 지우기
-리턴 부분에서 삼항연산자 써서 조건부 렌더링 시킨것도 지우기~


-여기서 잠깐!!
-아까 윈도우로 에드이벤트리스너로 리사이즈 등록할때에는 유즈이펙트 안에서 꼭 클린업 시켜줘써야했는데.. 온클릭 이벤트는...클린업 왜 안시켜줌??
->> on과 클릭으로 시작하는 onClick이벤트는 리액트 문법으로써, 자체적으로 이 앨리먼트에다가 클릭이벤트 심어주고 언마운트 될때 알아서 클린업됨!
-그래서 신경 안써도 되는 것임



-이번 누데이크 캔버스에서는 움직이는 캔버스를 예제에 활용하지 않기 때문에 이 프레임 함수 지워주면 됨


-하지만 지우기 전에, 이해를 위해서 잠깐 활용해보기로 함




<<연습, 테스트 겸 써보기 : 리액트에서 프레임함수 써보기>>
-이 까만 정사각형 움직여 볼것임

-x,y를 100으로 상수값 주는 게 아님
-프레임 함수 밖에서 x,y를 0으로 초기화하고
-vx, vy를 20으로 초기화
-사이즈를 200으로 초기화시켜주기
:     let x = 0;
    let y = 0;
    let vx = 20;
    let vy = 20;
    let size = 200;

    function frame(){
...
}


-그리고 프레임 함수 안에다가 다음과 같이 코드 작성하기
:     function frame(){
      frameId = requestAnimationFrame(frame);

      if(x < 0){
        x = 0;
        vx *= -1;
      }
      else if(x > canvasWidth - size){
        x = canvasWidth - size;
        vx *= -1;
      }
      else if(y < 0){
        y = 0;
        vy *= -1;
      }
      else if(y > canvasHeight - size){
        y = canvasHeight - size;
        vy *= -1;
      }

      ctx.fillRect(100, 100, 100, 100);
    }


-즉, x가 0보다 작거나 캔버스 가로값-상자크기보다 클때에는, 즉 박스의 오른쪽 면이 캔버스의 오른쪽 끝에 닿을 때 x를 0으로 바꾸고 속도를 반대방향으로바꾸는 것임
-마찬가지로y도 그렇게 해줌

-그리고 x에 vx를 더하고 y에는vy를 더해주기
:      x += vx;
      y += vy;


-그리고 fillRect에 100이라고넣은 상수들을 지우고 x, y size, size를 넣기
:       ctx.fillRect(x, y, size, size);

-그리고 프레임함수 블럭 상단에서 clearRect()로 화면 지워주기
: function frame(){
      frameId = requestAnimationFrame(frame);

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      if(x < 0){
        x = 0;
        vx *= -1;
      }
      else if(x > canvasWidth - size){
        x = canvasWidth - size;
        vx *= -1;
      }
      else if(y < 0){
        y = 0;
        vy *= -1;
      }
      else if(y > canvasHeight - size){
        y = canvasHeight - size;
        vy *= -1;
      }

      x += vx;
      y += vy;

      ctx.fillRect(x, y, size, size);
    }



-이러면 막 움직임
-이게 바로 리액트에서 유즈 이펙트 안에서 캔버스를 애니메이션 시키는 방법임!
-js에서 클래스 쓴것처럼 여기도 클래스 파일 만들고 이 컴포넌트 안으로 임포트해서 사용해도 됨

-if문을 클래스의 업데이트 메서드 안에서 정의하면 됨
-맨아래 fillRect는 드로우 메서드로 이전에 만든것처럼 해도 됨


-이 테스트용으로 작성한코드 싹 다 지우고 아래처럼 남기기
:   useEffect(()=>{
    const canvas = canvasRef.current;
    const canvasParent = canvas.parentNode;
    const ctx = canvas.getContext('2d');

    let canvasWidth, canvasHeight;

    function resize(){
      canvasWidth = canvasParent.clientWidth;
      canvasHeight = canvasParent.clientHeight;

      // 캔버스 고유 사이즈
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      // 캔버스 CSS 사이즈
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }

    // 리사이즈 이벤트 등록하기
    window.addEventListener("resize", resize);
    // 리사이즈 함수 최초 호출
    resize();

    // Nudake 컴포넌트가 언마운트 될 때 해당 기능들 클린업 시키기
    return ()=>{
      // 리사이즈 함수
      window.removeEventListener("resize", resize);
    }
  }, []);





