[ 미니게임 ]
-이전에는 파티클 이펙트와 관련해서 파티클 애니메이션 공부했음
-이번에는 미니게임 만들면서 캔버스와 다른 방식으로 친해지려고 함
-마우스 클릭이벤트만 이용해서 작업 할 예정

-기초뼈대 만들고
-상태관리 필요없는 백그라운드 만들기
-장애물 벽을 클래스로 만들기
-player캐릭터를 클래스로 만들기
-장애물벽과 플레이어간 충돌 감지 로직 만들기
-코인 클래스 만들기
-코인과 플레이어안 충돌 감지 로직 만들기
-스코어 클래스 만들기
-게임 상태에 따른 ui/ux 작업하기




[ 미니게임 뼈대 만들기 ]
-기초 뼈대 구성

-인덱스.js에 바로 코드 작업했지만, 이제는 클래스형태의 앱을 만들고 그걸 인덱스.js에 임포트하는 방식으로 하기

<index.html>
-!쳐서 기본 보일러플레이트 불러와서 세팅하기
-바디 태그에 canvas 태그 넣기
-link태그로 css불러오기

<styel.css>
-html, body요소에 기본 세팅하기
-w100p h100p o m0 bgc#1f1f1f df aic jcc 하기


<index.js>
-우선 만들어두고 여기다 바로 코딩하지 말고, App이라는 클래스 만들어서 그걸로 하기

<App.js>
-export default class App{}로 앱을 클래스로 만들기
-컨스트럭터 사용하기 전에 그 위에 앱 전역에서 사용할 고정 상수값들을 스태틱으로 선언해주기
-먼저 캔버스를 쿼리셀렉터로 가져와서 저장해주고, ctx도 선언해주기
: static canvas = document.querySelector('canvas');
static ctx = App.canvas.getContext('2d');
-> 이렇게 스태틱으로 선언된 값을 쓸 떄에는 클래스명과 스태틱변수명으로 가져오면 됨!

-이전에 우리가 많이 보일러 플레이트를 만들어서 사용한 상수값들을 넣어주기
-dpr도 스태틱으로 넣어주기
-인터벌로 1000 / 60으로 하고
가로는 1024, 세로는 768로 4:3 비율로 만들어주기
: static dpr = devicePixelRatio > 1 ? 2 : 1;
    static interval = 1000 / 60;
    static width = 1024;
    static height = 768;

-리사이즈 함수 만들기
-이 함수에는 캔버스스타일 css의 사이즈와 캔버스 자체 사이즈, scale값을 넣어주기
-캔버스 자체의 가로,세로값은 위에 정의한 값을 쓰면 됨
: App.canvas.width = App.width * App.dpr;
        App.canvas.height = App.height * App.dpr;


->높은 dpr을 지원해주는 기기에서는 큰사이즈를 만들어주는데, 너무 큰사이즈로 만들지 않고 최대 2배 만큼만 크게 만들어서 적당히 선명하게 보여주면서 자원절약할 수 있게 하기

-app.ctx.scale로 dpr을 각각 곱해줘서, 이전에 크게 만들었던 캔버스의 고유사이즈를 dpr이 1일 떄 캔버스에 그려지는 것과 동일시하게 만들어주면서도, 선명도가 차이나게 만들어주기
->근데 이렇게하면 캔버스 크기에 차이가 있으니까 css로 캔버스 요소의 사이즈를 동일하게 맞춰주기

-화면 비율이 4:3으로 정해져있으니까 css도 마찬가지로 비율을 똑같이 해주면 됨
-css 반응형으로 만들어주기 위해
width를 화면의 가로가 세로보다 커지면 widht를 innerHeight에 0.9를 곱한 정도로 만들어주고,
반대로 화면의 세로가 가로보다 커지면 width를 innerwidth에 0.9를 곱한 정도로 만들어주기
->4:3의 비율로 캔버스 스타일이 작성됨
:        const width = innerWidth > innerHeight ? innerHeight * 0.9 : innerWidth * 0.9;
        App.canvas.style.width = width + 'px';
        App.canvas.style.height = width * (3 / 4) + 'px';

-그리고 컨스트럭터 안에 window.addEventListner로 리사이즈될 때 방금 정한 리사이즈 함수가 실행되도록 하기
: 

-resize()만 하면 되는 게 아니고, this.resize.bind(this)라고 해줘야 방금 만든 리사이즈 함수가 실행됨
-이유 : bind(this)를 하지 않고, 리사이즈 함수에서 콘솔.로그(this)를 출력해보면,
지금 처음에는 this가 app클래스를 가리키고 있는데, 리사이즈하기 시작하면 window를 가리키게 됨. 기본적으로 add이벤트리스너로 등록할떄 바인드하지않으면 이벤트를 등록한 주최인 윈도우가 this로 인식하게 됨.
=특별히 바인드 디스를 해주게 되면 현재 부모인 클래스 app이 this로 바인딩되는 것임

->그럼 왜 처음에는 app이 찍힌걸까?
: 좀아까 인덱스.js에서 윈도우가 로드되었을 때 app.리사이즈를 직접 실행해주었기 떄문임. 그 이후에 실행된 콘솔들은 app.js안에 윈도우 이벤트 리스너 리사이즈 이벤트 안에서 실행된 것이기 때문임
->따라서 이렇게 바인드디스를 해줘서 앞으로 리사이즈 함수 내에 선언될 수 있는 this값들을 app클래스 내에 선언한 변수들이나 메서드가 인식될 수 있도록 해주기




->잘 먹혔는지 확인 위해서 index.js로 돌아가서 const app = new App();으로 방금 만든 app클래스에서 app 인스턴스를 만들어서 가져오기!
(물론 최상단에 임포트해야함)
: const app = new App();

-그 다음, 윈도우 로드가 끝났을 때, app.resize메서드를 실행해주기
:window.addEventListener('load', ()=>{
    app.resize();
});


->>이러면 이제 캔버스가 가로 세로의 비율에 따라서 반응형으로 잘 작동하는 것을 볼 수 있음



<렌더 메서드 만들기>
-이제 렌더 메서드를 만들어서 프레임마다 실행되는 모든 내용을 안에 넣어주기

-먼저 주사율이 높은 모니터에서 더 빨리 실행되는 것을 막고, 동일하게 실행되게 하기 위해서 now, then, delta와 interval을 활용해서 만들기

-렌더 함수 안에서 now, delta 변수를 선언하기
-then을 선언하고 Date.now()를 할당하기
-frame함수를 변수에 담아서 할당형으로 만들고, 그 안의 블록에서 리퀘스트 애니메이션 프레임 함수를 호출하고, 인자로 frame을 넣기
:     render(){
        let now, delta;
        let then = Date.now();
        const frame = ()=>{
            requestAnimationFrame(frame);
            
        };
    }
->이렇게하면 144헤르쯔와 60헤르쯔의 모니터에서 다 다르게 실행됨

-이를 막기 위해서 now = 현재시간을 저장해주고, 위에 초기화해준 then과의 차이값을 delta에 넣어주기
: now = Date.now();
 delta = now - then;

-delta값이 interval보다 작으면 리턴시켜주고, 크면 아랫줄이 실행되게 해주면 됨
-그러면 시간을 기준으로 프레임함수를 실행시키기 때문에 주사율이 달라도 동일하게 작동됨
: if(delta < App.interval) return;


-그러고나서 실행할 코드들이 모두 실행된 후 마지막에다가 then값을 교체해주기
: then = now - (delta % App.interval);


->이 부분이 이해가 잘 안되면 이전 영상 참고 플리즈~^^ㅋㅋㅋ



-그리고 프레임 함수 바깥에서 프레임함수를 호출해서 실행하기
: requestAnimationFrame(frame);

->결과 잘 나오나 확인 위해 박스 그려보기
-프레임함수 안에서 app.ctx.clearRect(0 , 0, 가로, 세로);로 일단 이전 프레임 전체 화면을 지우기
: App.ctx.clearRect(0, 0, App.width, App.height);

-그러고나서 app.fillRect()로 사각형 그리기
: App.ctx.fillRect(50, 50, 100, 100);

-그리고 index.js로 돌아가서 렌더함수를 실행해보기
: app.render();

->이러면 사각형이 잘 그려지는 것을 확인할 수 있음





[ 백그라운드 배경 클래스 만들기 ]
-항상 배경이 뒤에서 애니메이션되면서 디폴트로 움직일 수 있도록 먼저 작업해보기

-assets폴더 만들고 거기에 이미지 옮겨두기

-구글에 itch.io 사이트를 검색해서 들어가보면, 많은 게임 개발자들의 작품을 모아둔 인디게임 유통 사이트임
-html5로 만든 게임들도 볼 수 있음
-상단에 브라우즈 게임 탭>assets 탭을 들어가보면 2d게임을 만들 때 유용한 자료들이 많이 있음
-플레이어의 스프라이트 이미지를 애니메이션 시키기 위한 스프라이트png이미지 에셋같은것도 여기서 잘 찾아보면 무료로 괜찮은 에셋들을 다운받을 수 있음

-에셋에 대한 설명, 예시 이미지가 있고 이 에셋을 통해서 구현할 수 있는 애니메이션도 확인 가능함
-맨 하단에 내려보면 다운로드 버튼이 있고, 클릭해보면 다운했을 때 무료일떄 다운받을 수 있는 미리보기용 맛보기 파일이 있고, 유료로 다운받을 수 있는 집 파일이 있음

-본격적으로 2d 웹게임 개발에 관심 있따면 여기서 다운받으면 됨

-다운받아서 열어보면 그리드 형태로 된 png이미지들도 있고, 오브젝트파일에는 맵을 그릴 때 쓸 수 있는 다양한 에셋들이 포함되어 있음

-참고로 우리가 사용할 배경화면도 여기서 다운받음

-레이어로 구성된 여러 이미지를 겹쳐서 애니메이션 효과를 만들도록 제공된 이미지임
-그래서 양쪽 끝이 자연스럽게 연결되도록 만들어진 것을 알 수 있음







<백그라운드 파일 기초 세팅>
-js폴더에 backgorund파일을 만들기
-export default class Background{}해서 클래스를 만들어주기

-이 안에 이전 플젝에서 했던 방식으로... 컨스트럭터, 업데이트, 드로우 순으로 메서드 만들고 정의하기
: export default class Background {
    constructor(){

    }

    update(){

    }

    draw(){
        
    }
}

-이제 백그라운드 클래스 만들었으니까 이미지를 한번 띄워야함
-그러기위해 다시 인덱스.html로 가서 이미지 태그를 만들어서 이미지를 올려보기
: <img src="./assets/bg1.png" id="bg1-img" class="asset-img">
    <img src="./assets/bg2.png" id="bg2-img" class="asset-img">
    <img src="./assets/bg3.png" id="bg3-img" class="asset-img">

-돔 이미지 태그를 애니메이션 시키기 위해서 바디에서 부른게 아니라, 이 불러와진 이미지를 캔버스에서 ctx.드로우 이미지를 하기위해 바디에 넣은 것이기 때문에 지금처럼 화면에 보일 필요가 없음
->따라서 css로 가서 디스플레이:넌으로 안보이게 만들어주기
-하지만 draw이미지를 하게 되면 잘 보일 것임!

-이제 백그라운드.js로 돌아와서 컨스트럭터 안에서 이미지태그들을 불러오기
: constructor(){
        this.img = document.querySelector("#bg1-img");
    }
-그리고 드로우 메서드 안에서 ctx를 가져와야하니까 app을 임포트 한 다음, app.ctx.drawImage를 호출하기
-drawImage(this.img, 0, 0, this.img.width, this.img.height);
->두번째 인자부터는 fillRect와 동일한 내용 넣으면 됨
->>app.js에 이 백그라운드 클래스를 불러오면 그려질 것임!


-App.js에서 컨스트럭터에서 백그라운드 클래스를 불러와서 인스턴스를 생성하기
: this.backgournd = new Background();

-render함수의 블록 안에서..그중에서도 if문 아래쪽에다가! draw함수로 배경을 그려주기
: this.backgournd.draw();

->그러면 내가 만들어둔 캔버스 안에 배경이 그려짐



-그런데 우리가 원하는 배경은... 화면에 꽉 채워진 이미지가 가로로 무한히 이동해야 함
-우선 이미지 크기를 확대해줘야함
-우선 세로크기에 맞게 세로를 늘려주기로 함

<배경을 캔버스 사이즈에 맞게 늘리기>
-백그라운드.js에서 draw함수에서 이미지를 그렸었음
: draw(){
        App.ctx.drawImage(this.img, 0, 0, this.img.width, this.img.height);
    }
-이떄 세로 길이를 이미지의 길이에 맞게 설정해뒀었는데, 우리는 캔버스 세로 크기에 맞게 만들고 싶은 것이니까 세로 크기 인자를 canvas의 세로 크기와 동일한 값을 넣어주면 됨

-컨스트럭터 안에 this.height를 선언하고, app.height로 정해주면 됨
:this.height = App.height;


-가로크기는...이 이미지의 고유 가로값과 세로값을.... 가져올 수 있어서! 비례식으로 이미지의 확대된 크기를 구할 수 있음

-this.width : this.height = App.width : App.height;
-외항과 내항끼리 연산하면,
this.width = App.height * (this.img.height분의 this.img.width)로 구할 수 있게 됨
: this.width = App.height * (this.img.width / this.img.height);

-이렇게 구한 this.width, this.height를 drawImage()함수의 인자로 넣기
: App.ctx.drawImage(this.img, 0, 0, this.width, this.height);

->이러면 캔버스 사이즈에 맞게 배경이미지의 가로,세로값이 확대됨!!


<배경이미지 움직이게 하기>
-그러면 이제 이 배경이미지를 업데이트해서 -20만큼 움직이게 하면 됨
-우선 x와 y가 0,0이 아닌...컨스트럭터에서 따로 선언된 변수여야 함
-x,y를 따로 초기화 하지말고 객체형으로 같이 초기화해주기
: this.pos = { x: 0, y: 0 };

-그러면 이제 draw함수 블록에서 drawImage()메서드를 쓸 때 0,0이 아니라 컨스트럭터에서 선언한 this.pos.x, y를 넣으면 됨
: App.ctx.drawImage(
            this.img, 
            this.pos.x, this.pos.y, 
            this.width, this.height
        );


-그리고 이제 update함수 블록 안에서 this.pos.x를 계속해서 -20 재할당해주면 됨
: update(){
        this.pos.x -= 20;
    }


-그리고 이 update메서드를 app.js의 렌더 함수에서 배경이미지가 드로우 되기 전에 실행시켜주기
: render(){
// 배경이미지 움직이도록 업데이트하기
this.background.update();
// 배경이미지 그리기
this.background.draw();
}


->이러면 배경이미지가 왼쪽으로 이동함


<이미지 무한루프 만들기>
-이미지를 하나 더 뒤에 붙이는 것임!
-이미지가 2개라면 2개의 이미지를 같은 속도로 왼쪽으로 이동시키다가, 왼쪽이미지가 화면 밖으로 완전히 사라지는 순간 오른쪽이미지의 뒤에 다시 갖다 붙이면 무한히 루프되는 모양이 됨
-그럼 왼쪽이미지가 화면에서 완전히 사라지는 순간이 언제일까?
->left.x + this.width가 0보다 작아야함!


-왼쪽이미지, 오른쪽이미지 이렇게 2개의 이미지를 써야 하니까 아까 this.pos로 위치값을 명명한 것을 this.leftPos로 이름을 바꿔주기
: this.leftPos = { x: 0, y: 0 };
-그리고 오른쪽 이미지의 x,y위치값도 초기화해주기
-오른쪽 이미지의 x값은 왼쪽 이미지의 바로 오른쪽에 붙어야하니까, 이미지의 가로만큼 오른쪽으로 떨어진 this.width가 됨
: this.rightPos = { x: this.width, y: 0 };

-그리고 draw메서드 안에서 드로우 이미지()를 2개 만든 다음에, 각각의 인자만 left, right로 바꿔주기
:     draw(){
        // 왼쪽 배경이미지 그리기
        App.ctx.drawImage(
            this.img, 
            this.leftPos.x, this.leftPos.y, 
            this.width, this.height
        );
        // 오른쪽 배경이미지 그리기
        App.ctx.drawImage(
            this.img, 
            this.rightPos.x, this.rightPos.y, 
            this.width, this.height
        );
    }



<업데이트 함수에다가 코드짜기>
-왼쪽 이미지와 오른쪽이미지가 화면 밖으로 벗어나는지 계속 체크해야하기 때문에 업데이트 함수 상단에 if문으로 제어하기
: // 왼쪽 배경이미지가 화면 밖으로 나가는지 체크
        if(this.leftPos.x + this.width < 0) {
            // 오른쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.leftPos.x = this.rightPos.x + this.width;
        }


-오른쪽 배경이미지가 왼쪽으로 벗어날 때도 마찬가지로 해줘야 하기 때문에 반대 상황도 if문으로 제어하기
: // 오른쪽 배경이미지가 화면 왼쪽 밖으로 나가는지 체크
        if(this.rightPos.x + this.width < 0) {
            // 왼쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.rightPos.x = this.leftPos.x + this.width;
        }



-this.left.pos.x에 매 프레임마다 속도를 더해주기
-속도는 this.speed로 컨스트럭터 안에다가 정의한 값 넣어주기
: constructor(){
  this.speed = -20;
}
update(){
// 속도 더하기
        this.leftPos.x += this.speed;
}


-this.rightPos.x에도 똑같이 속도를 주기


->이러면 계속 루프가 되면서 오른쪽으로 이동하는 느낌이 남!
->>그런데 이미지를 바꿔서 #bg2-img를 루프 돌려보면, 약간의 틈새가 벌어진 것을 알 수 있음
-이유? bg2의 png파일을 열어보니 얘만 양 끝이 약간 맞물려있지 않아서 문제가 발생한 것임
-아쉽지만 오른쪽 이미지를 왼쪽 끝에 딱 붙이는게 아니라 -4px만큼 앞으로 당겨서 살짝 겹쳐지게 해서 틈이 안보이게 만들기
: constructor(){
 this.rightPos = { x: this.width - 4, y: 0 };
}

-마찬가지로 업데이트 함수에서도 화면 바깥으로 사라진 이미지를 다음 이미지의 오른쪽에 붙일 때 약간 더 겹치게 붙여야 함
: // 왼쪽 배경이미지가 화면 왼쪽 밖으로 나가는지 체크
        if(this.leftPos.x + this.width < 0) {
            // 오른쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.leftPos.x = this.rightPos.x + this.width - 4;
        }
        // 오른쪽 배경이미지가 화면 왼쪽 밖으로 나가는지 체크
        if(this.rightPos.x + this.width < 0) {
            // 왼쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.rightPos.x = this.leftPos.x + this.width - 4;
        }


-그런데 사실 이 -4는... 옵션에 넣어서 필요한 이미지에만 -4를 더해줘야하지만..우리는 그냥 귀찮으니까^^ 공통적으로 -4px만큼 이동시켜주도록 하기!

-그리고 이제 지금은 특정 이미지만을 위한 백그라운드 클래스가 만들어졌기 때문에
-3가지 이미지 동시 호환이 가능하도록 하기 위해서
-this.img값을 밖에서 연결시켜주도록 하기
-컨스트럭터의 인자로 config로 넣고, this.img에다가 config.img로 바꿔주기
: constructor(config){
 this.img = config.img;
}

-그리고 this.speed또한 config.speed로 바꿔주기
: this.speed = config.speed;


-그리고 app.js로 가서 this.backgorund변수를 s로 바꿔주고 배열형으로 바꿔서
3가지 백그라운드 인스턴스를 넣어주기
: this.backgrounds =[
            new Background({ img : document.querySelector("#bg1-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
        ];



-이제 frame함수로 가서 아까 테스트로 만들어둔 까만 정사각형을 지우고,
-this.backgrounds를 forEach로 돌아서 각각 업데이트와 드로우를 실행해주기
: // 배경이미지 생성
            this.backgrounds.forEach(background => {
                // 배경이미지 움직이도록 업데이트하기
                background.update();
                // 배경이미지 그리기
                background.draw();
            })


-그리고 아까 주석처리해둔 업데이트 함수의 속도 재할당 부분을 주석해제시키기



->그러면 배경이 이동하는 것을 확인할 수 있음
-지금 bg3의이미지가 투명도가 없어서 뒤의 이미지들이 가려져서 안보임
-그래서 bg1과 bg2배경이 가려짐
-따라서 app 클래스의 컨스트럭터에서 배경이미지 인스턴스를 생성할 때 순서를 반대로 3, 2, 1로 바꾸면 가장 나중에 그려지는 1이미지가 맨 앞으로 z인덱스가 제일 높은(?) 맨 앞으로 나오게 됨
: this.backgrounds =[
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg1-img"), speed: -1 }),
        ];


->레이어처럼 먼배경 - 가까운배경 순으로 이미지가 쌓이고 이게 다같이 잘 움직이게 됨

-그런데 다같은 속도로 움직이니까 입체감이 없어보임
-2d이미지에서 원근감을 주기 위해서는 가까이있는 것은 빨리 이동, 멀리 있는 것은 느리게 이동하도록 해야 함
-그래서 가까이에 있는 bg1은 -4 속도를 줘서 가장 빨리 움직이게 하고, 가운데는 -2, 가장 멀리 있는 3은 -1을 주기
: this.backgrounds =[
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -2 }),
            new Background({ img : document.querySelector("#bg1-img"), speed: -4 }),
        ];


->>이러면 입체감이 느껴짐

-그리고 지금까지 캔버스 사이즈 가늠을 위해 설정해둔 보더값을 지워주기






[ wall 클래스 만들기 1 ]
-백그라운드를 게임에 적용했으니, 젤 중요한 역할을 하는 장애물 월 클래스 만들기

-이번시간에도 우리가 원하는 asset을 찾아서 이미지를 한번 더 다른 프로그램을 이용해서 가공한 후 적용해보기

-가공된 이미지가 자료에 포함되어 있으니 원하는 사람만 따라해보기

<이미지 가공하기>
-itch.io 들어가서
태그리스트 중에서 타일셋을 찾아서 고르기


-이미지를 열어보면.... 2d게임 에셋을 자유롭게 만들 수 있도록 파일셋(?)을 세트로 묶음으로 만들어두기 때문에
-우리가 필요한 부분만 갖다가 후가공할 수 있게 해줌
-이떄 필요한 프로그램이 타일드?라는 것임..
: tiled


-파일 실행해보면 빈 화면 나오는데, 뉴맵 하면 사이즈 설정해서 만들면 타일맵이 생성됨
-tlx라는 확장자를 가진 타일형태로 된 맵이 나옴

-나중에 저 안에서 다양한 에셋을 활용해서 2d게임의 맵같은거를 만들 수 있나봄

-레이어를 쌓아서 하나의 이미지를 완성시키는 것임
(하나로만도 만들 수 있음)




<벽 클래스 만들기>
-js파일에다가 Wall.js를 만들기
-index.html에 이미지 요소 하나 추가해서 거기에서 이미지 불러오기
-똑같이 클래스를 asset-img를 줘서 안보이게 해두기

-한 이미지파일에 2가지 이미지를 같이 넣어뒀기 때문에 우리가 잘라서 써야함
-그래서 2가지 타입으로 나누고 빅, 스몰 이렇게! 타입에 대한 것도 바깥에서 받아와서 쓰도록 컨스트럭터에 저장함


-우선 만들어졌는지 확인 위해서 한번 만들어보기!
-App.js파일에서 App클래스의 컨스트럭터에 장애물 배열을 만들기
: this.walls = [new Wall({ type: 'SMALL' })];


-렌더 안에서 배경 코드바로 아래에 forEach()로 똑같이 업데이트와 드로우를 실행시켜주기
: // 장애물 생성
            this.walls.forEach(wall => {
                wall.update();
                wall.draw();
            });




-Wall.js파일로 돌아와서, 이제 여기 컨스트럭터 안에다가 스위치문으로 타입에 따라서 장애물 이미지를 다르게 보이게 함


<이미지 그리기>
-draw 함수에서 ctx를 불러와서 그림 그리면 됨
: App.ctx.drawImage(this.img, 0, 0, 가로값, 세로값);

-가로값은 일단 App.width로 하고 세로값도 App.height로 하기
:     draw(){
        App.ctx.drawImage(
            this.img,
            0, 0, App.width, App.height
        );
    }

->> 이렇게 하면 화면에 2개 타입 장애물이 다 나오게 됨

-근데 우리는 타입에 따라서 잘라서 쓰기로 했으니까, 이럴 떄 쓸 떄에 사용할 수 있는 방법이, drawImage()함수 안에 중간 인자를 더 넣는 것임

-sx, sy, sw, sh가 있음
-잘라서 보여주기 시작할 x, y로부터 가로, 세로크기를 지정해주는 것임

-그러면 우리 예제에서는...시작할 sx, sy는... sy는 항상 0이니까 0으로 시작하고
-sx만 this.sx로 해서 받아오면 됨!!


-앞에 있는 SMALL 타입은 파일 전체 가로크기가 0부터 시작해서 30개의 타일을 쓰니까 보기 좋게... this.width * (0 / 30)으로 적도록 함
-BIG 타입은 9 / 30이라고 하면 될 것 같음
:switch(this.type){
            case 'BIG' : 
                this.sx = this.img.width * (9 / 30);
                break;
            case 'SMALL' :
                this.sx = this.img.width * (0 / 30);
                break;
        }


-sh는 이미지 고유의 사이즈에서 height 전체를 그대로  넣으면 될 것이기 떄문에, this.img.height를 해주면 됨
-sw는 가로는 이미지의 고유 width의 30분의 9임..!

-BIG의 사이즈는 가로 차지하는 타일이 18칸이니까 18 / 30으로 해주면 됨
switch(this.type){
            case 'BIG' : 
                this.sizeX = 18 / 30;
                this.sx = this.img.width * (9 / 30);
                break;
            case 'SMALL' :
                this.sizeX = 9 / 30;
                this.sx = this.img.width * (0 / 30);
                break;
        }



-draw함수에 drawImage함수의 인자로 들어가는 것들 아래처럼 해주면 됨!
: App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            0, 0, App.width, App.height
        );



->>이렇게 하면 big타입이 딱 나옴!
->>다만 이제 캔버스에 실제로 그릴 가로세로를 앱에 맞게 하다보니까 이미지가 늘어나보임
-이제는 실제로 그려질 width와 height를 위에서 재정의해서 넣어주면 됨!


-가로값은 정사각형 이미지 파일 기준으로 this.sizex의 비율만큼 보여주면 되기 때문에 곱해주면 됨
-세로값은 app.hieght그대로 하고 하면 됨
->이러면 작은 벽이 자기 사이즈대로 그려지게 됨

->큰 벽이 잘 그려지는지 확인하고 싶으면 app.js에 가서 인스턴스 생성하는 곳에서 타입을 BIG라고 하면 됨



-윗벽과 아랫벽으로 나누고 그 사이 간격을 랜덤값으로 지정해주기
-캔버스 오른쪽 끝에서 생성하고 왼쪽으로 이동
-그리고 움직이고 있는 사이에 다음 벽을 랜덤한 시간에 생성시키기 + 왼쪽으로 사라진 벽은 배열에서 지워주기





[ Wall 클래스 만들기2 ]
-윗벽과 아랫벽으로 나누고 그 사이 간격을 랜덤값으로 지정해주기
-캔버스 오른쪽 끝에서 생성하고 왼쪽으로 이동
-그리고 움직이고 있는 사이에 다음 벽을 랜덤한 시간에 생성시키기 + 왼쪽으로 사라진 벽은 배열에서 지워주기



<장애물 벽을 윗벽과 아랫벽으로 나눠 만들기>



-갭y라고 이름 지어주고 랜덤값을 주면 통로 사이즈가 랜덤하게 됨
-그리고 갭y가 시작하는 위치도 랜덤하게 줘야지 위쪽에서 만들어지기도하고 아래쪽에서 만들어지기도 하고 할 것임!

-위 벽을 y1 아래벽을 y2라고 했을 때 윗벽인 y1의 최소값은 자신의height만큼 마이너스방향으로 이동했을 때....라고 할 수 있음
-그러면 y2의 시작하는 위치는.... y1에서 벽의 높이를 더하고 거기에 갭y를 더하면 구해질 것임!
=이러면 y1만 생각하면... y1의 최대값은....맨아래지점이 app.height니까 여기서 갭y값을 빼고, 자신의 높이를 뺴면 y1이 가질 수 있는 최대값이 됨!

-그러면 우리는 저 사이에서 랜덤값만 도출하면 됨!




-통과 구간 정의하기
-컨스트럭터에 정의하기...
-this.gapY라고 이름 짓고 app높이의 10퍼센트를 최소값으로하고, 캔버스높이의 20퍼센트정도를 최대값으로 해서 랜덤값 뽑기
: this.gapY = randomNumBetween(App.height * 0.1, App.height * 0.2);

-this.y를 하기 전에, this.x를 0으로 미리 우리가 지정해두기
: this.x = 0;



<y1 정의하기>
-최소값이 -this.height고, 최대값은 캔버스높이에서 갭y를 빼고, 자기 높이만큼 빼면 그 값이 최대값이 됨
-그러니까 여기서 공통되는 값인 -this.height를 바깥으로 빼고, 랜덤유틸함수로 App.height - this.gapY를 뺴면 됨
: this.y1 = -this.height + randomNumBetween(0, App.height - this.gapY);



<y2 정의하기>
-this.y1에다 this.height를 더하고 갭y만큼 더해주면 아랫벽이 시작하는 y위치인 y2구할 수 있음
: this.y2 = this.y1 + this.height + this.gapY;

-이제 드로우 함수 안의 내용을 수정하기
: App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y1, this.width, this.height
        );

-그리고 복사해서 윗벽 아랫벽 이렇게 2개가 되기 위해 하나 더 만들어주는데 y1만 y2로 바꾸면 됨
->>이러면 이제 계속 새로고침해보면 랜덤하게 윗벽아랫벽이 생김

-조금 보완하자면 이미지상에서 상단, 하단에 약간의 여백이 있음! 그래서 윗벽의 최소값이나와버리면 벽이 아예 안보이게 됨!
-그래서 우리가 임의로 수정하도록 함 
-마찬가지로 윗벽의 최대값에 -30을 해서 조금 위로 올려버리기
: this.y1 = -this.height + randomNumBetween(30, App.height - this.gapY - 30);


-갭 수정하기 좋은 방법은 아랫줄에다가 갭y를 오버라이딩해서 값을 테스트해보면 됨
this.gapY = randomNumBetween(App.height * 0.2, App.height * 0.35);
this.gapY = App.height * 0.2; =>이렇게 여기서 오버라이딩해서 테스트해보기


<벽 움직이기>
-배열에 추가,삭제로 관리해주기
-화면 바깥으로 사라졌을 떄 제거하는 것부터 시작하기

-업데이트 메서드 안에서 this.x에 -6을 프레임마다 더해줘서 왼쪽으로 이동
: this.x += -6;
-시작하는 x의 위치도 화면의 오른쪽 끝 안보이는 곳에서부터 등장하도록 App.width를 부여함
: this.x = App.width;

->이러면 오른쪽에서 왼쪽으로 잘 이동됨!


<벽을 배열에서 지우기>
-바깥으로 잘 나갔는지 확인하기 위해서 isOutside라는 getter정의하기
-this.x의(자기자신의) width를 더한 값이 0보다 작아야 안보이게 됨!
-이를 리턴하기
: get isOutside(){
        return this.x + this.width < 0
    }


-app.js로 가서 forEach()로 가서 벽을 그리는 곳에서 getter잘 되는지 확인하기
this.walls.forEach(wall => {
                wall.update();
                wall.draw();

                console.log(wall.isOutside);
            });
->>이러면 완전히 나가면 true가 뜸!


-이제 배열에서 나간 요소를 지우면 됨
-if로 제어문을 만들어서 쓰기!
: this.walls.forEach((wall, idx) => {
                wall.update();
                wall.draw();

                console.log(wall.isOutside);
                // 캔버스 화면 밖으로 장애물이 나가면 배열에서 지우기
                if(wall.isOutside) this.walls.splice(idx, 1);
            });




-forEach로 만들면 배열에 인스턴스가 여러개 들어가있다고 가정했을 떄, 앞의 인스턴스 제거하는 순간 뒤에 실행될 인스턴스의 순서에 영향이 가면서 깜빡임 현상과 같은 부작용이 발생함!
-그래서 for문을 역순으로 돌도록 만듦
: for(let i = this.walls.length - 1; i >= 0; i--){
                this.walls[i].update();
                this.walls[i].draw();
    
                console.log(this.walls[i].isOutside);
                // 캔버스 화면 밖으로 장애물이 나가면 배열에서 지우기
                if(this.walls[i].isOutside) this.walls.splice(i, 1);
            }



<새로운 벽을 생성하는 코드 짜기>
-그 전에 미리 프레임함수 안에서 나중에 코드가 길어지니까.. 미리 보기 쉽게 주석들 달기


-wall.js가서 잠깐 업데이트 메서드안의 내용을 주석처리하기
-그리고 canGenerateNext getter를 만들기
-이건 다음 벽을 생성할수 있는지 체크하는 것임
-컨스트럭터 안에 this.generatedNext라는 변수에 false를 담아두기
: this.generatedNext = false;
-getter에서 저 변수를 ture로 바꿔서 한벽당 한번씩만 다음벽 생성하도록 구조짜면 됨


-벽의 x값에 벽의 가로값을 합친 값이 전체 캔버스의 몇 퍼센트를 지났을 때 다음 벽을 생성할 것인지 정하면 됨
-여기서는 0.7이라고 함. 이 특정값 이하일 때 생성시키면 됨
-이 특정값도 컨스트럭터에서 지정해야함
: get canGenerateNext(){
        return(
            !this.generatedNext &&
            this.x + this.width < this.gapNextX  -> 생성 가능한 시점
        )
    }

-컨스트럭터 안에다가 gapNextX변수를 정해두기
-우선 캔버스 가로값 * 0.6정도 해두기
: this.gapNextX = App.width * 0.6;



-그리고 app.js로 가서 벽을 제거하는 코드 아래에다가 if문으로...해당 벽의 다음벽 생성 가능 여부 확인하는 getter가 true일 경우, 벽을 만들도록 하기
: if(this.walls[i].canGenerateNext){}
-그리고 해당한다면 벽을 만들도록 하는데, 그전에! 한번 벽을 만들면 더이상은 만들지 못하게 generatedNext변수를 ture로 만들어두기 (벽을 이미만들었다는 뜻)
-그 다음 아랫줄에다가 푸시로 만들면 됨
: this.walls.push(new Wall());

-그런데 이때 벽의 타입을 SMALL, 이나 BIG로 둘중 하나를 랜덤하게 골라야 함

-이것도 마찬가지로 랜덤함수를돌림!
-예를들어서, Math.random()의 값이 0.3보다 크면 SMALL타입을, 아니면 BIG을 생성하도록 하기
: this.walls.push(new Wall({ type: Math.random() > 0.3 ? 'SMALL' : 'BIG' }));


->빅타입은 어려운 타입이니까...!

-그리고 splice로 배열을 지운 후에 다음 코드로 넘어가도록 컨티뉴 추가해주기
: if(this.walls[i].isOutside) {
                    this.walls.splice(i, 1);
                    continue
                }


-다시 wall.js로 가서 속도를 좀 빠르게 한 뒤 다시 테스트해보기
-> 잘 출력되는 것 확인 가능함!



-다음 벽을 생성할 시점을 0.8이상으로 하면 벽이 너무 많아져서 플레이하기 어려워지니까, 최대값을 0.7쯤으로 지정해주기
-이 값도 랜덤하게 만들면 더 게임처럼 됨!
: this.gapNextX = App.width * randomNumBetween(0.6, 0.75);


(무인 아이스크림은..... 월세 100이 넘어가면 차리는 의미가 없대....별루....ㅎ)









[ Player 클래스 만들기 ]
-스프라이트 이미지를 애니메이션 시키는 과정을 통해서 클릭 이벤트를 넣어서 상하로만 날개짓하며 움직이도록 하기
-이번 강의에서 만든 걸로 이용해서 충돌 감지하는 기능을 다음시간에 만들기

<플레이어 클래스 만들기>
-js폴더 안에 Player.js 파일을 만들기
-그러고나서 클래스 기본형식 세팅하기
: export default class Player {
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}



-무료 스프라이트 이미지를 찾는 사람들을 위한 사이트 추천
-구글에 'bevouliin.com'이라는 사이트를 검색하면 된다!
-여기는 개인이 운영하는 사이트로, 무료로 제공하기도 하고 유료로 판매하기도 함
-무료이용시 주의할점이 라이센스! 이 사이트는 재배포, 판매하지 않은 이상... 사용 가능함!
-스프라이트 이미지가 각 이미지로 나뉘어서 15장이 들어있을것임!

-근데 우리는 이미지 임포트할 때 용량 절약, 코드에서 사용하기 쉽도록 강사님이 다 이어 붙여서 하나의 파일로 만들어둠!
-투디 에셋들을 다운로드 받아서 사용해보는 것도 좋은 경험이 됨!


-버드 이미지를 에셋폴더로 옮기고, 인덱스.html에서 벽 이미지 아래쪽에다가 새이미지를 불러오기
: <img src="./assets/bird.png" id="wall-img" class="asset-img">


-다시 플레이어.js로 돌아가서, this.img를 쿼리셀렉터로 선택해서 재할당해두기
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");
    }

-드로우 함수에다가 app의 ctx를 불러와서 drawImage 함수로 이미지를 그리기
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            100, 200,   // width, height
            100, 100    // 그릴 x위치, y위치
        );
    }


-app.js안에서 컨스트럭터 안에다가 this.플레이어 선언해주기...
: constructor(){
this.player = new Player();
}


-렌더함수 > 프레임 함수 맨 하단에...물론 then 재할당하기 전에! 거기에다가 방금 만든 인스턴스를 업데이트, 드로우 시켜주기
: render(){
  const frame = ()=>{
    this.player.update();.
    this.player.draw();
  }
}


-다시 플레이어.js 파일로 돌아와서 시작하는 x와 y값을 변수로 빼서 컨스트럭터에서 재정의해주기
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");

        this.x = App.width * 0.1;
        this.y = App.height * 0.5;
    }

- 이렇게 하면 width는 가로의 10프로에 위치, height는 세로의 50퍼센트에 위치하게 됨
-이렇게 하고 아래쪽 드로우에서 100, 200이라고 하드코딩 박아뒀던 것을 바꾸기
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.x, this.y,   // 시작하는 x와 y위치 
            100, 100    // width, height
        );
    }




-그리고 이제 width와 height를 컨스트럭터에서 재정의해주기
-width는 대충 130픽셀정도로 상수로 정의하고, 
-height는 정해진 width와 이미지의 실제 비율을 통해서 구하면 됨
-이미지 파일의 폴더 경로에서 이미지 상세보기로 보면, 가로세로를 알 수 있음!
-이미지 한 프레임의 가로 길이는... 총 15개의 이미지니까 2096픽셀 / 15라고 하면됨!
-2096을 15로 나누면 139.63333333이렇게 나오니까 대충 140픽셀이라고 보면 됨!


-세로 길이는 이미지의 총 길이인 96픽셀이 될 것임
-그러면 이미지의 비율이 가로분의 세로니까 140분의 96픽셀임!
-우리가 가로 길이를 130이라고 정했으니까 비례식으로 구해보면....width * (96 / 140) 이렇게 하면 됨!
: this.width = 130;
        this.height = this.width * ( 96 / 140);



-그러고 이제 draw함수에다가 100이라고 상수 박아둔 것을 바꾸면 됨
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.x, this.y,   // 시작하는 x와 y위치 
            this.width, this.height    // width, height
        );
    }



-이렇게 하면 15개의 이미지가 하나의 프레임에 보여줘야할 이미지 사이즈에 압축돼서 짜부돼서 보여지게됨....
-이제 이걸 보고싶은 부분씩 잘라서 보려면 draw에 인자를 더 추가해서 잘라서 봤었던 그 방식을 그대로 다시 쓰면 됨
-this.img 바로 아래에 sx, sy, sw, sh를 추가하면 된다
-즉, 자르기 시작할 x와 y위치, 자를 영역의 width, height로 설정하면 된다


-첫번째 이미지를 잘라서 캔버스에 그리기 위해서는..........
-sx, sy는 0,0 이면 되고, sw는 전체 이미지 길이에서 15분의1! 각 이미지 갯수만큼 나누면됨
-그리고 sh는 이 이미지가 한줄짜리니까... sh는 이미지 고유의 높이로 하면 된다!

-두번째 스프라이트 이미지를 표현하려면??? 시작할 sy, sw, sh는 이전과 동일하겠지만.. 자르기 시작할 x위치인 sx만 달라지면 된다!
-전체 이미지에서 한 프레임의 길이만큼만 이동하면 되고... 그 다음은 두 프레임의 길이만큼 이동하면 되는 식이다!


-여기서 sy는 항상 0이 될테고, sw는 전체 이미지 가로 길이값을 15로 나누면 된다, 그리고 높이는 이미지의 높이 그 자체가 되면 된다
: sx, 0, this.img.width / 15, this.img.height

-이제 sx는...우선...this.이미지 가로값을 15로 나누고, 첫번째 이미지를 보여주기 위해서는 우선 곱하기 0을 하면...된다!
: App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.img.width / 15 * 0, 0,  // 자르기 시작할 x와 y위치
            this.img.width / 15, this.img.height,    // 자를 영역의 width, height
            this.x, this.y,   // 시작하는 x와 y위치 
            this.width, this.height    // width, height
        );




-그럼 두번째 이미지를 보여주기 위해서는?
-곱하기 0 한 것을 곱하기 1을 해주면 된다!

-프레임에니매이션시켜주기 위해서 이 숫자만 this.frameX라고 컨스트럭터에서 선언해주면 된다
-초기값으로 0을 주고, 0이라고 상수로 박아둔 곳에서 this.frameX라고 변수를 써주면 관리가 된다!
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");

        this.x = App.width * 0.1;
        this.y = App.height * 0.5;
        this.width = 130;
        this.height = this.width * ( 96 / 140);
        // 플레이어 이미지 한 프레임 넘버 (0~14번 프레임)
        this.frameX = 0;
    }
-이렇게하면 원하는 이미지 부위만 잘 보일 것임



-이 이미지의 마지막 프레임값은...총 스프라이트 이미지 갯수가 15개이고 0번째부터 시작이니까.. 14가 마지막 프레임x의 값일 것임
-즉, 이 프레임x값이 15가 되면 이미지가 끝나는 지점이 x좌표가 될 것이니 아무것도 안보이게 된다!

-따라서 업데이트 메서드 안에서 프레임x를 0부터 14까지를 계속 반복하도록 해주면 된다


-우선 업데이트 함수에서 이미지 프레임 넘버를 1씩 증가시키면 매 프레임마다 이미지가 한컷씩 넘어가는데...근데 이렇게 1씩만 증가시키면 날갯짓을 1번만 하게 된다...
-즉 너무 빨리 사라져서 확인이 잘 안된다ㅠ
-따라서 조절해줘야한다
:     update(){
        // 플레이어 이미지 프레임 넘버 넘기기
        this.frameX += 1;

        // 플레이어 이미지 프레임 갯수 반복시키기
        if(this.frameX === 15) this.frameX = 0;

    }



-다른 방법으로는.... %를 사용해서 나눈 나머지값을 활용해도 똑같은 결과가 나오게 된다!
: if(this.frameX % 15 === 0) this.frameX = 0;


-15나누니 15하면 0이되니까 이렇게 0이 되면 다시 0을 할당하도록 하는 것임


-위의 식이 길다 느껴진다면 아래처럼도 쓸 수 있음
: this.frameX = ++this.frameX % 15;
=> this.frameX를 1씩 증가하고, 나눈 나머지 값을 계속 this.frameX에 재할당해주는 것임



-그리고 이 스프라이트 이미지 자체에 애니메이션 속도 조절하고 싶은 경우라면
-컨스트럭터 안에다가 this.counter라는 변수를 만들어주고
: this.counter = 0;

-업데이트 함수에서 카운터 값을 매 프레임마다 1씩 증가시켜주도록 하면 된다
:     update(){
        // 애니메이션 속도 조절 변수 1씩 증가시키기
        this.counter += 1;


-그러고 나서 카운터 변수를 2로 나눈 나머지값이 0이 되면, 프레임 넘버를 증가시키는 식이 실행되도록 하면 된다
:         // 애니메이션 속도 조절하기
        if(this.counter % 2 === 0){
            // 플레이어 이미지 프레임 넘버 넘기기
            this.frameX += 1;
    
            // 플레이어 이미지 프레임 갯수 반복시키기
            // if(this.frameX === 15) this.frameX = 0;  // 방법1
            // if(this.frameX % 15 === 0) this.frameX = 0;  // 방법2
            this.frameX = ++this.frameX % 15;   // 방법3
        }


-이렇게 하면 애니메이션 속도가 반으로 줄어든다
-2대신 3으로 하면 3배 더 느려지고, 10을 쓰면 10배 더 느려지게 된다!


-그리고 'this.counter += 1;'이라는 코드도 마찬가지로, if의 조건문 안에다가 식의 앞에 ++로 연산자로 써줘도 똑같이 된다!
: if(++this.counter % 2 === 0) { ... }


-이렇게 스프라이트 이미지를 표현하는 방식을 배움!

-이제 간단하게 마우스 클릭 이벤트를 넣어서 이 이미지를 상하로 움직여보도록 함



-플레이어.js의 컨스트럭터 안에서 app.캔버스.addEventListener로 클릭 이벤트를 듣도록 하면 됨
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");

        this.x = App.width * 0.1;
        this.y = App.height * 0.5;
        this.width = 130;
        this.height = this.width * ( 96 / 140);
        // 플레이어 이미지 한 프레임 넘버 (0~14번 프레임)
        this.frameX = 0;

        // 애니메이션 속도 조절
        this.counter = 0;

        // 클릭 이벤트 연결
        App.canvas.addEventListener("click", ()=>{});
    }



-클릭하면 플레이어 이미지가 위로 올라가게 할 것임
-캔버스를 아무위치에서나 클릭하게 되면...올라갈건데 vy변수를 활용할 것임!
-우선 컨스트럭터에 vy 선언하고 0 넣어주기
: this.vy = 0;


-이제 여기에 중력을 속도 y값에 더해주기로 함
-컨스트럭터에 그래비티를 선언해주고 0.3정도로 만들어주기
:         // 클릭시 플레이어 이미지 이동 속도
        this.vy = 0;
        // 중력
        this.gravity = 0.3;


-그리고 업데이트 함수에서 vy에다가 gravity를 누적해서 더해주기
: this.vy += this.gravity;
-이 vy값을 this.y에다가 매프레임마다 누적해서 더해주기
:     update(){
        // 애니메이션 속도 조절 변수 1씩 증가시키기
        this.counter += 1;
        // 애니메이션 속도 조절하기
        if(this.counter % 2 === 0){
            // 플레이어 이미지 프레임 넘버 넘기기
            this.frameX += 1;
    
            // 플레이어 이미지 프레임 갯수 반복시키기
            // if(this.frameX === 15) this.frameX = 0;  // 방법1
            // if(this.frameX % 15 === 0) this.frameX = 0;  // 방법2
            this.frameX = ++this.frameX % 15;   // 방법3
        }

        // 클릭시 이동 속도 조절
        this.vy += this.gravity;
        this.y += this.vy;

    }

->이렇게 하면 아래로 가속도를 받아서 이미지가 빠르게 떨어지게 됨


-이제 클릭을 할때마다 이 vy에 -5라는 값을 계속 더해보도록...해보기
-클릭이벤트 안에서 this.vy를 위로 올라가려면 마이너스여야하니까... -5씩 더해주면...!
:         // 클릭 이벤트 연결
        App.canvas.addEventListener("click", ()=>{
            // 클릭 발생하면 vy값에 -5씩 해서 위쪽으로 움직이게 만들기
            this.vy += -5;
        });



->>그러면 이제 클릭 할때마다 조금씩 애가 위로 치솟았다가 떨어진다! 중력 받은것처럼 속도 차이가 나면서!!!!


-근데...시작하자마자 떨어져서 맘의 준비가 안됐음;;;
-첨 시작할때 vy값을 0이 아니라 마이너스 값을 줘서 위로 조금 올라가다가 내려가게 해주겠음!
: this.vy = -10;


->>이 값은 게임 난이도에 따라 다르게 설정해도 될 것 같음 ㅎㅎㅎㅎ



-이제 다음은 충돌감지 기능을 만들 것임!!



[ 장애물 벽과 플레이어 간 충돌 감지하는 기능 만들기 ]

-충돌 되었는지 체크하도록 하기
-그냥 충돌 감지만 하는 것이 아니라 각각에다가 바운딩 박스를 만들어서 씌우고, 그 바운딩 박스 클래스들끼리 충돌을 체크할것임!
-이 이유는 따로 있음~


<박스간의 충돌감지 기본 원리>
-박스1을 오른쪽으로 이동했을 때 박스2랑 충돌된다
= 양 박스의 영역이 교집합이 생긴다
-교집합이 생기는 지점은?
= box1의 x좌표 + box1의 가로값이 box2의 x좌표값보다 같거나 커질 때!
= box1.x + box1.width >= box2.x

-y좌표도 마찬가지임
-아래로 내려오다가 겹치기 시작하는 지점도 x좌표처럼...
-박스1의 y좌표 + 높이값의 지점이 박스2의 y좌표보다 크거나 같을때!
= box1.y + box1.height >= box2.y
-그래야 충돌된다고 할 수 있음

-이 두 조건을 동시에 충족해야하니까 &&가 되어야 한다


-반대로, 박스2가 왼쪽에 있고 박스1이 오른쪽에 있는 상황도 고려해야한다.
-마찬가지로 x 시점 조건은...
= box1.x <= box2.x + box2.width

-마찬가지로 y 시점의 조건은...
= box1.y <= box2.y + box2.height

-이 두 조건을 동시에 충족해야한다!



->> 이 모든 조건들을 모두 충족해야한다! 따라서 조건1 & 조건2 && 조건3 && 조건4 이렇게 해야 한다!
=즉 박스가 어느 구간에 있어도 겹치는 구간이 조금이라도 있으면 모든 조건이 다 충족되는 것이다

-따라서 이 모든 조건이 충족된다면 그 다음 로직, 예를 들면 실패조건띄우기 이런 것을 실행하도록 하면 된다!


<코드 짜기>
-플레이어 클래스와 월 클래스가 직접 충돌감지하지 않고
-충돌 영역을 바운딩박스로 감싸서 할 것임.
-그러니까 바운딩박스 클래스를 따로 만들어야 한다.

-js폴더에다가 BoundingBox.js 를 만든다
-그리고 여기서 바운딩박스 클래스를 만들고, 컨스트럭터와 드로우 메서드를 만들어준다.
: export default class BoundingBox{
    constructor(){
        
    }
    draw(){

    }
}

-인스턴스를 만들 떄 바깥에서 차례로 x,y,width,height를 받아와서 this로 저장해주기
:     constructor(x, y, width, height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }



-드로우 메서드에서는 App을 불러와서 ctx.fillstyel에 컬러 지정하기
-그리고 지정할 컬러는 인스턴스를 만들 떄 바깥에서 받아오게 하기 위해 this로 지정하기
:     constructor(x, y, width, height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        
        this.color = "rgba(255, 0, 0, 0.3)";
    }
    draw(){
        App.ctx.fillStyle = this.color;
        App.ctx.fillRect();
    }


-그리고나서 방금 this라고 작성한 x,y,width,height를 모두 fillRect에다가 넣어주기
:     draw(){
        App.ctx.fillStyle = this.color;
        App.ctx.fillRect(this.x, this.y, this.width, this.height);
    }



-이제 플레이어 클래스 안에서 바운딩박스를 지정해줄것임
-플레이어 클래스의 컨스트럭터 안에다가 this.boundingBox로 인스턴스 새로 만들어서 선언하기
-그리고 인자로 이 플레이어의 x,y,w,h모두 다 넣기
: (player.js에서)
export default class Player {
    constructor(){
        // 충돌 감지용 바운딩 박스
        this.boundingBox = new BoundingBox(this.x, this.y, this.width, this.height);
    }
}


-이제 드로우 메서드 안에다가 먼저 플레이어 그리는 작업이 끝나면 그 다음에 this.boundingBox.draw를 실행시켜주기
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.img.width / 15 * this.frameX, 0,  // 자르기 시작할 x와 y위치
            this.img.width / 15, this.img.height,    // 자를 영역의 width, height
            this.x, this.y,   // 시작하는 x와 y위치 
            this.width, this.height    // width, height
        );
        // 바운딩 박스 그리기
        this.boundingBox.draw();
    }



-이후 화면 보면 플레이어를 감싸는 박스가 생김!
-이걸 통상적으로 "바운딩박스"라고 부름
-이 박스를 다른 바운딩박스와 겹치는지, 나중에 콜라이딩 체크를 해 줄 것임
-그런데 그 전에 App.js에서 플레이어에 업데이트가 있었을 떄에는.... 바운딩 박스와 플레이어의 위치가 맞지 않게 된다!

-플레이어.js에서 처음에 박스가 만들어질 떄에는 초기값을 잘 넣어서 맞았지만.. 이후에는 값이 업데이트되어서 변동되었기 떄문!

-따라서 플레이어의 바뀐 y값을 바운딩박스의 y으로 다시 넣어줘야 한다!
-플에이어.js로 가서, 업데이트 함수에서, 클릭하면 y에다가 변동값을 넣어준것 처럼 똑같이 아랫줄에다가 바운딩박스의 y값을 업데이트해준다
: update(){
        // 클릭시 이동 속도 조절
        this.vy += this.gravity;
        this.y += this.vy;

        // 바운딩박스 y좌표값 업데이트하기
        this.boundingBox.y = this.y;

    }



-이렇게하면 따로 노는 문제 해결할 수 있따!
->이렇게 하고 확인해보면 된다~





<월 클래스에 바운딩박스 만들기>
-월.js에서 마찬가지로 바운딩박스 인스턴스를 만들어줘야하는데
-여기서는 하나가 아니라 2개를 만들어야한다
-왜냐? 클래스 뜯어보면 윗벽,아랫벽 이렇게 2개를 따로 드로우해주기 떄문이다
-위에 충돌하든 아래에 충돌하든 똑같이 충돌한것으로 여겨야 하기 떄문임


-wall.js의 컨스트럭터 안에다가 바운딩박스 인스턴스를 새로 만들어서 2개를 선언해주기
: export default class Wall{
    constructor(config){
        // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x, this.y1, this.width, this.height);
        this.boundingBox2 = new BoundingBox(this.x, this.y2, this.width, this.height);
    }


-그리고 wall.js의 드로우함수 안에서 벽 이미지가 모두 그려진 다음에 바운딩박스를 그려주면 된다
:     draw(){
        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y1, this.width, this.height
        );
        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y2, this.width, this.height
        );

        // 충돌감지용 바운딩박스 그리기
        this.boundingBox1.draw();
        this.boundingBox2.draw();
    }


-아직 벽이 보이지 않는 이유는...업데이트 함수를 주석처리했기떄문!
-App.js파일로 가서 프레임함수 안에 있는  벽 생성관련된 코드있는 곳에 있는 업데이트함수 주석풀기!
: for(let i = this.walls.length - 1; i >= 0; i--){
                this.walls[i].update(); ->>이거 풀면됨!

-근데 이래도 안보이는 이유는??바로...플레이어에다가 바운딩박스 작업할떄와 똑같은 이유임!
-맨처음에 바운딩박스를 그린 그 위치에서 자꾸 업데이트되는데 바운딩박스는 위치가 고정되어 있어서 그런 것임!

-wall.js에서도 업데이트안에 벽의 x값이 바뀔때 this.boundingBox1,2의 x값도 마찬가지로 동적으로 바꿔서 싱크를 맞춰줘야한다
: update(){
        this.x += -6;

        // 충돌감지용 바운딩박스 x좌표 업데이트하기
        this.boundingBox1.x = this.x;
        this.boundingBox2.x = this.x;
        // this.boundingBox1.x = this.boundingBox2.x = this.x; // 위의 2줄 코드와 동일함
    }



-이 바운딩박스와 플레이어간의 충돌감지를 할 수 있게 됨!

-그럼 이제 우리가 이해한 4가지 조건을 작성해야함
-바운딩박스.js로 돌아와서, 드로우메서드위에 isColliding이라는 메서드를 만들어주기
-인자로는 target을 가져오기
:     // 충돌 감지 메서드
    isColliding(target){

    }
-불리언을 리턴해줄 것임
-여기에서 아까 고민한 4가지 조건을 작성해주기
:     // 충돌 감지 메서드
    isColliding(target){
        return(
            target.x + target.width >= this.x &&
            target.x <= this.x + this.width &&
            target.y + target.height >= this.y &&
            target.y <= this.y + this.height
        )
    }



-이렇게하면 조금이라도 교집합이 생긴다? = 4가지 조건 달성한다는 뜻!
-이제 wall.js에가서 똑같이 isColliding 메서드를 만들어주기
-업데이트 메서드위쪽에다가 만들기
:     // 충돌 감지 메서드
    isColliding(target){
        return(
            this.boundingBox1.isColliding(target) ||
            this.boundingBox2.isColliding(target)
        )
    }

-이렇게 작성해야 한 벽클래스에 존재하는 2가지 벽 중 하나라도 닿아서 충돌하는지 체크할 수 있게 된다




-이제 플라이어와 벽을 어디서 실시간으로 감지할것인가를 고민해야함
-플레이어를 현재 생성되어있는 벽들이랑 포문으로 한번씩 돌면서 이즈콜라이딩으로 체크해줘야한다
-app.js파일로 가보면 이미 월인스턴스들이 포문안에서 돌고있는 구간이 있음!
-그래서 여기서 그냥 플레이어와의 충돌체크를 해주기로 함!
-벽 생성 for문 내부의 맨아래에다가 관련 코드를 작성하기
: if(this.walls[i].isColliding(this.player.boundingBox))
-이렇게...써서...! 만약 i번째 벽이 타겟인 플레이어의 바운딩박스와 충돌된다면, 즉 true가 반환된다면 블럭내의 코드 실행하게 하자
: // 장애물 벽 생성
            for(let i = this.walls.length - 1; i >= 0; i--){
                 // 벽과 플레이어 충돌 감지하기
                if(this.walls[i].isColliding(this.player.boundingBox)){
                    console.log("colliding!!!!");
                }
            }



-간단하게 플레이어 충돌을 감지하는 로직 구현완성~~!!
-이제 아쉬운 부분 보완하기!


-벽의 위치를 임의로 조정해보기
-그래보면 플레이어와 벽의 충돌 영역을 보면 필요이상으로 쓸데없이 공간이 많이 남는 것을 확인할 수 있음
-이건 드로우이미지를 하는 과정에서 이미지를 자르는 부분에 한계가 있어서 그런 것임
-이 x,y,w,h를 그대로 가져오니까 바운딩박스에도 의도치않게 불필요한 영역이 생긴것임
-이걸 간단하게..잘라보기!


-wall.js에서 처음에 init하는 과정에서 인자로 받아간 this.x를 뒤로 밀어버리면 됨
-이 this.x에다가 + 30을해서 밀어버리면됨!
:         // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x + 30, this.y1, this.width, this.height);
        this.boundingBox2 = new BoundingBox(this.x + 30, this.y2, this.width, this.height);

-마찬가지로 드로우와 업데이트함수 안에서도 +30을 해줘야함
: update(){
        this.x += -6;

        // 충돌감지용 바운딩박스 x좌표 업데이트하기
        this.boundingBox1.x = this.x + 30;
        this.boundingBox2.x = this.x + 30;
        // this.boundingBox1.x = this.boundingBox2.x = this.x; // 위의 2줄 코드와 동일함
    }

-드로우도 동일하게 바운딩박스의 x좌표값에 30더하기
: draw(){
        // 테스트용
        this.x = 700;
        this.boundingBox1.x = this.boundingBox2.x = this.x + 30;

        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y1, this.width, this.height
        );
        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y2, this.width, this.height
        );

        // 충돌감지용 바운딩박스 그리기
        this.boundingBox1.draw();
        this.boundingBox2.draw();
    }


-width는 반대로 -60을 줄여주면...! 바깥쪽 이끼를 제외하고 딱딱해보이는 벽 영역만큼만 바운딩박스가 생성됨!
:         // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x + 30, this.y1, this.width - 60, this.height);
        this.boundingBox2 = new BoundingBox(this.x + 30, this.y2, this.width - 60, this.height);


-마찬가지로 y와 height도 똑같이 해주면 된다!
:         // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x + 30, this.y1 + 30, this.width - 60, this.height - 60);
        this.boundingBox2 = new BoundingBox(this.x + 30, this.y2 + 30, this.width - 60, this.height - 60);



-그러면 이렇게 합리적으로 충돌 지점을 수정할 수 있다


-플레이어도 마찬가지로 보면... 박스를 조금 줄여줘야...된다!

-플레이어.js파일에가서 컨스트럭터에서 충돌감지용 바운딩박스 init하는 부분에서 = 즉 새로운 인스턴스 생성하는 부분에서 적당한 수치를 더하거나 빼서 박스 사이즈를 플레이어 이미지와 비슷하게 줄여준다
:         // 충돌 감지용 바운딩 박스
        this.boundingBox = new BoundingBox(this.x + 10, this.y + 16, this.width - 20, this.height - 20);


-그리고 마찬가지로 박스와 플레이어 이미지의 이동 싱크를 맞추기 위해서 업데이트 함수 안에서 바운딩박스의 y값 업데이트 하는 곳에서 똑같이 + 16을 해주면 된다
: // 바운딩박스 y좌표값 업데이트하기
        this.boundingBox.y = this.y + 16;




-그리고 콘솔창에서 충돌했다고 확인하는 것보다 시각적으로..충돌됐음을 표현하기 위해서 소this.player.boundingBox.color를 변경해주는게 더 좋아서 그렇게 바꿨따
: this.player.boundingBox.color = `rgba(255, 0, 0, 0.3)`;
-그리고 충돌이 아닐 경우에는 색상을 파란색으로 바꿔줬다!
:                 // 벽과 플레이어 충돌 감지하기
                if(this.walls[i].isColliding(this.player.boundingBox)){
                    // console.log("colliding!!!!");
                    
                    // 충돌(true)시 바운딩박스 색상 변경
                    this.player.boundingBox.color = `rgba(255, 0, 0, 0.3)`;
                }
                else{
                    this.player.boundingBox.color = `rgba(0, 0, 255, 0.3)`;
                }



-이렇게 하고 wall.js에 가서 아까 테스트 하기 위해서 바운딩박스 위치를 고정시켰던 코드를 지우고 확인하면 된다!






