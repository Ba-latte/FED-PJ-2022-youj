[ 미니게임 ]
-이전에는 파티클 이펙트와 관련해서 파티클 애니메이션 공부했음
-이번에는 미니게임 만들면서 캔버스와 다른 방식으로 친해지려고 함
-마우스 클릭이벤트만 이용해서 작업 할 예정

-기초뼈대 만들고
-상태관리 필요없는 백그라운드 만들기
-장애물 벽을 클래스로 만들기
-player캐릭터를 클래스로 만들기
-장애물벽과 플레이어간 충돌 감지 로직 만들기
-코인 클래스 만들기
-코인과 플레이어안 충돌 감지 로직 만들기
-스코어 클래스 만들기
-게임 상태에 따른 ui/ux 작업하기




[ 미니게임 뼈대 만들기 ]
-기초 뼈대 구성

-인덱스.js에 바로 코드 작업했지만, 이제는 클래스형태의 앱을 만들고 그걸 인덱스.js에 임포트하는 방식으로 하기

<index.html>
-!쳐서 기본 보일러플레이트 불러와서 세팅하기
-바디 태그에 canvas 태그 넣기
-link태그로 css불러오기

<styel.css>
-html, body요소에 기본 세팅하기
-w100p h100p o m0 bgc#1f1f1f df aic jcc 하기


<index.js>
-우선 만들어두고 여기다 바로 코딩하지 말고, App이라는 클래스 만들어서 그걸로 하기

<App.js>
-export default class App{}로 앱을 클래스로 만들기
-컨스트럭터 사용하기 전에 그 위에 앱 전역에서 사용할 고정 상수값들을 스태틱으로 선언해주기
-먼저 캔버스를 쿼리셀렉터로 가져와서 저장해주고, ctx도 선언해주기
: static canvas = document.querySelector('canvas');
static ctx = App.canvas.getContext('2d');
-> 이렇게 스태틱으로 선언된 값을 쓸 떄에는 클래스명과 스태틱변수명으로 가져오면 됨!

-이전에 우리가 많이 보일러 플레이트를 만들어서 사용한 상수값들을 넣어주기
-dpr도 스태틱으로 넣어주기
-인터벌로 1000 / 60으로 하고
가로는 1024, 세로는 768로 4:3 비율로 만들어주기
: static dpr = devicePixelRatio > 1 ? 2 : 1;
    static interval = 1000 / 60;
    static width = 1024;
    static height = 768;

-리사이즈 함수 만들기
-이 함수에는 캔버스스타일 css의 사이즈와 캔버스 자체 사이즈, scale값을 넣어주기
-캔버스 자체의 가로,세로값은 위에 정의한 값을 쓰면 됨
: App.canvas.width = App.width * App.dpr;
        App.canvas.height = App.height * App.dpr;


->높은 dpr을 지원해주는 기기에서는 큰사이즈를 만들어주는데, 너무 큰사이즈로 만들지 않고 최대 2배 만큼만 크게 만들어서 적당히 선명하게 보여주면서 자원절약할 수 있게 하기

-app.ctx.scale로 dpr을 각각 곱해줘서, 이전에 크게 만들었던 캔버스의 고유사이즈를 dpr이 1일 떄 캔버스에 그려지는 것과 동일시하게 만들어주면서도, 선명도가 차이나게 만들어주기
->근데 이렇게하면 캔버스 크기에 차이가 있으니까 css로 캔버스 요소의 사이즈를 동일하게 맞춰주기

-화면 비율이 4:3으로 정해져있으니까 css도 마찬가지로 비율을 똑같이 해주면 됨
-css 반응형으로 만들어주기 위해
width를 화면의 가로가 세로보다 커지면 widht를 innerHeight에 0.9를 곱한 정도로 만들어주고,
반대로 화면의 세로가 가로보다 커지면 width를 innerwidth에 0.9를 곱한 정도로 만들어주기
->4:3의 비율로 캔버스 스타일이 작성됨
:        const width = innerWidth > innerHeight ? innerHeight * 0.9 : innerWidth * 0.9;
        App.canvas.style.width = width + 'px';
        App.canvas.style.height = width * (3 / 4) + 'px';

-그리고 컨스트럭터 안에 window.addEventListner로 리사이즈될 때 방금 정한 리사이즈 함수가 실행되도록 하기
: 

-resize()만 하면 되는 게 아니고, this.resize.bind(this)라고 해줘야 방금 만든 리사이즈 함수가 실행됨
-이유 : bind(this)를 하지 않고, 리사이즈 함수에서 콘솔.로그(this)를 출력해보면,
지금 처음에는 this가 app클래스를 가리키고 있는데, 리사이즈하기 시작하면 window를 가리키게 됨. 기본적으로 add이벤트리스너로 등록할떄 바인드하지않으면 이벤트를 등록한 주최인 윈도우가 this로 인식하게 됨.
=특별히 바인드 디스를 해주게 되면 현재 부모인 클래스 app이 this로 바인딩되는 것임

->그럼 왜 처음에는 app이 찍힌걸까?
: 좀아까 인덱스.js에서 윈도우가 로드되었을 때 app.리사이즈를 직접 실행해주었기 떄문임. 그 이후에 실행된 콘솔들은 app.js안에 윈도우 이벤트 리스너 리사이즈 이벤트 안에서 실행된 것이기 때문임
->따라서 이렇게 바인드디스를 해줘서 앞으로 리사이즈 함수 내에 선언될 수 있는 this값들을 app클래스 내에 선언한 변수들이나 메서드가 인식될 수 있도록 해주기




->잘 먹혔는지 확인 위해서 index.js로 돌아가서 const app = new App();으로 방금 만든 app클래스에서 app 인스턴스를 만들어서 가져오기!
(물론 최상단에 임포트해야함)
: const app = new App();

-그 다음, 윈도우 로드가 끝났을 때, app.resize메서드를 실행해주기
:window.addEventListener('load', ()=>{
    app.resize();
});


->>이러면 이제 캔버스가 가로 세로의 비율에 따라서 반응형으로 잘 작동하는 것을 볼 수 있음



<렌더 메서드 만들기>
-이제 렌더 메서드를 만들어서 프레임마다 실행되는 모든 내용을 안에 넣어주기

-먼저 주사율이 높은 모니터에서 더 빨리 실행되는 것을 막고, 동일하게 실행되게 하기 위해서 now, then, delta와 interval을 활용해서 만들기

-렌더 함수 안에서 now, delta 변수를 선언하기
-then을 선언하고 Date.now()를 할당하기
-frame함수를 변수에 담아서 할당형으로 만들고, 그 안의 블록에서 리퀘스트 애니메이션 프레임 함수를 호출하고, 인자로 frame을 넣기
:     render(){
        let now, delta;
        let then = Date.now();
        const frame = ()=>{
            requestAnimationFrame(frame);
            
        };
    }
->이렇게하면 144헤르쯔와 60헤르쯔의 모니터에서 다 다르게 실행됨

-이를 막기 위해서 now = 현재시간을 저장해주고, 위에 초기화해준 then과의 차이값을 delta에 넣어주기
: now = Date.now();
 delta = now - then;

-delta값이 interval보다 작으면 리턴시켜주고, 크면 아랫줄이 실행되게 해주면 됨
-그러면 시간을 기준으로 프레임함수를 실행시키기 때문에 주사율이 달라도 동일하게 작동됨
: if(delta < App.interval) return;


-그러고나서 실행할 코드들이 모두 실행된 후 마지막에다가 then값을 교체해주기
: then = now - (delta % App.interval);


->이 부분이 이해가 잘 안되면 이전 영상 참고 플리즈~^^ㅋㅋㅋ



-그리고 프레임 함수 바깥에서 프레임함수를 호출해서 실행하기
: requestAnimationFrame(frame);

->결과 잘 나오나 확인 위해 박스 그려보기
-프레임함수 안에서 app.ctx.clearRect(0 , 0, 가로, 세로);로 일단 이전 프레임 전체 화면을 지우기
: App.ctx.clearRect(0, 0, App.width, App.height);

-그러고나서 app.fillRect()로 사각형 그리기
: App.ctx.fillRect(50, 50, 100, 100);

-그리고 index.js로 돌아가서 렌더함수를 실행해보기
: app.render();

->이러면 사각형이 잘 그려지는 것을 확인할 수 있음





[ 백그라운드 배경 클래스 만들기 ]
-항상 배경이 뒤에서 애니메이션되면서 디폴트로 움직일 수 있도록 먼저 작업해보기

-assets폴더 만들고 거기에 이미지 옮겨두기

-구글에 itch.io 사이트를 검색해서 들어가보면, 많은 게임 개발자들의 작품을 모아둔 인디게임 유통 사이트임
-html5로 만든 게임들도 볼 수 있음
-상단에 브라우즈 게임 탭>assets 탭을 들어가보면 2d게임을 만들 때 유용한 자료들이 많이 있음
-플레이어의 스프라이트 이미지를 애니메이션 시키기 위한 스프라이트png이미지 에셋같은것도 여기서 잘 찾아보면 무료로 괜찮은 에셋들을 다운받을 수 있음

-에셋에 대한 설명, 예시 이미지가 있고 이 에셋을 통해서 구현할 수 있는 애니메이션도 확인 가능함
-맨 하단에 내려보면 다운로드 버튼이 있고, 클릭해보면 다운했을 때 무료일떄 다운받을 수 있는 미리보기용 맛보기 파일이 있고, 유료로 다운받을 수 있는 집 파일이 있음

-본격적으로 2d 웹게임 개발에 관심 있따면 여기서 다운받으면 됨

-다운받아서 열어보면 그리드 형태로 된 png이미지들도 있고, 오브젝트파일에는 맵을 그릴 때 쓸 수 있는 다양한 에셋들이 포함되어 있음

-참고로 우리가 사용할 배경화면도 여기서 다운받음

-레이어로 구성된 여러 이미지를 겹쳐서 애니메이션 효과를 만들도록 제공된 이미지임
-그래서 양쪽 끝이 자연스럽게 연결되도록 만들어진 것을 알 수 있음







<백그라운드 파일 기초 세팅>
-js폴더에 backgorund파일을 만들기
-export default class Background{}해서 클래스를 만들어주기

-이 안에 이전 플젝에서 했던 방식으로... 컨스트럭터, 업데이트, 드로우 순으로 메서드 만들고 정의하기
: export default class Background {
    constructor(){

    }

    update(){

    }

    draw(){
        
    }
}

-이제 백그라운드 클래스 만들었으니까 이미지를 한번 띄워야함
-그러기위해 다시 인덱스.html로 가서 이미지 태그를 만들어서 이미지를 올려보기
: <img src="./assets/bg1.png" id="bg1-img" class="asset-img">
    <img src="./assets/bg2.png" id="bg2-img" class="asset-img">
    <img src="./assets/bg3.png" id="bg3-img" class="asset-img">

-돔 이미지 태그를 애니메이션 시키기 위해서 바디에서 부른게 아니라, 이 불러와진 이미지를 캔버스에서 ctx.드로우 이미지를 하기위해 바디에 넣은 것이기 때문에 지금처럼 화면에 보일 필요가 없음
->따라서 css로 가서 디스플레이:넌으로 안보이게 만들어주기
-하지만 draw이미지를 하게 되면 잘 보일 것임!

-이제 백그라운드.js로 돌아와서 컨스트럭터 안에서 이미지태그들을 불러오기
: constructor(){
        this.img = document.querySelector("#bg1-img");
    }
-그리고 드로우 메서드 안에서 ctx를 가져와야하니까 app을 임포트 한 다음, app.ctx.drawImage를 호출하기
-drawImage(this.img, 0, 0, this.img.width, this.img.height);
->두번째 인자부터는 fillRect와 동일한 내용 넣으면 됨
->>app.js에 이 백그라운드 클래스를 불러오면 그려질 것임!


-App.js에서 컨스트럭터에서 백그라운드 클래스를 불러와서 인스턴스를 생성하기
: this.backgournd = new Background();

-render함수의 블록 안에서..그중에서도 if문 아래쪽에다가! draw함수로 배경을 그려주기
: this.backgournd.draw();

->그러면 내가 만들어둔 캔버스 안에 배경이 그려짐



-그런데 우리가 원하는 배경은... 화면에 꽉 채워진 이미지가 가로로 무한히 이동해야 함
-우선 이미지 크기를 확대해줘야함
-우선 세로크기에 맞게 세로를 늘려주기로 함

<배경을 캔버스 사이즈에 맞게 늘리기>
-백그라운드.js에서 draw함수에서 이미지를 그렸었음
: draw(){
        App.ctx.drawImage(this.img, 0, 0, this.img.width, this.img.height);
    }
-이떄 세로 길이를 이미지의 길이에 맞게 설정해뒀었는데, 우리는 캔버스 세로 크기에 맞게 만들고 싶은 것이니까 세로 크기 인자를 canvas의 세로 크기와 동일한 값을 넣어주면 됨

-컨스트럭터 안에 this.height를 선언하고, app.height로 정해주면 됨
:this.height = App.height;


-가로크기는...이 이미지의 고유 가로값과 세로값을.... 가져올 수 있어서! 비례식으로 이미지의 확대된 크기를 구할 수 있음

-this.width : this.height = App.width : App.height;
-외항과 내항끼리 연산하면,
this.width = App.height * (this.img.height분의 this.img.width)로 구할 수 있게 됨
: this.width = App.height * (this.img.width / this.img.height);

-이렇게 구한 this.width, this.height를 drawImage()함수의 인자로 넣기
: App.ctx.drawImage(this.img, 0, 0, this.width, this.height);

->이러면 캔버스 사이즈에 맞게 배경이미지의 가로,세로값이 확대됨!!


<배경이미지 움직이게 하기>
-그러면 이제 이 배경이미지를 업데이트해서 -20만큼 움직이게 하면 됨
-우선 x와 y가 0,0이 아닌...컨스트럭터에서 따로 선언된 변수여야 함
-x,y를 따로 초기화 하지말고 객체형으로 같이 초기화해주기
: this.pos = { x: 0, y: 0 };

-그러면 이제 draw함수 블록에서 drawImage()메서드를 쓸 때 0,0이 아니라 컨스트럭터에서 선언한 this.pos.x, y를 넣으면 됨
: App.ctx.drawImage(
            this.img, 
            this.pos.x, this.pos.y, 
            this.width, this.height
        );


-그리고 이제 update함수 블록 안에서 this.pos.x를 계속해서 -20 재할당해주면 됨
: update(){
        this.pos.x -= 20;
    }


-그리고 이 update메서드를 app.js의 렌더 함수에서 배경이미지가 드로우 되기 전에 실행시켜주기
: render(){
// 배경이미지 움직이도록 업데이트하기
this.background.update();
// 배경이미지 그리기
this.background.draw();
}


->이러면 배경이미지가 왼쪽으로 이동함


<이미지 무한루프 만들기>
-이미지를 하나 더 뒤에 붙이는 것임!
-이미지가 2개라면 2개의 이미지를 같은 속도로 왼쪽으로 이동시키다가, 왼쪽이미지가 화면 밖으로 완전히 사라지는 순간 오른쪽이미지의 뒤에 다시 갖다 붙이면 무한히 루프되는 모양이 됨
-그럼 왼쪽이미지가 화면에서 완전히 사라지는 순간이 언제일까?
->left.x + this.width가 0보다 작아야함!


-왼쪽이미지, 오른쪽이미지 이렇게 2개의 이미지를 써야 하니까 아까 this.pos로 위치값을 명명한 것을 this.leftPos로 이름을 바꿔주기
: this.leftPos = { x: 0, y: 0 };
-그리고 오른쪽 이미지의 x,y위치값도 초기화해주기
-오른쪽 이미지의 x값은 왼쪽 이미지의 바로 오른쪽에 붙어야하니까, 이미지의 가로만큼 오른쪽으로 떨어진 this.width가 됨
: this.rightPos = { x: this.width, y: 0 };

-그리고 draw메서드 안에서 드로우 이미지()를 2개 만든 다음에, 각각의 인자만 left, right로 바꿔주기
:     draw(){
        // 왼쪽 배경이미지 그리기
        App.ctx.drawImage(
            this.img, 
            this.leftPos.x, this.leftPos.y, 
            this.width, this.height
        );
        // 오른쪽 배경이미지 그리기
        App.ctx.drawImage(
            this.img, 
            this.rightPos.x, this.rightPos.y, 
            this.width, this.height
        );
    }



<업데이트 함수에다가 코드짜기>
-왼쪽 이미지와 오른쪽이미지가 화면 밖으로 벗어나는지 계속 체크해야하기 때문에 업데이트 함수 상단에 if문으로 제어하기
: // 왼쪽 배경이미지가 화면 밖으로 나가는지 체크
        if(this.leftPos.x + this.width < 0) {
            // 오른쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.leftPos.x = this.rightPos.x + this.width;
        }


-오른쪽 배경이미지가 왼쪽으로 벗어날 때도 마찬가지로 해줘야 하기 때문에 반대 상황도 if문으로 제어하기
: // 오른쪽 배경이미지가 화면 왼쪽 밖으로 나가는지 체크
        if(this.rightPos.x + this.width < 0) {
            // 왼쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.rightPos.x = this.leftPos.x + this.width;
        }



-this.left.pos.x에 매 프레임마다 속도를 더해주기
-속도는 this.speed로 컨스트럭터 안에다가 정의한 값 넣어주기
: constructor(){
  this.speed = -20;
}
update(){
// 속도 더하기
        this.leftPos.x += this.speed;
}


-this.rightPos.x에도 똑같이 속도를 주기


->이러면 계속 루프가 되면서 오른쪽으로 이동하는 느낌이 남!
->>그런데 이미지를 바꿔서 #bg2-img를 루프 돌려보면, 약간의 틈새가 벌어진 것을 알 수 있음
-이유? bg2의 png파일을 열어보니 얘만 양 끝이 약간 맞물려있지 않아서 문제가 발생한 것임
-아쉽지만 오른쪽 이미지를 왼쪽 끝에 딱 붙이는게 아니라 -4px만큼 앞으로 당겨서 살짝 겹쳐지게 해서 틈이 안보이게 만들기
: constructor(){
 this.rightPos = { x: this.width - 4, y: 0 };
}

-마찬가지로 업데이트 함수에서도 화면 바깥으로 사라진 이미지를 다음 이미지의 오른쪽에 붙일 때 약간 더 겹치게 붙여야 함
: // 왼쪽 배경이미지가 화면 왼쪽 밖으로 나가는지 체크
        if(this.leftPos.x + this.width < 0) {
            // 오른쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.leftPos.x = this.rightPos.x + this.width - 4;
        }
        // 오른쪽 배경이미지가 화면 왼쪽 밖으로 나가는지 체크
        if(this.rightPos.x + this.width < 0) {
            // 왼쪽 배경이미지의 오른쪽 끝에 붙도록 하기
            this.rightPos.x = this.leftPos.x + this.width - 4;
        }


-그런데 사실 이 -4는... 옵션에 넣어서 필요한 이미지에만 -4를 더해줘야하지만..우리는 그냥 귀찮으니까^^ 공통적으로 -4px만큼 이동시켜주도록 하기!

-그리고 이제 지금은 특정 이미지만을 위한 백그라운드 클래스가 만들어졌기 때문에
-3가지 이미지 동시 호환이 가능하도록 하기 위해서
-this.img값을 밖에서 연결시켜주도록 하기
-컨스트럭터의 인자로 config로 넣고, this.img에다가 config.img로 바꿔주기
: constructor(config){
 this.img = config.img;
}

-그리고 this.speed또한 config.speed로 바꿔주기
: this.speed = config.speed;


-그리고 app.js로 가서 this.backgorund변수를 s로 바꿔주고 배열형으로 바꿔서
3가지 백그라운드 인스턴스를 넣어주기
: this.backgrounds =[
            new Background({ img : document.querySelector("#bg1-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
        ];



-이제 frame함수로 가서 아까 테스트로 만들어둔 까만 정사각형을 지우고,
-this.backgrounds를 forEach로 돌아서 각각 업데이트와 드로우를 실행해주기
: // 배경이미지 생성
            this.backgrounds.forEach(background => {
                // 배경이미지 움직이도록 업데이트하기
                background.update();
                // 배경이미지 그리기
                background.draw();
            })


-그리고 아까 주석처리해둔 업데이트 함수의 속도 재할당 부분을 주석해제시키기



->그러면 배경이 이동하는 것을 확인할 수 있음
-지금 bg3의이미지가 투명도가 없어서 뒤의 이미지들이 가려져서 안보임
-그래서 bg1과 bg2배경이 가려짐
-따라서 app 클래스의 컨스트럭터에서 배경이미지 인스턴스를 생성할 때 순서를 반대로 3, 2, 1로 바꾸면 가장 나중에 그려지는 1이미지가 맨 앞으로 z인덱스가 제일 높은(?) 맨 앞으로 나오게 됨
: this.backgrounds =[
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg1-img"), speed: -1 }),
        ];


->레이어처럼 먼배경 - 가까운배경 순으로 이미지가 쌓이고 이게 다같이 잘 움직이게 됨

-그런데 다같은 속도로 움직이니까 입체감이 없어보임
-2d이미지에서 원근감을 주기 위해서는 가까이있는 것은 빨리 이동, 멀리 있는 것은 느리게 이동하도록 해야 함
-그래서 가까이에 있는 bg1은 -4 속도를 줘서 가장 빨리 움직이게 하고, 가운데는 -2, 가장 멀리 있는 3은 -1을 주기
: this.backgrounds =[
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -2 }),
            new Background({ img : document.querySelector("#bg1-img"), speed: -4 }),
        ];


->>이러면 입체감이 느껴짐

-그리고 지금까지 캔버스 사이즈 가늠을 위해 설정해둔 보더값을 지워주기






[ wall 클래스 만들기 1 ]
-백그라운드를 게임에 적용했으니, 젤 중요한 역할을 하는 장애물 월 클래스 만들기

-이번시간에도 우리가 원하는 asset을 찾아서 이미지를 한번 더 다른 프로그램을 이용해서 가공한 후 적용해보기

-가공된 이미지가 자료에 포함되어 있으니 원하는 사람만 따라해보기

<이미지 가공하기>
-itch.io 들어가서
태그리스트 중에서 타일셋을 찾아서 고르기


-이미지를 열어보면.... 2d게임 에셋을 자유롭게 만들 수 있도록 파일셋(?)을 세트로 묶음으로 만들어두기 때문에
-우리가 필요한 부분만 갖다가 후가공할 수 있게 해줌
-이떄 필요한 프로그램이 타일드?라는 것임..
: tiled


-파일 실행해보면 빈 화면 나오는데, 뉴맵 하면 사이즈 설정해서 만들면 타일맵이 생성됨
-tlx라는 확장자를 가진 타일형태로 된 맵이 나옴

-나중에 저 안에서 다양한 에셋을 활용해서 2d게임의 맵같은거를 만들 수 있나봄

-레이어를 쌓아서 하나의 이미지를 완성시키는 것임
(하나로만도 만들 수 있음)




<벽 클래스 만들기>
-js파일에다가 Wall.js를 만들기
-index.html에 이미지 요소 하나 추가해서 거기에서 이미지 불러오기
-똑같이 클래스를 asset-img를 줘서 안보이게 해두기

-한 이미지파일에 2가지 이미지를 같이 넣어뒀기 때문에 우리가 잘라서 써야함
-그래서 2가지 타입으로 나누고 빅, 스몰 이렇게! 타입에 대한 것도 바깥에서 받아와서 쓰도록 컨스트럭터에 저장함


-우선 만들어졌는지 확인 위해서 한번 만들어보기!
-App.js파일에서 App클래스의 컨스트럭터에 장애물 배열을 만들기
: this.walls = [new Wall({ type: 'SMALL' })];


-렌더 안에서 배경 코드바로 아래에 forEach()로 똑같이 업데이트와 드로우를 실행시켜주기
: // 장애물 생성
            this.walls.forEach(wall => {
                wall.update();
                wall.draw();
            });




-Wall.js파일로 돌아와서, 이제 여기 컨스트럭터 안에다가 스위치문으로 타입에 따라서 장애물 이미지를 다르게 보이게 함


<이미지 그리기>
-draw 함수에서 ctx를 불러와서 그림 그리면 됨
: App.ctx.drawImage(this.img, 0, 0, 가로값, 세로값);

-가로값은 일단 App.width로 하고 세로값도 App.height로 하기
:     draw(){
        App.ctx.drawImage(
            this.img,
            0, 0, App.width, App.height
        );
    }

->> 이렇게 하면 화면에 2개 타입 장애물이 다 나오게 됨

-근데 우리는 타입에 따라서 잘라서 쓰기로 했으니까, 이럴 떄 쓸 떄에 사용할 수 있는 방법이, drawImage()함수 안에 중간 인자를 더 넣는 것임

-sx, sy, sw, sh가 있음
-잘라서 보여주기 시작할 x, y로부터 가로, 세로크기를 지정해주는 것임

-그러면 우리 예제에서는...시작할 sx, sy는... sy는 항상 0이니까 0으로 시작하고
-sx만 this.sx로 해서 받아오면 됨!!


-앞에 있는 SMALL 타입은 파일 전체 가로크기가 0부터 시작해서 30개의 타일을 쓰니까 보기 좋게... this.width * (0 / 30)으로 적도록 함
-BIG 타입은 9 / 30이라고 하면 될 것 같음
:switch(this.type){
            case 'BIG' : 
                this.sx = this.img.width * (9 / 30);
                break;
            case 'SMALL' :
                this.sx = this.img.width * (0 / 30);
                break;
        }


-sh는 이미지 고유의 사이즈에서 height 전체를 그대로  넣으면 될 것이기 떄문에, this.img.height를 해주면 됨
-sw는 가로는 이미지의 고유 width의 30분의 9임..!

-BIG의 사이즈는 가로 차지하는 타일이 18칸이니까 18 / 30으로 해주면 됨
switch(this.type){
            case 'BIG' : 
                this.sizeX = 18 / 30;
                this.sx = this.img.width * (9 / 30);
                break;
            case 'SMALL' :
                this.sizeX = 9 / 30;
                this.sx = this.img.width * (0 / 30);
                break;
        }



-draw함수에 drawImage함수의 인자로 들어가는 것들 아래처럼 해주면 됨!
: App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            0, 0, App.width, App.height
        );



->>이렇게 하면 big타입이 딱 나옴!
->>다만 이제 캔버스에 실제로 그릴 가로세로를 앱에 맞게 하다보니까 이미지가 늘어나보임
-이제는 실제로 그려질 width와 height를 위에서 재정의해서 넣어주면 됨!


-가로값은 정사각형 이미지 파일 기준으로 this.sizex의 비율만큼 보여주면 되기 때문에 곱해주면 됨
-세로값은 app.hieght그대로 하고 하면 됨
->이러면 작은 벽이 자기 사이즈대로 그려지게 됨

->큰 벽이 잘 그려지는지 확인하고 싶으면 app.js에 가서 인스턴스 생성하는 곳에서 타입을 BIG라고 하면 됨



-윗벽과 아랫벽으로 나누고 그 사이 간격을 랜덤값으로 지정해주기
-캔버스 오른쪽 끝에서 생성하고 왼쪽으로 이동
-그리고 움직이고 있는 사이에 다음 벽을 랜덤한 시간에 생성시키기 + 왼쪽으로 사라진 벽은 배열에서 지워주기





[ Wall 클래스 만들기2 ]
-윗벽과 아랫벽으로 나누고 그 사이 간격을 랜덤값으로 지정해주기
-캔버스 오른쪽 끝에서 생성하고 왼쪽으로 이동
-그리고 움직이고 있는 사이에 다음 벽을 랜덤한 시간에 생성시키기 + 왼쪽으로 사라진 벽은 배열에서 지워주기



<장애물 벽을 윗벽과 아랫벽으로 나눠 만들기>



-갭y라고 이름 지어주고 랜덤값을 주면 통로 사이즈가 랜덤하게 됨
-그리고 갭y가 시작하는 위치도 랜덤하게 줘야지 위쪽에서 만들어지기도하고 아래쪽에서 만들어지기도 하고 할 것임!

-위 벽을 y1 아래벽을 y2라고 했을 때 윗벽인 y1의 최소값은 자신의height만큼 마이너스방향으로 이동했을 때....라고 할 수 있음
-그러면 y2의 시작하는 위치는.... y1에서 벽의 높이를 더하고 거기에 갭y를 더하면 구해질 것임!
=이러면 y1만 생각하면... y1의 최대값은....맨아래지점이 app.height니까 여기서 갭y값을 빼고, 자신의 높이를 뺴면 y1이 가질 수 있는 최대값이 됨!

-그러면 우리는 저 사이에서 랜덤값만 도출하면 됨!




-통과 구간 정의하기
-컨스트럭터에 정의하기...
-this.gapY라고 이름 짓고 app높이의 10퍼센트를 최소값으로하고, 캔버스높이의 20퍼센트정도를 최대값으로 해서 랜덤값 뽑기
: this.gapY = randomNumBetween(App.height * 0.1, App.height * 0.2);

-this.y를 하기 전에, this.x를 0으로 미리 우리가 지정해두기
: this.x = 0;



<y1 정의하기>
-최소값이 -this.height고, 최대값은 캔버스높이에서 갭y를 빼고, 자기 높이만큼 빼면 그 값이 최대값이 됨
-그러니까 여기서 공통되는 값인 -this.height를 바깥으로 빼고, 랜덤유틸함수로 App.height - this.gapY를 뺴면 됨
: this.y1 = -this.height + randomNumBetween(0, App.height - this.gapY);



<y2 정의하기>
-this.y1에다 this.height를 더하고 갭y만큼 더해주면 아랫벽이 시작하는 y위치인 y2구할 수 있음
: this.y2 = this.y1 + this.height + this.gapY;

-이제 드로우 함수 안의 내용을 수정하기
: App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y1, this.width, this.height
        );

-그리고 복사해서 윗벽 아랫벽 이렇게 2개가 되기 위해 하나 더 만들어주는데 y1만 y2로 바꾸면 됨
->>이러면 이제 계속 새로고침해보면 랜덤하게 윗벽아랫벽이 생김

-조금 보완하자면 이미지상에서 상단, 하단에 약간의 여백이 있음! 그래서 윗벽의 최소값이나와버리면 벽이 아예 안보이게 됨!
-그래서 우리가 임의로 수정하도록 함 
-마찬가지로 윗벽의 최대값에 -30을 해서 조금 위로 올려버리기
: this.y1 = -this.height + randomNumBetween(30, App.height - this.gapY - 30);


-갭 수정하기 좋은 방법은 아랫줄에다가 갭y를 오버라이딩해서 값을 테스트해보면 됨
this.gapY = randomNumBetween(App.height * 0.2, App.height * 0.35);
this.gapY = App.height * 0.2; =>이렇게 여기서 오버라이딩해서 테스트해보기


<벽 움직이기>
-배열에 추가,삭제로 관리해주기
-화면 바깥으로 사라졌을 떄 제거하는 것부터 시작하기

-업데이트 메서드 안에서 this.x에 -6을 프레임마다 더해줘서 왼쪽으로 이동
: this.x += -6;
-시작하는 x의 위치도 화면의 오른쪽 끝 안보이는 곳에서부터 등장하도록 App.width를 부여함
: this.x = App.width;

->이러면 오른쪽에서 왼쪽으로 잘 이동됨!


<벽을 배열에서 지우기>
-바깥으로 잘 나갔는지 확인하기 위해서 isOutside라는 getter정의하기
-this.x의(자기자신의) width를 더한 값이 0보다 작아야 안보이게 됨!
-이를 리턴하기
: get isOutside(){
        return this.x + this.width < 0
    }


-app.js로 가서 forEach()로 가서 벽을 그리는 곳에서 getter잘 되는지 확인하기
this.walls.forEach(wall => {
                wall.update();
                wall.draw();

                console.log(wall.isOutside);
            });
->>이러면 완전히 나가면 true가 뜸!


-이제 배열에서 나간 요소를 지우면 됨
-if로 제어문을 만들어서 쓰기!
: this.walls.forEach((wall, idx) => {
                wall.update();
                wall.draw();

                console.log(wall.isOutside);
                // 캔버스 화면 밖으로 장애물이 나가면 배열에서 지우기
                if(wall.isOutside) this.walls.splice(idx, 1);
            });




-forEach로 만들면 배열에 인스턴스가 여러개 들어가있다고 가정했을 떄, 앞의 인스턴스 제거하는 순간 뒤에 실행될 인스턴스의 순서에 영향이 가면서 깜빡임 현상과 같은 부작용이 발생함!
-그래서 for문을 역순으로 돌도록 만듦
: for(let i = this.walls.length - 1; i >= 0; i--){
                this.walls[i].update();
                this.walls[i].draw();
    
                console.log(this.walls[i].isOutside);
                // 캔버스 화면 밖으로 장애물이 나가면 배열에서 지우기
                if(this.walls[i].isOutside) this.walls.splice(i, 1);
            }



<새로운 벽을 생성하는 코드 짜기>
-그 전에 미리 프레임함수 안에서 나중에 코드가 길어지니까.. 미리 보기 쉽게 주석들 달기


-wall.js가서 잠깐 업데이트 메서드안의 내용을 주석처리하기
-그리고 canGenerateNext getter를 만들기
-이건 다음 벽을 생성할수 있는지 체크하는 것임
-컨스트럭터 안에 this.generatedNext라는 변수에 false를 담아두기
: this.generatedNext = false;
-getter에서 저 변수를 ture로 바꿔서 한벽당 한번씩만 다음벽 생성하도록 구조짜면 됨


-벽의 x값에 벽의 가로값을 합친 값이 전체 캔버스의 몇 퍼센트를 지났을 때 다음 벽을 생성할 것인지 정하면 됨
-여기서는 0.7이라고 함. 이 특정값 이하일 때 생성시키면 됨
-이 특정값도 컨스트럭터에서 지정해야함
: get canGenerateNext(){
        return(
            !this.generatedNext &&
            this.x + this.width < this.gapNextX  -> 생성 가능한 시점
        )
    }

-컨스트럭터 안에다가 gapNextX변수를 정해두기
-우선 캔버스 가로값 * 0.6정도 해두기
: this.gapNextX = App.width * 0.6;



-그리고 app.js로 가서 벽을 제거하는 코드 아래에다가 if문으로...해당 벽의 다음벽 생성 가능 여부 확인하는 getter가 true일 경우, 벽을 만들도록 하기
: if(this.walls[i].canGenerateNext){}
-그리고 해당한다면 벽을 만들도록 하는데, 그전에! 한번 벽을 만들면 더이상은 만들지 못하게 generatedNext변수를 ture로 만들어두기 (벽을 이미만들었다는 뜻)
-그 다음 아랫줄에다가 푸시로 만들면 됨
: this.walls.push(new Wall());

-그런데 이때 벽의 타입을 SMALL, 이나 BIG로 둘중 하나를 랜덤하게 골라야 함

-이것도 마찬가지로 랜덤함수를돌림!
-예를들어서, Math.random()의 값이 0.3보다 크면 SMALL타입을, 아니면 BIG을 생성하도록 하기
: this.walls.push(new Wall({ type: Math.random() > 0.3 ? 'SMALL' : 'BIG' }));


->빅타입은 어려운 타입이니까...!

-그리고 splice로 배열을 지운 후에 다음 코드로 넘어가도록 컨티뉴 추가해주기
: if(this.walls[i].isOutside) {
                    this.walls.splice(i, 1);
                    continue
                }


-다시 wall.js로 가서 속도를 좀 빠르게 한 뒤 다시 테스트해보기
-> 잘 출력되는 것 확인 가능함!



-다음 벽을 생성할 시점을 0.8이상으로 하면 벽이 너무 많아져서 플레이하기 어려워지니까, 최대값을 0.7쯤으로 지정해주기
-이 값도 랜덤하게 만들면 더 게임처럼 됨!
: this.gapNextX = App.width * randomNumBetween(0.6, 0.75);


(무인 아이스크림은..... 월세 100이 넘어가면 차리는 의미가 없대....별루....ㅎ)









[ Player 클래스 만들기 ]
-스프라이트 이미지를 애니메이션 시키는 과정을 통해서 클릭 이벤트를 넣어서 상하로만 날개짓하며 움직이도록 하기
-이번 강의에서 만든 걸로 이용해서 충돌 감지하는 기능을 다음시간에 만들기

<플레이어 클래스 만들기>
-js폴더 안에 Player.js 파일을 만들기
-그러고나서 클래스 기본형식 세팅하기
: export default class Player {
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}



-무료 스프라이트 이미지를 찾는 사람들을 위한 사이트 추천
-구글에 'bevouliin.com'이라는 사이트를 검색하면 된다!
-여기는 개인이 운영하는 사이트로, 무료로 제공하기도 하고 유료로 판매하기도 함
-무료이용시 주의할점이 라이센스! 이 사이트는 재배포, 판매하지 않은 이상... 사용 가능함!
-스프라이트 이미지가 각 이미지로 나뉘어서 15장이 들어있을것임!

-근데 우리는 이미지 임포트할 때 용량 절약, 코드에서 사용하기 쉽도록 강사님이 다 이어 붙여서 하나의 파일로 만들어둠!
-투디 에셋들을 다운로드 받아서 사용해보는 것도 좋은 경험이 됨!


-버드 이미지를 에셋폴더로 옮기고, 인덱스.html에서 벽 이미지 아래쪽에다가 새이미지를 불러오기
: <img src="./assets/bird.png" id="wall-img" class="asset-img">


-다시 플레이어.js로 돌아가서, this.img를 쿼리셀렉터로 선택해서 재할당해두기
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");
    }

-드로우 함수에다가 app의 ctx를 불러와서 drawImage 함수로 이미지를 그리기
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            100, 200,   // width, height
            100, 100    // 그릴 x위치, y위치
        );
    }


-app.js안에서 컨스트럭터 안에다가 this.플레이어 선언해주기...
: constructor(){
this.player = new Player();
}


-렌더함수 > 프레임 함수 맨 하단에...물론 then 재할당하기 전에! 거기에다가 방금 만든 인스턴스를 업데이트, 드로우 시켜주기
: render(){
  const frame = ()=>{
    this.player.update();.
    this.player.draw();
  }
}


-다시 플레이어.js 파일로 돌아와서 시작하는 x와 y값을 변수로 빼서 컨스트럭터에서 재정의해주기
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");

        this.x = App.width * 0.1;
        this.y = App.height * 0.5;
    }

- 이렇게 하면 width는 가로의 10프로에 위치, height는 세로의 50퍼센트에 위치하게 됨
-이렇게 하고 아래쪽 드로우에서 100, 200이라고 하드코딩 박아뒀던 것을 바꾸기
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.x, this.y,   // 시작하는 x와 y위치 
            100, 100    // width, height
        );
    }




-그리고 이제 width와 height를 컨스트럭터에서 재정의해주기
-width는 대충 130픽셀정도로 상수로 정의하고, 
-height는 정해진 width와 이미지의 실제 비율을 통해서 구하면 됨
-이미지 파일의 폴더 경로에서 이미지 상세보기로 보면, 가로세로를 알 수 있음!
-이미지 한 프레임의 가로 길이는... 총 15개의 이미지니까 2096픽셀 / 15라고 하면됨!
-2096을 15로 나누면 139.63333333이렇게 나오니까 대충 140픽셀이라고 보면 됨!


-세로 길이는 이미지의 총 길이인 96픽셀이 될 것임
-그러면 이미지의 비율이 가로분의 세로니까 140분의 96픽셀임!
-우리가 가로 길이를 130이라고 정했으니까 비례식으로 구해보면....width * (96 / 140) 이렇게 하면 됨!
: this.width = 130;
        this.height = this.width * ( 96 / 140);



-그러고 이제 draw함수에다가 100이라고 상수 박아둔 것을 바꾸면 됨
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.x, this.y,   // 시작하는 x와 y위치 
            this.width, this.height    // width, height
        );
    }



-이렇게 하면 15개의 이미지가 하나의 프레임에 보여줘야할 이미지 사이즈에 압축돼서 짜부돼서 보여지게됨....
-이제 이걸 보고싶은 부분씩 잘라서 보려면 draw에 인자를 더 추가해서 잘라서 봤었던 그 방식을 그대로 다시 쓰면 됨
-this.img 바로 아래에 sx, sy, sw, sh를 추가하면 된다
-즉, 자르기 시작할 x와 y위치, 자를 영역의 width, height로 설정하면 된다


-첫번째 이미지를 잘라서 캔버스에 그리기 위해서는..........
-sx, sy는 0,0 이면 되고, sw는 전체 이미지 길이에서 15분의1! 각 이미지 갯수만큼 나누면됨
-그리고 sh는 이 이미지가 한줄짜리니까... sh는 이미지 고유의 높이로 하면 된다!

-두번째 스프라이트 이미지를 표현하려면??? 시작할 sy, sw, sh는 이전과 동일하겠지만.. 자르기 시작할 x위치인 sx만 달라지면 된다!
-전체 이미지에서 한 프레임의 길이만큼만 이동하면 되고... 그 다음은 두 프레임의 길이만큼 이동하면 되는 식이다!


-여기서 sy는 항상 0이 될테고, sw는 전체 이미지 가로 길이값을 15로 나누면 된다, 그리고 높이는 이미지의 높이 그 자체가 되면 된다
: sx, 0, this.img.width / 15, this.img.height

-이제 sx는...우선...this.이미지 가로값을 15로 나누고, 첫번째 이미지를 보여주기 위해서는 우선 곱하기 0을 하면...된다!
: App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.img.width / 15 * 0, 0,  // 자르기 시작할 x와 y위치
            this.img.width / 15, this.img.height,    // 자를 영역의 width, height
            this.x, this.y,   // 시작하는 x와 y위치 
            this.width, this.height    // width, height
        );




-그럼 두번째 이미지를 보여주기 위해서는?
-곱하기 0 한 것을 곱하기 1을 해주면 된다!

-프레임에니매이션시켜주기 위해서 이 숫자만 this.frameX라고 컨스트럭터에서 선언해주면 된다
-초기값으로 0을 주고, 0이라고 상수로 박아둔 곳에서 this.frameX라고 변수를 써주면 관리가 된다!
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");

        this.x = App.width * 0.1;
        this.y = App.height * 0.5;
        this.width = 130;
        this.height = this.width * ( 96 / 140);
        // 플레이어 이미지 한 프레임 넘버 (0~14번 프레임)
        this.frameX = 0;
    }
-이렇게하면 원하는 이미지 부위만 잘 보일 것임



-이 이미지의 마지막 프레임값은...총 스프라이트 이미지 갯수가 15개이고 0번째부터 시작이니까.. 14가 마지막 프레임x의 값일 것임
-즉, 이 프레임x값이 15가 되면 이미지가 끝나는 지점이 x좌표가 될 것이니 아무것도 안보이게 된다!

-따라서 업데이트 메서드 안에서 프레임x를 0부터 14까지를 계속 반복하도록 해주면 된다


-우선 업데이트 함수에서 이미지 프레임 넘버를 1씩 증가시키면 매 프레임마다 이미지가 한컷씩 넘어가는데...근데 이렇게 1씩만 증가시키면 날갯짓을 1번만 하게 된다...
-즉 너무 빨리 사라져서 확인이 잘 안된다ㅠ
-따라서 조절해줘야한다
:     update(){
        // 플레이어 이미지 프레임 넘버 넘기기
        this.frameX += 1;

        // 플레이어 이미지 프레임 갯수 반복시키기
        if(this.frameX === 15) this.frameX = 0;

    }



-다른 방법으로는.... %를 사용해서 나눈 나머지값을 활용해도 똑같은 결과가 나오게 된다!
: if(this.frameX % 15 === 0) this.frameX = 0;


-15나누니 15하면 0이되니까 이렇게 0이 되면 다시 0을 할당하도록 하는 것임


-위의 식이 길다 느껴진다면 아래처럼도 쓸 수 있음
: this.frameX = ++this.frameX % 15;
=> this.frameX를 1씩 증가하고, 나눈 나머지 값을 계속 this.frameX에 재할당해주는 것임



-그리고 이 스프라이트 이미지 자체에 애니메이션 속도 조절하고 싶은 경우라면
-컨스트럭터 안에다가 this.counter라는 변수를 만들어주고
: this.counter = 0;

-업데이트 함수에서 카운터 값을 매 프레임마다 1씩 증가시켜주도록 하면 된다
:     update(){
        // 애니메이션 속도 조절 변수 1씩 증가시키기
        this.counter += 1;


-그러고 나서 카운터 변수를 2로 나눈 나머지값이 0이 되면, 프레임 넘버를 증가시키는 식이 실행되도록 하면 된다
:         // 애니메이션 속도 조절하기
        if(this.counter % 2 === 0){
            // 플레이어 이미지 프레임 넘버 넘기기
            this.frameX += 1;
    
            // 플레이어 이미지 프레임 갯수 반복시키기
            // if(this.frameX === 15) this.frameX = 0;  // 방법1
            // if(this.frameX % 15 === 0) this.frameX = 0;  // 방법2
            this.frameX = ++this.frameX % 15;   // 방법3
        }


-이렇게 하면 애니메이션 속도가 반으로 줄어든다
-2대신 3으로 하면 3배 더 느려지고, 10을 쓰면 10배 더 느려지게 된다!


-그리고 'this.counter += 1;'이라는 코드도 마찬가지로, if의 조건문 안에다가 식의 앞에 ++로 연산자로 써줘도 똑같이 된다!
: if(++this.counter % 2 === 0) { ... }


-이렇게 스프라이트 이미지를 표현하는 방식을 배움!

-이제 간단하게 마우스 클릭 이벤트를 넣어서 이 이미지를 상하로 움직여보도록 함



-플레이어.js의 컨스트럭터 안에서 app.캔버스.addEventListener로 클릭 이벤트를 듣도록 하면 됨
:     constructor(){
        // 이미지 불러오기
        this.img = document.querySelector("#bird-img");

        this.x = App.width * 0.1;
        this.y = App.height * 0.5;
        this.width = 130;
        this.height = this.width * ( 96 / 140);
        // 플레이어 이미지 한 프레임 넘버 (0~14번 프레임)
        this.frameX = 0;

        // 애니메이션 속도 조절
        this.counter = 0;

        // 클릭 이벤트 연결
        App.canvas.addEventListener("click", ()=>{});
    }



-클릭하면 플레이어 이미지가 위로 올라가게 할 것임
-캔버스를 아무위치에서나 클릭하게 되면...올라갈건데 vy변수를 활용할 것임!
-우선 컨스트럭터에 vy 선언하고 0 넣어주기
: this.vy = 0;


-이제 여기에 중력을 속도 y값에 더해주기로 함
-컨스트럭터에 그래비티를 선언해주고 0.3정도로 만들어주기
:         // 클릭시 플레이어 이미지 이동 속도
        this.vy = 0;
        // 중력
        this.gravity = 0.3;


-그리고 업데이트 함수에서 vy에다가 gravity를 누적해서 더해주기
: this.vy += this.gravity;
-이 vy값을 this.y에다가 매프레임마다 누적해서 더해주기
:     update(){
        // 애니메이션 속도 조절 변수 1씩 증가시키기
        this.counter += 1;
        // 애니메이션 속도 조절하기
        if(this.counter % 2 === 0){
            // 플레이어 이미지 프레임 넘버 넘기기
            this.frameX += 1;
    
            // 플레이어 이미지 프레임 갯수 반복시키기
            // if(this.frameX === 15) this.frameX = 0;  // 방법1
            // if(this.frameX % 15 === 0) this.frameX = 0;  // 방법2
            this.frameX = ++this.frameX % 15;   // 방법3
        }

        // 클릭시 이동 속도 조절
        this.vy += this.gravity;
        this.y += this.vy;

    }

->이렇게 하면 아래로 가속도를 받아서 이미지가 빠르게 떨어지게 됨


-이제 클릭을 할때마다 이 vy에 -5라는 값을 계속 더해보도록...해보기
-클릭이벤트 안에서 this.vy를 위로 올라가려면 마이너스여야하니까... -5씩 더해주면...!
:         // 클릭 이벤트 연결
        App.canvas.addEventListener("click", ()=>{
            // 클릭 발생하면 vy값에 -5씩 해서 위쪽으로 움직이게 만들기
            this.vy += -5;
        });



->>그러면 이제 클릭 할때마다 조금씩 애가 위로 치솟았다가 떨어진다! 중력 받은것처럼 속도 차이가 나면서!!!!


-근데...시작하자마자 떨어져서 맘의 준비가 안됐음;;;
-첨 시작할때 vy값을 0이 아니라 마이너스 값을 줘서 위로 조금 올라가다가 내려가게 해주겠음!
: this.vy = -10;


->>이 값은 게임 난이도에 따라 다르게 설정해도 될 것 같음 ㅎㅎㅎㅎ



-이제 다음은 충돌감지 기능을 만들 것임!!



[ 장애물 벽과 플레이어 간 충돌 감지하는 기능 만들기 ]

-충돌 되었는지 체크하도록 하기
-그냥 충돌 감지만 하는 것이 아니라 각각에다가 바운딩 박스를 만들어서 씌우고, 그 바운딩 박스 클래스들끼리 충돌을 체크할것임!
-이 이유는 따로 있음~


<박스간의 충돌감지 기본 원리>
-박스1을 오른쪽으로 이동했을 때 박스2랑 충돌된다
= 양 박스의 영역이 교집합이 생긴다
-교집합이 생기는 지점은?
= box1의 x좌표 + box1의 가로값이 box2의 x좌표값보다 같거나 커질 때!
= box1.x + box1.width >= box2.x

-y좌표도 마찬가지임
-아래로 내려오다가 겹치기 시작하는 지점도 x좌표처럼...
-박스1의 y좌표 + 높이값의 지점이 박스2의 y좌표보다 크거나 같을때!
= box1.y + box1.height >= box2.y
-그래야 충돌된다고 할 수 있음

-이 두 조건을 동시에 충족해야하니까 &&가 되어야 한다


-반대로, 박스2가 왼쪽에 있고 박스1이 오른쪽에 있는 상황도 고려해야한다.
-마찬가지로 x 시점 조건은...
= box1.x <= box2.x + box2.width

-마찬가지로 y 시점의 조건은...
= box1.y <= box2.y + box2.height

-이 두 조건을 동시에 충족해야한다!



->> 이 모든 조건들을 모두 충족해야한다! 따라서 조건1 & 조건2 && 조건3 && 조건4 이렇게 해야 한다!
=즉 박스가 어느 구간에 있어도 겹치는 구간이 조금이라도 있으면 모든 조건이 다 충족되는 것이다

-따라서 이 모든 조건이 충족된다면 그 다음 로직, 예를 들면 실패조건띄우기 이런 것을 실행하도록 하면 된다!


<코드 짜기>
-플레이어 클래스와 월 클래스가 직접 충돌감지하지 않고
-충돌 영역을 바운딩박스로 감싸서 할 것임.
-그러니까 바운딩박스 클래스를 따로 만들어야 한다.

-js폴더에다가 BoundingBox.js 를 만든다
-그리고 여기서 바운딩박스 클래스를 만들고, 컨스트럭터와 드로우 메서드를 만들어준다.
: export default class BoundingBox{
    constructor(){
        
    }
    draw(){

    }
}

-인스턴스를 만들 떄 바깥에서 차례로 x,y,width,height를 받아와서 this로 저장해주기
:     constructor(x, y, width, height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }



-드로우 메서드에서는 App을 불러와서 ctx.fillstyel에 컬러 지정하기
-그리고 지정할 컬러는 인스턴스를 만들 떄 바깥에서 받아오게 하기 위해 this로 지정하기
:     constructor(x, y, width, height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        
        this.color = "rgba(255, 0, 0, 0.3)";
    }
    draw(){
        App.ctx.fillStyle = this.color;
        App.ctx.fillRect();
    }


-그리고나서 방금 this라고 작성한 x,y,width,height를 모두 fillRect에다가 넣어주기
:     draw(){
        App.ctx.fillStyle = this.color;
        App.ctx.fillRect(this.x, this.y, this.width, this.height);
    }



-이제 플레이어 클래스 안에서 바운딩박스를 지정해줄것임
-플레이어 클래스의 컨스트럭터 안에다가 this.boundingBox로 인스턴스 새로 만들어서 선언하기
-그리고 인자로 이 플레이어의 x,y,w,h모두 다 넣기
: (player.js에서)
export default class Player {
    constructor(){
        // 충돌 감지용 바운딩 박스
        this.boundingBox = new BoundingBox(this.x, this.y, this.width, this.height);
    }
}


-이제 드로우 메서드 안에다가 먼저 플레이어 그리는 작업이 끝나면 그 다음에 this.boundingBox.draw를 실행시켜주기
:     draw(){
        // 그릴 앱 불러오기
        App.ctx.drawImage(
            this.img,   // 그릴 이미지 대상
            this.img.width / 15 * this.frameX, 0,  // 자르기 시작할 x와 y위치
            this.img.width / 15, this.img.height,    // 자를 영역의 width, height
            this.x, this.y,   // 시작하는 x와 y위치 
            this.width, this.height    // width, height
        );
        // 바운딩 박스 그리기
        this.boundingBox.draw();
    }



-이후 화면 보면 플레이어를 감싸는 박스가 생김!
-이걸 통상적으로 "바운딩박스"라고 부름
-이 박스를 다른 바운딩박스와 겹치는지, 나중에 콜라이딩 체크를 해 줄 것임
-그런데 그 전에 App.js에서 플레이어에 업데이트가 있었을 떄에는.... 바운딩 박스와 플레이어의 위치가 맞지 않게 된다!

-플레이어.js에서 처음에 박스가 만들어질 떄에는 초기값을 잘 넣어서 맞았지만.. 이후에는 값이 업데이트되어서 변동되었기 떄문!

-따라서 플레이어의 바뀐 y값을 바운딩박스의 y으로 다시 넣어줘야 한다!
-플에이어.js로 가서, 업데이트 함수에서, 클릭하면 y에다가 변동값을 넣어준것 처럼 똑같이 아랫줄에다가 바운딩박스의 y값을 업데이트해준다
: update(){
        // 클릭시 이동 속도 조절
        this.vy += this.gravity;
        this.y += this.vy;

        // 바운딩박스 y좌표값 업데이트하기
        this.boundingBox.y = this.y;

    }



-이렇게하면 따로 노는 문제 해결할 수 있따!
->이렇게 하고 확인해보면 된다~





<월 클래스에 바운딩박스 만들기>
-월.js에서 마찬가지로 바운딩박스 인스턴스를 만들어줘야하는데
-여기서는 하나가 아니라 2개를 만들어야한다
-왜냐? 클래스 뜯어보면 윗벽,아랫벽 이렇게 2개를 따로 드로우해주기 떄문이다
-위에 충돌하든 아래에 충돌하든 똑같이 충돌한것으로 여겨야 하기 떄문임


-wall.js의 컨스트럭터 안에다가 바운딩박스 인스턴스를 새로 만들어서 2개를 선언해주기
: export default class Wall{
    constructor(config){
        // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x, this.y1, this.width, this.height);
        this.boundingBox2 = new BoundingBox(this.x, this.y2, this.width, this.height);
    }


-그리고 wall.js의 드로우함수 안에서 벽 이미지가 모두 그려진 다음에 바운딩박스를 그려주면 된다
:     draw(){
        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y1, this.width, this.height
        );
        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y2, this.width, this.height
        );

        // 충돌감지용 바운딩박스 그리기
        this.boundingBox1.draw();
        this.boundingBox2.draw();
    }


-아직 벽이 보이지 않는 이유는...업데이트 함수를 주석처리했기떄문!
-App.js파일로 가서 프레임함수 안에 있는  벽 생성관련된 코드있는 곳에 있는 업데이트함수 주석풀기!
: for(let i = this.walls.length - 1; i >= 0; i--){
                this.walls[i].update(); ->>이거 풀면됨!

-근데 이래도 안보이는 이유는??바로...플레이어에다가 바운딩박스 작업할떄와 똑같은 이유임!
-맨처음에 바운딩박스를 그린 그 위치에서 자꾸 업데이트되는데 바운딩박스는 위치가 고정되어 있어서 그런 것임!

-wall.js에서도 업데이트안에 벽의 x값이 바뀔때 this.boundingBox1,2의 x값도 마찬가지로 동적으로 바꿔서 싱크를 맞춰줘야한다
: update(){
        this.x += -6;

        // 충돌감지용 바운딩박스 x좌표 업데이트하기
        this.boundingBox1.x = this.x;
        this.boundingBox2.x = this.x;
        // this.boundingBox1.x = this.boundingBox2.x = this.x; // 위의 2줄 코드와 동일함
    }



-이 바운딩박스와 플레이어간의 충돌감지를 할 수 있게 됨!

-그럼 이제 우리가 이해한 4가지 조건을 작성해야함
-바운딩박스.js로 돌아와서, 드로우메서드위에 isColliding이라는 메서드를 만들어주기
-인자로는 target을 가져오기
:     // 충돌 감지 메서드
    isColliding(target){

    }
-불리언을 리턴해줄 것임
-여기에서 아까 고민한 4가지 조건을 작성해주기
:     // 충돌 감지 메서드
    isColliding(target){
        return(
            target.x + target.width >= this.x &&
            target.x <= this.x + this.width &&
            target.y + target.height >= this.y &&
            target.y <= this.y + this.height
        )
    }



-이렇게하면 조금이라도 교집합이 생긴다? = 4가지 조건 달성한다는 뜻!
-이제 wall.js에가서 똑같이 isColliding 메서드를 만들어주기
-업데이트 메서드위쪽에다가 만들기
:     // 충돌 감지 메서드
    isColliding(target){
        return(
            this.boundingBox1.isColliding(target) ||
            this.boundingBox2.isColliding(target)
        )
    }

-이렇게 작성해야 한 벽클래스에 존재하는 2가지 벽 중 하나라도 닿아서 충돌하는지 체크할 수 있게 된다




-이제 플라이어와 벽을 어디서 실시간으로 감지할것인가를 고민해야함
-플레이어를 현재 생성되어있는 벽들이랑 포문으로 한번씩 돌면서 이즈콜라이딩으로 체크해줘야한다
-app.js파일로 가보면 이미 월인스턴스들이 포문안에서 돌고있는 구간이 있음!
-그래서 여기서 그냥 플레이어와의 충돌체크를 해주기로 함!
-벽 생성 for문 내부의 맨아래에다가 관련 코드를 작성하기
: if(this.walls[i].isColliding(this.player.boundingBox))
-이렇게...써서...! 만약 i번째 벽이 타겟인 플레이어의 바운딩박스와 충돌된다면, 즉 true가 반환된다면 블럭내의 코드 실행하게 하자
: // 장애물 벽 생성
            for(let i = this.walls.length - 1; i >= 0; i--){
                 // 벽과 플레이어 충돌 감지하기
                if(this.walls[i].isColliding(this.player.boundingBox)){
                    console.log("colliding!!!!");
                }
            }



-간단하게 플레이어 충돌을 감지하는 로직 구현완성~~!!
-이제 아쉬운 부분 보완하기!


-벽의 위치를 임의로 조정해보기
-그래보면 플레이어와 벽의 충돌 영역을 보면 필요이상으로 쓸데없이 공간이 많이 남는 것을 확인할 수 있음
-이건 드로우이미지를 하는 과정에서 이미지를 자르는 부분에 한계가 있어서 그런 것임
-이 x,y,w,h를 그대로 가져오니까 바운딩박스에도 의도치않게 불필요한 영역이 생긴것임
-이걸 간단하게..잘라보기!


-wall.js에서 처음에 init하는 과정에서 인자로 받아간 this.x를 뒤로 밀어버리면 됨
-이 this.x에다가 + 30을해서 밀어버리면됨!
:         // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x + 30, this.y1, this.width, this.height);
        this.boundingBox2 = new BoundingBox(this.x + 30, this.y2, this.width, this.height);

-마찬가지로 드로우와 업데이트함수 안에서도 +30을 해줘야함
: update(){
        this.x += -6;

        // 충돌감지용 바운딩박스 x좌표 업데이트하기
        this.boundingBox1.x = this.x + 30;
        this.boundingBox2.x = this.x + 30;
        // this.boundingBox1.x = this.boundingBox2.x = this.x; // 위의 2줄 코드와 동일함
    }

-드로우도 동일하게 바운딩박스의 x좌표값에 30더하기
: draw(){
        // 테스트용
        this.x = 700;
        this.boundingBox1.x = this.boundingBox2.x = this.x + 30;

        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y1, this.width, this.height
        );
        App.ctx.drawImage(
            this.img,
            this.sx, 0, this.img.width * this.sizeX, this.img.height,
            this.x, this.y2, this.width, this.height
        );

        // 충돌감지용 바운딩박스 그리기
        this.boundingBox1.draw();
        this.boundingBox2.draw();
    }


-width는 반대로 -60을 줄여주면...! 바깥쪽 이끼를 제외하고 딱딱해보이는 벽 영역만큼만 바운딩박스가 생성됨!
:         // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x + 30, this.y1, this.width - 60, this.height);
        this.boundingBox2 = new BoundingBox(this.x + 30, this.y2, this.width - 60, this.height);


-마찬가지로 y와 height도 똑같이 해주면 된다!
:         // 충돌감지 바운딩박스 만들기
        this.boundingBox1 = new BoundingBox(this.x + 30, this.y1 + 30, this.width - 60, this.height - 60);
        this.boundingBox2 = new BoundingBox(this.x + 30, this.y2 + 30, this.width - 60, this.height - 60);



-그러면 이렇게 합리적으로 충돌 지점을 수정할 수 있다


-플레이어도 마찬가지로 보면... 박스를 조금 줄여줘야...된다!

-플레이어.js파일에가서 컨스트럭터에서 충돌감지용 바운딩박스 init하는 부분에서 = 즉 새로운 인스턴스 생성하는 부분에서 적당한 수치를 더하거나 빼서 박스 사이즈를 플레이어 이미지와 비슷하게 줄여준다
:         // 충돌 감지용 바운딩 박스
        this.boundingBox = new BoundingBox(this.x + 10, this.y + 16, this.width - 20, this.height - 20);


-그리고 마찬가지로 박스와 플레이어 이미지의 이동 싱크를 맞추기 위해서 업데이트 함수 안에서 바운딩박스의 y값 업데이트 하는 곳에서 똑같이 + 16을 해주면 된다
: // 바운딩박스 y좌표값 업데이트하기
        this.boundingBox.y = this.y + 16;




-그리고 콘솔창에서 충돌했다고 확인하는 것보다 시각적으로..충돌됐음을 표현하기 위해서 소this.player.boundingBox.color를 변경해주는게 더 좋아서 그렇게 바꿨따
: this.player.boundingBox.color = `rgba(255, 0, 0, 0.3)`;
-그리고 충돌이 아닐 경우에는 색상을 파란색으로 바꿔줬다!
:                 // 벽과 플레이어 충돌 감지하기
                if(this.walls[i].isColliding(this.player.boundingBox)){
                    // console.log("colliding!!!!");
                    
                    // 충돌(true)시 바운딩박스 색상 변경
                    this.player.boundingBox.color = `rgba(255, 0, 0, 0.3)`;
                }
                else{
                    this.player.boundingBox.color = `rgba(0, 0, 255, 0.3)`;
                }



-이렇게 하고 wall.js에 가서 아까 테스트 하기 위해서 바운딩박스 위치를 고정시켰던 코드를 지우고 확인하면 된다!






[ 코인 클래스 만들기 ]
-장애물 윗벽과 아랫벽 사이 중간에 코인 배치하기
-랜덤 확률에 따라서 벽 사이의 중간에 배치하기
-박스간 충돌 감지 기능을 통해서 벽에 충돌하면 게임 상태 바꾸고, 코인에 충돌시 점수 획득, 충돌된 코인을 코인즈 배열에서 제거하기!

-코인은 스프라이트 애니메이션 효과로 플레이어 만드는 것과 비슷함!
-


<코인 크래스 만들기>
-코인.js파일 만들고 기본형식 따다가 그대로 쓰기(ex, df, cl, cion{})
-컨스트럭터랑 업데이트 메서드 만들기
-에셋폴더에서 이미지 가져오기
-html파일에 코인 이미지 가져오기

-다시 coin.js로 돌아와서 이미지 불러오기
:     constructor(){
        this.img = document.querySelector("#coin-img");
    }

-드로우 메서드 만들고, app불러와서 그리기
:     draw(){
        App.ctx.drawImage(
            this.img,
            100, 100,
            100, 100
        );
    }

-그리고 화면에 표시해주기 위해서 app.js로 가서 컨스트럭터 안에다가 코인 배열 만들기!
-컨스트럭터에 코인즈라는 배열 만들고 거기서 코인 인스턴스 하나 만들기
:     constructor(){
        // 코인 만들기
        this.coins = [new Coin()];
    }
-우선 하나만 만들어주기!
-원래는 빈 배열에 랜덤한 타이밍마다 생성해서 배열에 넣을 것이지만 일단 테스트로 하나 만든 것임!



-그리고 프레임 함수 안에 맨 아래다가 코인 관련  주석 쓰고 for문 역순으로 월즈 돌았던 것처럼 반복문쓰고, 업데이트와 드로우 메서드를 순차적으로 호출해서 실행시키기
: const frame = ()=>{
           for(let i = this.coins.length - 1; i >= 0; i--){
                this.coins[i].update();
                this.coins[i].draw();
            }
}




-스프라이트 애니메이션 만들기 위해서 코인.js로 돌아와서 드로우이미지()함수에다가 sx, sy, sw, sh를 부여하기
:     draw(){
        App.ctx.drawImage(
            this.img,
            0, 0, this.img.width / 10, this.img.height,
            100, 100, 100, 100
        );


-이러면 첫번쨰 코인 이미지가 잘 잘려서 나옴!

-이제 컨스트럭터 안에다가 스프라이트 애니메이션을 위해서, this.frame 선언하고 0으로 할당하기
:     constructor(){
        this.img = document.querySelector("#coin-img");

        this.frameX = 0;
    }


-드로우 메서드에서 이미지 자르는 위치를 this.img.width / 10 * this.frameX를 하면 sx에다가 0 넣은 것과 똑같은 결과가 나온다!
:     draw(){
        App.ctx.drawImage(
            this.img,
            this.img.width / 10 * this.frameX, 0, // sx, sy
            this.img.width / 10, this.img.height, // sw, sh
            100, 100, 100, 100
        );
    }



-이제 업데이트 메서드에서 this.frameX를 1씩 더해주는데, 만약 이 프레임엑스가 10이 되면 아래 드로우이미지에서 보는것처럼 프레임x가 10이 되면 이미지를 자를 sx의 값이 이미지의 끝지점이 되니까 프레임을 그리기전에 framex를 다시 0으로 초기화하면 된다
:     update(){
        // 프레임넘버 증가해서 애니메이션 만들기
        this.frameX += 1;
        // 만약 프레임넘버 한계수 도달하면 처음으로 되돌리기
        if(this.frameX === 10) this.frameX = 0;
    }



-이 업데이트 코드 간결하게 작성 위해 this.frameX = ++this.frameX % 10; 이라고 한줄로 작성함


-이제 너무 빠르게 돌기 때문에 프레임 넘어가는 속도를 조절하기 위해서 컨스트럭터에서 카운터 만들어주기
: constructor(){
  this.counter = 0;
}

-그리고 업데이트 메서드에서 프레임넘버 증가하기 전에, 카운터변수 1씩 증가시키고, 이 값이 2의 배수가 될 때 프레임넘버 증가하도록 하기
:     update(){
        if(++this.counter % 2 === 0){
            // 프레임넘버 증가해서 애니메이션 만들기
            this.frameX += 1;
            // 만약 프레임넘버 한계수 도달하면 처음으로 되돌리기
            if(this.frameX === 10) this.frameX = 0;
            // 위의 2줄 코드 한줄로 줄이면 : this.frameX = ++this.frameX % 10;
        }
    }


->>이렇게 하면 속도가 2분의 1이 됨!

->>근데 이것도 빨라서 5분의 1로 줄임! 


-이제 스프라이트 애니메이션 작업 끝임



-드로우이미지 함수에 있는 x,y,w,h를 이제 컨스트럭터로 빼서 변수화하기
-this.x,y는 바깥에서 받아오기 위해서 인자로 받아오기
-this.width는 100으로, 높이도 100 그대로 상수값 넣어서 선언하기
:     constructor(x, y){
        this.img = document.querySelector("#coin-img");

        this.x = x;
        this.y = y;
        this.width = 100;
        this.height = 100;



-그리고 드로우 메서드 안의 드로우이미지 함수안의 100이라고 상수 박아놓은 것들 변수로 처리하기
:         App.ctx.drawImage(
            this.img,
            this.img.width / 10 * this.frameX, 0, // sx, sy
            this.img.width / 10, this.img.height, // sw, sh
            this.x, this.y, this.width, this.height
        );




<이제는 코인을 벽사이에 배치하기!>
-일단 임의로 배치해두기 위해서 wall.js로 가서 드로우 메서드 상단에 this.x = 700이라고 하고, 이 업데이트 함수의 코드 복사해서 넣기
:     draw(){
        // 테스트하기 위해 바운딩박스 위치 고정시키기
        this.x = 700;
        this.boundingBox1.x = this.boundingBox2.x = this.x + 30;


-이렇게 만든 테스트용 벽에 코인 배치할것임!

-이제 코인을 만들 때, app.js파일의 컨스트럭터에 가보면 거기서 코인을 만들어내는데.... 이때 생성할 때 인자를 보내줘야함
-근데 위치는 벽의 가운데에 있어야함!
-이 x좌표는... 벽의 x좌표에서 가로사이즈의 절반을 더하면 되고
-y는 벽의 y2좌표에서 gapY의 절반을 빼면 가운데 x,y좌표가 나옴!

-이제 이걸 쓰면
700에 첫번째 벽의 가로값 / 2를 하면되고
-y값은 0번째 벽의 y2값에서 0번째 벽의 gapY / 2를 해주면 된다
:         // 코인 만들기
        this.coins = [new Coin( 
            700 + this.walls[0].width / 2,  // x : 벽의 x좌표 - width의 절반
            this.walls[0].y2 - this.walls[0].gapY / 2  // y : 벽의 y2좌표 - gapY의 절반값
        )];


-근데 이렇게했는데.. 코인이 가운데에 위치하지 않음!
-이 이유는~ 코인을 그리는 좌표값이 0,0이기 때문! 그래서 코인이 살짝 더 오른쪽 아래쪽에 위치하게 된 것임

-간단하게 코인클래스로 돌아와서 this.x좌표에 - 자기자신 가로값의 절반, this.y좌표에 자기자신의 높이값의 절반만큼 위로 올려주면 된다
(css할때 마오마오 했던것처럼)
:         App.ctx.drawImage(
            this.img,
            this.img.width / 10 * this.frameX, 0, // sx, sy
            this.img.width / 10, this.img.height, // sw, sh
            this.x - this.width / 2, this.y - this.height / 2, this.width, this.height
        );



-이렇게 하면 가운데 오게 됨!

-근데 코인이 너무 커서... 사이즈를 줄여줌
:     constructor(x, y){
        this.img = document.querySelector("#coin-img");

        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 50;




<이제 랜덤으로 생성되는 벽에다가 코인 넣어보기>
-이제 app.js로 가서 임의로 만든 코인 배열을 지우고, 
-wall.js에서 테스트용으로 만들었던 코드도 지우기


-이제 코인생성하는 코드는 어디에 넣어야 할까?
=>바로 app.js의 벽을 생성하는 코드 안임!!!
-새로운 벽이 생성될 때에 랜덤 확률로 코인 생성해주면됨!
-그 코드 아랫줄에다가 코인생셩관련 주석을 달고 if문으로 생성 제어해주면 됨
:                     // 코인 생성하기
                    if(Math.random() < 1) {
                        const x = 
                        const y =
                        this.coins(new Coin(x, y));
                    }


-근데 이때 if조건에 랜덤수가 1보다 작으면 이라고 해서 항상 나오게 테스트 코드로 짰음
-이제 x와 y의 좌표는 새로 생성된 벽의 좌표를 기준으로 잡으면 됨


-지금은 this.walls.push()로 wall인스턴스를 다이렉트로 직접 만들고 있는데, 이제는 이렇게하지않고 위에 변수로 빼서 새 인스턴스를 담아준 다음, 이 변수를 푸시해주도록 하기
:                    // 새로운 장애물 만들기
                    const newWall = new Wall({ type: Math.random() > 0.3 ? 'SMALL' : 'BIG' });
                    this.walls.push(newWall);


-이제 코인생성하는 if문안에서 x는 newWall.x의 newWall.widht의 절반을 나누기 한 것을 담으면 된다
:                     // 코인 생성하기
                    if(Math.random() < 1) {
                        const x = newWall.x + newWall.width / 2;
                        const y = newWall.y2 - newWall.gapY / 2;
                        this.coins(new Coin(x, y));
                    }


->>이렇게해도 지금은 코인이 안나오는데 그 이유는..코인을 처음 그리는건 성공했는데 업데이트 안시켜주기 떄문임!!
-벽이 생성되는 건 화면안보이는 곳에서 ㅁ나들어지니까...


-이제 다시 코인.js로 돌아와서, 여기서 업데이트 메서드에서 x값을 계속 바꿔주면 된다
:     update(){
        if(++this.counter % 5 === 0){
            // 프레임넘버 증가해서 애니메이션 만들기
            this.frameX += 1;
            // 만약 프레임넘버 한계수 도달하면 처음으로 되돌리기
            if(this.frameX === 10) this.frameX = 0;
            // 위의 2줄 코드 한줄로 줄이면 : this.frameX = ++this.frameX % 10;
        }
        
        this.x += this.vx;
    }

-그리고 이때 vx는 컨스트럭터에 vx선언하면서 인자로도 받아오도록 하기
:     constructor(x, y, vx){
        this.vx = vx;
    }


-그리고 app.js에서 코인생성 관련 코드에서..코인을 만들때 새로운 인자로 vx를 받아오는데, 이 vx도 새로운 벽의vx를 받아오면 된다
:                     // 코인 생성하기
                    if(Math.random() < 1) {
                        const x = newWall.x + newWall.width / 2;
                        const y = newWall.y2 - newWall.gapY / 2;
                        this.coins(new Coin(x, y, newWall.vx));
                    }


-wall.js로 가서 업데이트 메서드보면..."this.x += -6;"이렇게... 현재 x값은 -6이라고 다이렉트로 들어가있음;; 이 값을 this.vx로 바꾸고 컨스트럭터 안에다가 vx를 초기화해주기
: 컨스트럭터 -> this.vx = -6;
    update(){
        this.x += this.vx;
}


-그리고 아까 코인생성하는데서 실수한거.. push로 배열에 생성해서 넣어야함~!
: if(Math.random() < 1) {
                        const x = newWall.x + newWall.width / 2;
                        const y = newWall.y2 - newWall.gapY / 2;
                        this.coins.push(new Coin(x, y, newWall.vx));
                    }



-이렇게 하면 코인이 2번째 벽부터 가운데에서 잘 생성되는 것을 볼 수 있음!

-근데 이렇게만 하면 문제가......... 코인을 없애주는 코드를 안 만들어서...코인이 아예 안보이는 시점에서는 제거를 해줘야한다!!



<안보이게 되면 코인 배열에서 코인 지우기>
-app.js에서 for문 돌면서 코인 업데이트하고 드로우하는 코인 관련 부분에서 맨 아래쪽에다가 if()문 써서.. 코인의 x좌표 + 코인의 width가 0보다 작아지는 시점이 되면 = 안보이게 되면
스플라이스해서 i번째에서 1개만 지워주기
:             // 코인 관련
            for(let i = this.coins.length - 1; i >= 0; i--){
                this.coins[i].update();
                this.coins[i].draw();

                // 코인이 화면 밖으로 나갔을 때 배열에서 지워주기
                if(this.coins[i].x + this.coins[i].width < 0){
                    this.coins.splice(i, 1);
                }
            }



-이러면 이제 배열에서 잘 제거 됨!



-이제 확률을 1에서 0.5로 조절해주면 된다!
:                 // 다음 장애물 벽 생성하기
                if(this.walls[i].canGenerateNext){
                    // 더이상 생성 막기
                    this.walls[i].generatedNext = true;

                    // 새로운 장애물 만들기
                    const newWall = new Wall({ type: Math.random() > 0.3 ? 'SMALL' : 'BIG' });
                    this.walls.push(newWall);

                    // 코인 생성하기
                    if(Math.random() < 0.5) {
                        const x = newWall.x + newWall.width / 2;
                        const y = newWall.y2 - newWall.gapY / 2;
                        this.coins.push(new Coin(x, y, newWall.vx));
                    }
                }




[ Coin과 플레이어 충돌 감지]
-코인 클래스 마저 완성하기
-이미 바운딩박스 만들어뒀으니까, 코인.클래스에서 바운딩박스를 불러와서 생성하기

-Coin.js의 constructor에서 this.boundingBox 생성하기
: this.boundingBox = new BoundingBox();

-이 바운딩박스 인자로 x, y, 가로, 세로값 넣기
: this.boundingBox = new BoundingBox(this.x, this.y, this.width, this.height);


-draw()메서드에서 코인이 그려지는 곳 아래쪽에서 바운딩 박스도 그려주기
: this.boundingBox.draw();
-이때 주의해야할 점이 그려진 this.boudingBox도 처음 값만 제대로 들어간 것이지, 업데이트가 제대로 이뤄지지 않아서 안보이게 됨
-마찬가지로 update()메서드에서 x방향으로 움직이는 것 업데이트해주기
: this.boundingBox.x = this.x;

-그리고 확인해보면 잘 그려지지만 위치가 맞지 않아서, 위치를 수정해줘야함
-Coin.js의 draw()메서드에서 코인을 그릴 때 위치 값을 그냥 this.x, this.y로 한 게 아니고 여기서 this.x - this.width / 2 이런식으로 값을 조정했기 때문임
-그래서 코인의 실제 x,y좌표가 좀 달라진것임

-그러니까 draw()메서드의 App.ctx.drawImage()안에서 값을 임의로 조정했던 것을, 그냥 this.x라고 깔끔하게 쓰고, constructor에서 this.x에서 this.width / 2; 이런식으로 여기서 값을 처음부터 조정하도록 만들기
: this.x = x - this.width / 2;
        this.y = y - this.height / 2;

-이렇게 하면 기존에는 this.widht가 this.x,y의 밑에 줄에 있었는데, 상단에서 갖다 써야하므로! 위치를 더 올려주도록 하자
: this.width = 50;
        this.height = 50;
        
        this.x = x - this.width / 2;
        this.y = y - this.height / 2;


-이렇게 하면 코인과 충돌감지 박스가 잘 맞게 됨



-이제 App.js에서 코인과 플레이어 충돌 감지를 해줄 것임
-벽과 충돌하는 것과 마찬가지로, 코인도 코인 인스턴스 배열에서 코인 인스턴스를 splice로 지우고나면, 그 아래쪽 코드가 실행되면 안되기 때문에, continue를 써서 다음 인덱스로 코드가 진행되도록 만들어두기
: if(this.coins[i].x + this.coins[i].width < 0){
                    this.coins.splice(i, 1);
                    // 코인 지운 이후에 아래 코드 실행되지 않도록 막기
                    continue
                }

- 그리고 코인 관련된 코드블럭 안에서 i번째의 코인의 바운딩박스가 충돌했는지를 isColliding으로 플레이어와 충돌했는지 확인해보기
: for(let i = this.coins.length - 1; i >= 0; i--){
                this.coins[i].update();
                this.coins[i].draw();

                // 코인이 화면 밖으로 나갔을 때 배열에서 지워주기
                if(this.coins[i].x + this.coins[i].width < 0){
                    this.coins.splice(i, 1);
                    // 코인 지운 이후에 아래 코드 실행되지 않도록 막기
                    continue
                }

                // 코인과 플레이어 간의 충돌 감지
                if(this.coins[i].boundingBox.isColliding(this.player.boundingBox)){
                    console.log("플레이어와 코인 충돌!");
                }
            }


->잘 날아다니면서 코인 충돌한 것 콘솔창에 찍힘~~

-여기에서 먹은 코인은 배열에서 제거하고 게임에서 사라지게 만드는 동시에 점수 올라가도록 하면 끝!

-우선 코인을 제거해주도록 하자

-코인과 플레이어간의 충돌 감지하는 if문 블럭에서 true가 나서 충돌이 된다면, this.coin.splice()로 해당 코인의 인덱스번호 감지해서 해당 코인만! 제거하기
: if(this.coins[i].boundingBox.isColliding(this.player.boundingBox)){
                    console.log("플레이어와 코인 충돌!");
                    // 충돌된 코인을 배열에서 지우기
                    this.coins.splice(i, 1);
                }



-이제 boundingBox로 충돌 감지하는 것 다 확인했으니까 모든 곳에서 boundingBox를 그린 것 주석처리해서 안보이게 만들기!
: Coin.js, Player.js, Wall.js에서 this.boundingBox.draw() 주석하기





[ 스코어 Class 만들기 ]
-이번에는 스코어 클래스를 만들 것임
-코인과 플레이어간의 충돌 감지를 활용해서 스코어를 올릴 것임!

-오늘 배울 내용은 캔버스내의 텍스트를 돔형태가 아니라 fill텍스트를 이용해서 캔버스에 그리는 방법으로 점수 표헌하는 법, 먹은 코인의 갯수만 나타내는 게 아니라 업데이트가 호출된 만큼 거리 디스턴스?값을 누적시켜서 총 스코어에다가 새가 이동한 거리와 획득한 코인의 갯수 이 두가지를 상단 왼쪽, 오른쪽에 각각 표현하는 법 배우기



-js폴더 안에다가 Score.js를 만를기
-class Score 만들기
: export default class Score{
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}

-먼저 오른쪽 상단에 획득한 코인을 나타낼것임
-점수와 코인이미지 두개를 나타낼것임
-코인 이미지를 drawImage()로 새로 만들지 않고, 이전에 만든 코인 클래스를 가져다 쓸 것임

-constructor안에다가 this.coin해서 new Coin해서 새로운 인스턴스 만들기
: constructor(){
        // 코인 인스턴스 생성
        this.coin = new Coin();
    }
-새로운 인스턴스를 만들려면, 필요 인자가 x,y,vx값이 필요함
-코인 그리기 위한 센터의 x값이 어떻게 되지?
-App을 불러와서 앱의 width (가로값)에서 50만큼 떨어진 위치에 잡아주기로 함
: this.coin = new Coin(App.width - 50, );
-마찬가지로 y값도 마진효과를 주기 위해서 50을 주기
: this.coin = new Coin(App.width - 50, 50, );
-vx인 속도값은 0으로 해주기
: this.coin = new Coin(App.width - 50, 50, 0);


-이러고나서 draw()메서드 안에서 this.coin.draw()로 코인 그려주기

->잘 그려지는지 확인 위해서 App.js로 이동
->constructor 하단에 this.score 변수 만들고 스코어 인스턴스 만들어주기
: // 점수판 만들기
        this.score = new Score();

-그리고 프레임 함수 안에서 스코어 인스턴스 업데이트, 드로우를 시켜주면 됨!
-프레임 함수의 맨 아럐쪽에다가 만들어주기
: // 점수판 관련
            this.score.update();
            this.score.draw();


-->>이러면 캔버스 화면의 오른쪽 상단에 코인 이미지가 나타나는 것 확인됨
->그런데 이미지가 조금 삐뚤어져있음
-이는 코인 이미지 파일 열어보면, 첫번째 이미지가 살짝 삐뚤어져있어서 그러함
-그래서 score.js에서 constructor에서 this.coin의 framX값을 9로 초기화해주면 정면의 코인 모습이 나옴!
(여기서 frameX는 스프라이트 애니메이션의 프레임넘버이다! 정면 모습을 하고 있는 컷 번호를 가져와서 적어두는 것이다)
: // 코인 이미지 정면 모습으로 수정
        this.coin.frameX = 9;


-이제 그려진 코인의 왼쪽에 점수 텍스를 써주면 됨

-일단, 상태값이 있어야함!
-constructor안에다가 거리 상태값의 줄임말인 distCount를 0으로 초기화해주기
:     constructor(){
        // 코인 인스턴스 생성
        this.coin = new Coin(App.width - 50, 50, 0);
        // 코인 이미지 정면 모습으로 수정
        this.coin.frameX = 9;

        // 거리 상태
        this.distCount = 0;
    }

-그리고 그 아랫줄에 코인갯수 상태값의 줄임말로 coinCount를 0으로 초기화해서 선언해주기
: // 거리 상태
        this.distCount = 0;
        // 코인 갯수 상태
        this.coinCount = 0;


-draw()메서드 안에 App.ctx.fillText()를 써서 텍스트를 그리기 전에!! 윗줄에서 font 값을 지정해줘야함
-글씨체는 구글폰트 웹사이트에서 가져올것임
-html에다가 link태그를 붙여넣기

-그리고 App.ctx.font = ''; 이라고 해서 거기에 크기, 서체를 쓰기
: App.ctx.font = "55px Nanum Pen Script";

-그리고 App.ctx.fillText()를 쓰면 됨
-들어가는 인자로는 (들어갈 텍스트, x, y)
-텍스트는 this.coinCount를 그대로 쓰면 됨
-x와 y값은 우선 100, 100으로 상수값 넣어서 결과확인해보기
: // 코인 텍스트 그리기
        App.ctx.fillText(this.coinCount, 100, 100);

->근데 이렇게 하니까 글자색이 빨간색이네;;;;
-제대로 안보이니까 fillStyle로 스타일 지정해주기
: // 텍스트 스타일 지정
        App.ctx.fillStyle = "#f1f1f1";


-이제 이 텍스트를 오른쪽 코인 바로 왼쪽으로 배치 이동하기
-대략... x값으로는 App.width - 125를... y값으로는 69정도를 하면 적당히 옆으로 옴
: // 코인 텍스트 그리기
        App.ctx.fillText(this.coinCount, App.width - 125, 80);
->>이거는 내가 값을 조금 더 조정한 것임


-근데 만약 코인값이 한자리수가 아니라... 세자리 수가 되면... 왼쪽부터 텍스트가 그려지다보니까 자기자리를 넘어서 코인자리까지 침범해버림
-그래서 ctx에다가 텍스트얼라인 속성을 이용해서 기준점을 오른쪽으로 바꿔버리면!
-오른쪽에서부터 텍스트를 그려줌
: // 코인 텍스트의 폰트값 지정
        App.ctx.font = "80px Nanum Pen Script";
        // 텍스트 스타일 지정
        App.ctx.fillStyle = "#f1f1f1";
        App.ctx.textAlign = "right";
        // 코인 텍스트 그리기
        App.ctx.fillText(this.coinCount, App.width - 90, 80);

->>여러 자리수를 써서 코인자리 침범 안 하는지 확인해보기!




-그리고 이제 이동한 거리를 표시할것임
-이동 거리는 방금까지 App.ctx로 텍스트 기본 설정을 했던걸 이용해서 간단히 작업 가능함
-근데 거리는... 왼쪽 상단에 표시해줄것이니까 텍스트 얼라인만 레프트로 수정하기!
-지금 작성한 코드 아래쪽에다가 만들기
: App.ctx.textAlign = "left";
-그리고 거리 텍스트를 그려줄 건데 첫번쨰 인자로 작성할 문자열을 distCount변수를 쓰고 그 뒤에 "m"를 붙여서 진짜 거리처럼 표현해주기
-그리고 x는 25정도, y는 위에처럼 80으로 해주기
: // 거리 텍스트 그리기
        App.ctx.fillText(this.distCount + "m", 25, 80);
->이러면 이제 캔버스 화면의 왼쪽 상단에 나옴!

-이제 업데이트 해주면 됨
-거리점수를 올려주는 방법은...여러 방법이 있지만..
-우리는 간단하게.. 업데이트 메서드가 호출되는 만큼! 즉 한프레임씩 x값이 이동될때마다 디스트카운트도 조금씩 더해주려고 함!

-Score.js에서 update()메서드에서 프레임이 변할때마다 distCount변수에 1씩 더해주기
: update(){
        // 거리 이동 체크
        this.distCount += 1;
    }
->근데 이러면 프레임 넘어가는 속도에 맞춰서 너무 빨리 증가하므로...  적당히 조절
: this.distCount += 0.015;

->근데 이렇게 하면 소숫점이 너무 많이 나옴;;;
->소숫점 잘라내도록... fillText()에서 소숫점 내림처리하기
: App.ctx.fillText(Math.floor(this.distCount) + "m", 25, 80);
-이러면 이제 거리 상태값이 좀 천천히 올라감!




<코인 갯수 올려주기>
-App.js하단에 코인과 플레이어의 충돌 감지 부분에서 fi문으로 코인 충돌시 제거해주는 부분에서 점수상태 변수값을 변경시켜주면 됨
: if(this.coins[i].boundingBox.isColliding(this.player.boundingBox)){
                    // console.log("플레이어와 코인 충돌!");
                    // 충돌된 코인을 배열에서 지우기
                    this.coins.splice(i, 1);
                    // 코인 갯수 상태값 증가시키기
                    this.score.coinCount += 1;
                }
-이렇게 1을 누적해서 더하라는 코드를 한줄 더 추가해주면, 알아서 충돌 감지한 후 코인을 배열에서 지우고, 코인갯수 상태값에 1을 더해준다!



-이제 다음에는 게임 시작화면, 종료화면 만들고 이 스코어값을 활용해 보여줄 것임



[ 게임 상태에 따른 UI/UX 작업하기 ]
-지금까지는 게임이 진행되는 화면을 만든 것이었음!
-이제 게임 시작전, 도중, 후를 만들 것임

-게임 상태에 따라 화면을 다르게 보여주고 싶을 때 '게임 핸들러'라는 클래스를 통해서 상태와 화면의 ui를 함께 관리하면 됨!

<게임 핸들러 클래스 만들기>
-js파일 안에 'gameHandler라는 파일 만들고 클래스 기본 세팅하기
: export default class GameHandler{
    constructor(){
        
    }
}


-이 안에 this._status'라는 이름으로 "READY"라는 문자형 값을 넣어줌
-이 변수가 가장 중요함
    constructor(){
        this._status = "READY"; // READY, PLAYING, FINISHED
    }
-여기에는 READ, PLAYING, FINISHED 이렇게 3가지 상태값을 넣을 것임
-제일 처임엔 레디상태고, 이때 캔버스 화면을 z인덱스로 더 위에 덮는 div엘리먼트와 시작하기 버튼을 넣을 것임
-그러면 이제 시작하기 버튼을 클릭하면 상태값을 플레잉으로 바꿔주고 캔버스가 돌아가기 시작함!
-게임진행하다가 플레이어가 벽에 충돌하거나 화면 밖으로 나가면 게임상태를 피니시드로 바꿔줌!
-그러면 이제 숨겨뒀던 피니시드 화면을 보여줄 것임!



-App.js로 가서 컨스트럭터에다가 this.gameHandler변수를 만들고 게임핸들러 인스턴스를 저장해줌
: this.gameHandler = new GameHandler();

-하단에 프레임함수 안에서 배경을 그리기 전에! clearRect() 코드 위쪽에다가 아래의 코드 작성하기
: // 게임 상태관리 변수값에 따라 화면 보이기 : 플레잉 상태가 아니면 돌려보내기
            if(this.gameHandler.status !== "PLAYING") return;

            App.ctx.clearRect(0, 0, App.width, App.height);

->>이렇게 하면 이제 게임 상태관리 변수에 플레잉이 안 들어있으면 화면이 안보임
->>상태값이 플레잉이 되면 잘보임!
🔥🔥🔥주의🔥🔥🔥근데 지금 게임핸들러안에서 선언한 변수는 _status라 했는데, App.js의 렌더함수 안에서는 그냥 status라고 썼음
-이건 이따 게터와 세터를 사용하면서 일치시킬 것이므로 일단 이렇게 다르게 해둠!!


<gui작업하기>
-html파일로 가서, 만들어뒀던 canvas태그를 main으로 감싸기
-그리고 새로 section태그 만들고 클래스로 ready-screen을 쓰기
:     <main>
        <section class="ready-screen">

        </section>
        <canvas></canvas>
    </main>

-이제 섹션태그 안에다가 타이틀과 플레이 이미지를 가져와서 넣어두기
: <section class="ready-screen">
            <!-- 타이틀 -->
            <img src="./assets/title.png" class="title-img">
            <!-- 플레이 버튼 이미지 -->
            <img src="./assets/play.svg" class="play-img">
        </section>


-그리고 이제 스타일.css로 가서 스타일링 해주기
-vmin은 현재 스크린의 뷰포트의 vw와 vh중에서 더 짧은 쪽을 단위로 사용하는 것임
-반대로 vmax는 더 큰쪽을 사용하는 것임
: main{
    position: relative;
    overflow: hidden;
}
.ready-screen{
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: 1;
    background-color: rgba(0, 0, 0, 0.6);

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.title-img{
    width: 60vmin;
    margin-bottom: 15vmin;
}
.play-img{
    width: 11vmin;
    cursor: pointer;
}



🔥🔥vmin단위 쓰면서 App.js의 리사이즈쪽에서도 수정이 있었음🔥🔥
<기존>
// 화면 비율 정하기
        const width = innerWidth > innerHeight ? innerHeight * 0.9 : innerWidth * 0.9;
        App.canvas.style.width = width + 'px';
        App.canvas.style.height = width * (3 / 4) + 'px';

->이 부분 지우기

<이후>
-위의 코드 지우고 style.css에서 상단에 canvas요소에 width를 100vim, height를 75vmin;을 줬음
-이렇게 쓰면 화면 비율을 4대3으로 유지 가능함
: 
canvas{
    /* border: 1px solid red; */
    width: 100vmin;
    height: 75vmin;
}

->main보다도 위쪽에서 썼음!

-이렇게 하면 리사에즈 이벤트가 필요 없어져서.... App.js에서 리사이즈이벤트 지우기
: // 윈도우가 리사이즈될 때 리사이즈 함수 호출하기
        window.addEventListener('resize', this.resize.bind(this));
->이 코드 지우면 됨


-그리고 App.js의 resize함수의 이름을..이젠 리사이즈 할 필요 없으니까.. init으로 바꿔줘버림!
: init(){
        App.canvas.width = App.width * App.dpr;
        App.canvas.height = App.height * App.dpr;
        App.ctx.scale(App.dpr, App.dpr);

        // 화면 비율 정하기
        // const width = innerWidth > innerHeight ? innerHeight * 0.9 : innerWidth * 0.9;
        // App.canvas.style.width = width + 'px';
        // App.canvas.style.height = width * (3 / 4) + 'px';

    }


-그리고 index.js파일에 가서도 로드 이벤트에서 resize()함수 호출한거 이름 바꿔주기
: // 윈도우가 로드될 때 리사이즈 메서드 실행
window.addEventListener('load', ()=>{
    app.init();
    app.render();
});



-그리고 지금 렌더링되는 게.... 렌더 함수에서 if조건문(게임 상태변수가 플레잉이 아닐때)에 막혀서 지금의 화면을 보여주고 있음
-이렇게 되면 정말 너무 까만 바탕이라서 어색함
-그래서 그 아래쪽에서 배경을 그려주는 코드를 아예 초기화 함수에서 처음에 바로 그려지게 하면 더 좋을거 같아서 init함수 안으로 이동함
: App.ctx.clearRect(0, 0, App.width, App.height);
            // 배경이미지 생성
            this.backgrounds.forEach(background => {
                // 배경이미지 움직이도록 업데이트하기
                background.update();
                // 배경이미지 그리기
                background.draw();
            })
->>이렇게 render()함수 안에 있던 내용을

: // 초기화 함수 👉 리사이즈 함수 필요없어져서 개명
    init(){
        App.canvas.width = App.width * App.dpr;
        App.canvas.height = App.height * App.dpr;
        App.ctx.scale(App.dpr, App.dpr);

        // 화면 비율 정하기
        // const width = innerWidth > innerHeight ? innerHeight * 0.9 : innerWidth * 0.9;
        // App.canvas.style.width = width + 'px';
        // App.canvas.style.height = width * (3 / 4) + 'px';

        // 배경이미지 생성
        this.backgrounds.forEach(background => {
            // 배경이미지 움직이도록 업데이트하기
            background.update();
            // 배경이미지 그리기
            background.draw();
        })

    }
->>이렇게 초기화할 때 같이 그려주게 함
-그리고 초기화될 때부터 움직일 필요 없으니까, 업데이트 함수 지워주기
: init(){
        App.canvas.width = App.width * App.dpr;
        App.canvas.height = App.height * App.dpr;
        App.ctx.scale(App.dpr, App.dpr);

        // 배경이미지 생성
        this.backgrounds.forEach(background => {
            // 배경이미지 그리기
            background.draw();
        })

    }

->>이렇게 해주면 됨!!


-이러면 이제 레디상태의 스크린 ui디자인이 끝남!!



-이제 다시 게임핸들러.js로 돌아감
-클래스 안에다가 get status와 set status를 만들기
:     get status(){

    }
    set status(value){

    }

-이렇게 하고, 게터 안에서는 this._status를 리턴해주기
:     get status(){
        return this._status;
    }

-세터 안에서는 _status에 인자로 받아온 value값을 넣어주기
:     set status(value){
        this._status = value;
    }


-그리고 그 아래쪽에서 스위치문 돌며 벨류값에 따라서 케이스를 만들어주기
-READY케이스가 들어오면, showReadyScreen()메서드를 실행해주기
-그리고 이제 아래쪽에서 showReadyScreen() 메서드를 만들어주기
: set status(value){
        // 게임 상태 변수에 value값을 넣어 바꿔주기
        this._status = value;

        // value값에 따라 게임 상태 바꾸기
        switch(value){
            case "READY" : this.showReadyScreen();
                break;
        }
    }
    showReadyScreen(){
        
    }

-바깥에서 스테이터스 값을 변경하거나 불러와서 참고할 때엔 게터와 세터를 쓰도록 함
-데이터 함부로 못 변경하도록!!

-그리고 맨처음에 첫화면 보여줄때 애니메이션 효과주려고 쇼레디스크린이라는 메서드 만든 것임
-이제 이 메서드 위에 이닛메서드 만들어서 각종 필요한 엘리먼트들을 this로 저장하기
: init(){
        
    }
    // 첫 화면 보일 때 애니메이션 효과 부여
    showReadyScreen(){
        
    }


-ready-screen요소 가져오기
-title이미지도 docu.qs해서 클래스로 가져오고, 마찬가지로 플레이버튼도 가져오기
:  init(){
        // 첫 화면 구성 요소 가져오기
        this.readyScreen = document.querySelector(".ready-screen");
        this.titleImage = this.readyScreen.querySelector(".title-img");
        this.playBtn = this.readyScreen.querySelector(".play-img");
    }

-그리고 이제 애니메이션효과 주기 위해 gsap라이브러리를 가져와서 쓸 것임
: 
-버전은 일단 강의에서 사용하는 버전과 동일하게 3.11.0 버전을 가져와서 쓰지만, 최신 버전을 써도 문제가 없다면, 최신버전 쓰기
-참고문헌 : https://cdnjs.com/libraries/gsap/3.11.0
-코드 복사해서 index.html의 해드 태드안에다가 cdn붙여넣기
: <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.0/gsap.min.js" integrity="sha512-GQ5/eIhs41UXpG6fGo4xQBpwSEj9RrBvMuKyE2h/2vw3a9x85T1Bt0JglOUVJJLeyIUl/S/kCdDXlE/n7zCjIg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


-그리고 showReadyScreen메서드에서 gsap.to()해서 애니메이션 시작하도록 만들 것임
: showReadyScreen(){
        gsap.to(this.titleImage);
    }
-이렇게 써두고, stytle.css파일로 가서 title-img의 초기 상태에 투명도0, 스케일(2)로 일단 해주기
: .title-img{
    width: 60vmin;
    margin-bottom: 15vmin;

    /* 애니메이션 전 초기값 설정 */
    opacity: 0;
    transform: scale(2);
}



-다시 핸들러.js로 와서, to()의 두번째 인자로 옵션값을 넣어서 설정하기
: gsap.to(this.titleImage, {
            scale : 1,
            rotation : 720,
            opacity : 1,
            duration : 0.5
        });
-스케일은 처음 css에서 선언한 2에서 1로, 회전은 0에서 720도로 2번 회전하도록 하고, 투명도는 0에서 1로 나타나도록하고, 듀레이션을 0.5초로 해서 이 모든게 0.5초동안 일어나게 함

-다음에 gsap.to()로 playBtn도 애니메이션을 줌
-마찬가지로 애니메이션 부여하기 전에 css 파일로 돌아가서 transform의 scale을 0으로 만들기
: .play-img{
    width: 11vmin;
    cursor: pointer;

    /* 애니메이션 초기값 */
    transform: scale(0);
}

-그리고 다시 핸들러js로 돌아와서 애니메이션 부여하기
: gsap.to(this.playBtn, {
            scale : 1,
            duration : 1,
            ease : Elastic.easeOut.config(2, 0.5)
        });
-스케일을 0에서 1로 키우고, 1초동안 애니메이션하는데, 가속도를 부여해서 다르게 움직이게 함
-gsap easing사이트 들어가서 gsap에서 제공하는 다양한 이징옵션값을 확인해보기
-참고문헌 : https://gsap.com/docs/v3/Eases/

-엘라스틱을 보면, 첫번째 인자로 값이 변화되는 크기, 두번째는 바운스되는 정도를 설정할 수 있음
-앨라스틱, 파워1~4, 바운스 옵션을 주로 쓰는 것 같다고 함

-이렇게 애니메이션 만들어뒀으면, 이제 init메서드로 가서 아럐쪽에서 this.status()라고 하고 등호를 쓴 뒤, 바꿀 상태값이름을 적어서 넣으면 setter가 정한 값으로 _status를 바꿔줌
: this.status = "READY";

-이제 컨스트럭터 맨 하단에서 this.init()메서드를 불러서 처음에 이닛 불러서 실행시키기
:     constructor(){
        this._status = "READY"; // READY, PLAYING, FINISHED

        // 초기화 함수 실행
        this.init();
    }


-처음 화면이 뜰때 나타나는 애니메이션을 보고, playBtn의 애니메이션이 좀 빨리 실행되는 것 같아서, 타이틀 애니메이션이 나타난 후에 버튼 애니메이션 등장하도록 딜레이값을 주기
: gsap.to(this.playBtn, {
            scale : 1,
            duration : 1,
            ease : Elastic.easeOut.config(2, 0.5),
            delay : 0.5
        });




-이제 이 플레이버튼 누르면 게임 상태 "플레잉"으로 바꾸면됨
-init()메서드 안에서 버튼 클릭시 status값 바꾸도록 하면 됨
: // 플레이버튼 클릭시
        this.playBtn.addEventListener("click", ()=>{
            // 레디화면 숨기는 함수 호출
            this.hideReayScreen();
        });


-이제 쇼레디스크린()메서드 아래에다가 하이드레디스크린()메서드를 정의해주기
-이번에도 gsap로 애니메이션을 주기!
: gsap.to(this.readyScreen, {
            opacity : 0,
            pointerEvents : "none",
            duration : 0.3,
            // 완성 후 콜백 함수
            onComplete : ()=>{
                // 상태 변수 값 바꾸기
                this.status = "PLAYING";
            }
        });
-레디화면 전체를 투명도를 0으로 만들고 포인터이벤트 넌으로 해서 숨겨진 화면 터지 못하게 막고, 애니메이션을 0.3초동안 진행되게 하고 애니메이션이 끝나면 게임 상태 변수값을 플레잉으로 바꿔주기!
->이렇게하고 플레이버튼 누르면! 레디 화면에서 플레이 화면으로 바뀜


<이제 마지막 피니시드 상태 작업하기>
-먼저 인덱스.html로 가서 레디-스크린 섹션 하단에 finish-screen섹션을 만들기
: <!-- 끝 화면 -->
        <section class="finish-screen">
            <!-- 최종 거리 -->
            <div class="distance">0m</div>
            <!-- 최종 코인 갯수 -->
            <div class="coin">0 coin</div>
            <!-- 리플레이 버튼 이미지 -->
            <img src="./assets/replay.svg" class="replay-img">
        </section>
-그리고 위의 코드처럼 여러 코드 써주기

-그다음 css파일로 넘어가서 ready-screen 옆에 .finish-screen도 추가해서 같은 스타일 주기
: .ready-screen,
.finish-screen{
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: 1;
    background-color: rgba(0, 0, 0, 0.6);

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

-그리고 리플레이 버튼도 플레이버튼 스타일과 같게 만들어주기
: .play-img,
.replay-img{
    width: 11vmin;
    cursor: pointer;

    /* 애니메이션 초기값 */
    transform: scale(0);
}

-그리고 finish-screen만의 스타일도 부여하기
: .finish-screen{
    color: #fff;
    font-family: "Nanum Pen Script";
}
.finish-screen > .distance{
    font-size: 15vmin;
}
.finish-screen > .coin{
    margin-bottom: 8vmin;
    font-size: 8vmin;
    color: gold;
}


-그리고 다시 GameHandler.js로 돌아가서 준비화면의 애니메이션 연결하기
-status setter안의 switch-case에 FINISHED 상태 추가하기
: // value값에 따라 게임 상태 바꾸기
        switch(value){
            case "READY" : this.showReadyScreen();
                break;
            case "FINISHED" : this.showFinishScreen();
        }
-이제 쇼피니시스크린 메서드를 만들어주면 됨
: // 종료 화면 보이기 함수
    showFinishScreen(){
    }

-그리고 init() 메서드로 가서 미리 dom요소들을 담아서 클릭 이벤트에 넣어주기
: // 종료 화면 구성 요소 가져오기
        this.finishScreen = document.querySelector(".finish-screen");
        this.distanceText = this.finishScreen.querySelector(".distance");
        this.coinText = this.finishScreen.querySelector(".coin");
        this.replayBtn = this.finishScreen.querySelector(".replay-img");

        // 리플레이 버튼 클릭시
        this.replayBtn.addEventListener("click", ()=>{
            // 종료화면 숨기는 함수 호출
            this.hideFinishScreen();
        });


-그리고 쇼피니시스크린 메서드 하단에 하이드피니시스크린 메서드도 만들기
: // 종료 화면 숨기기 함수
    hideFinishScreen(){
        
    }


-쇼피니시 스크린 함수 안에서 이번에는 gsap에서 to()가 아니라 from,to를 쓸 것임
-피니시-플레잉 플로우로 반복될 것이니까, 스타일을 from에서 to로하면 따로 원상복귀시키지 않아도 자동으로 돌아가니까 이렇게 하는 것임
: fromTo는 첫번재로는 finishScreen, 두번째는 from의 옵션값, 세번째는 to의 옵션값을 쓰면 됨
: showFinishScreen(){
        gsap.fromTo(
            this.finishScreen, 
            { opacity : 0 }, // from 옵션
            {
                opacity : 1,
                duration : 0.5,
                pointerEvents : "all"
            } // to 옵션
        );
    }

-이제 다시 스타일.css로 가서 .finish-screen{}으로 가서 처음에는 보이지 않고 클릭도 안 되도록 숨겨두기
: .finish-screen{
    color: #fff;
    font-family: "Nanum Pen Script";

    /* 애니메이션 초기값 */
    opacity: 0;
    pointer-events: none;
}



-이제 다시 게임핸들러.js로 돌아가서 글자도 이쁘게 나타나도록 애니메이션 주기
: gsap.fromTo(this.distanceText, 
            { opacity : 0, scale : 0 }, 
            { opacity : 1, scale : 1, duration : 0.5, delay : 1}
        );
        gsap.fromTo(this.coinText, 
            { opacity : 0, scale : 0 }, 
            { opacity : 1, scale : 1, duration : 0.5, delay : 1.1}
        );
        gsap.fromTo(this.replayBtn, 
            { opacity : 0, scale : 0 }, 
            { opacity : 1, scale : 1, rotation : 720, duration : 0.5, delay : 1.3}
        );


-이제 결과 확인하기 위해 init메서드 안에서 처음 스테이터스만 피니시드로 만들어서 확인해보기
->애니메이션 잘 적용된것 확인됨!!

-이제 다시 원래대로 복구해놓기!



-이제 게임을 잘 진행하다가 충될 때의 세터갑을 피니시드로 바꾸면 됨
-App.js로 돌아가서... 벽과 플레이어가 충돌했을 때의 코드에서 세터로 상태값을 바꾸면 될 것같음
:                 // 벽과 플레이어 충돌 감지하기
                if(this.walls[i].isColliding(this.player.boundingBox)){
                    // console.log("colliding!!!!");
                    
                    // 충돌(true)시 바운딩박스 색상 변경
                    this.player.boundingBox.color = `rgba(255, 0, 0, 0.3)`;
                }
                else{
                    this.player.boundingBox.color = `rgba(0, 0, 255, 0.3)`;
                }

-지금까지는 충돌 확인하기위해 색상변경하도록 if-else문으로 써놨지만 이제는 충돌하면 바로 게임오버 상태로 바꾸기 위해서 그냥 if문만 쓰면 됨
: // setter로 게임 상태 변경하는 코드
                if(this.walls[i].isColliding(this.player.boundingBox)){
                    // console.log("colliding!!!!");
                    // 충돌(true)시 게임 상태 변수 바꿔서 종료 화면 보여주기
                    this.gameHandler.status = "FINISHED";
                    break;
                }
-그리고 안전하게 이 if문을 break;로 빠져나와서 혹시 모를 다른 일이 벌어지지 않게 막기




<이제 종료화면의 텍스트를 게임 진생 상황에 맞게 바꾸기>
-App.js의 스코어 인스턴스 내부의 값을 가져오기 위해서, 컨스트럭터 안에있는 게임핸들러 변수에다가 저장한 GameHandler 인스턴스의 소괄호에 'this'라고 써서, 이 app전체를 넘겨주기
-이렇게 하면 이제 게임핸들러 인스턴스가 게임핸들러 클래스로 app전체를 가지고 넘어감
: this.gameHandler = new GameHandler(this);

-그리고 핸들러. js에서 맨 위에서 컨스트럭터에서 app을 받아와서 this.app변수에 저장하기
: constructor(app){
        // App 전체 받아오기
        this.app = app;
...
}



-다음에 showFinishScreen() 메서드블럭 맨 위쪽에다가 거리텍스트 요소의 내부 텍스트로 app의 점수판의 거리값을 가져와서 내림하여주기
: showFinishScreen(){
        // 이동 거리값 보여주기
        this.distanceText.innerText = Math.floor(this.app.score.distCount) + 'm';
...
}
-마찬가지로 코인 텍스트도 가져와서 넣어주기
:         // 코인 갯수 보여주기
        this.coinText.innerText = Math.floor(this.app.score.coinCount) + coin';



-유저셀렉트 기본값때문에 결과화면 돌아오면 더블클릭해서 텍스트가 선택되어있는 것 막기
: .ready-screen,
.finish-screen{
    /* 유저셀렉트 기본기능 막기 */
    user-select: none;
}


-그리고 종료화면 숨기는 메서드인 하이드피니시스크린 메서드에서 애니메이션 부여하기
:gsap.fromTo(this.finishScreen, 
            { opacity : 1}, 
            { opacity : 0, pointerEvents : "none", duration : 0.1 }
        );

-근데 이렇게 하면 화면만 사라지고 게임이 실행되지는 않음!
- 그래서 아랫줄에서 status값을 'PLAYING'로 바꿔주기
: // 게임 상태 변경
        this.status = "PLAYING";


->근데 이렇게하면.. 충돌나서 게임이 오버됐을 때의 그 상태로 돌아가기 때문에 다시 또 게임오버가 되어버림

-이 문제 해결하기 위해서 App.js의 컨스트럭터 바로 아레에다가 리셋이라는 메서드를 추가로 만들고, 컨스트럭터에 있는 배경과 게임핸들러를 제외한 나머지를 리셋 메서드로 옮겨주기
: constructor(){
        // 배경 불러오기 : Background 클래스를 불러와서 인스턴스 생성하기
        // this.background = new Background();
        this.backgrounds =[
            new Background({ img : document.querySelector("#bg3-img"), speed: -1 }),
            new Background({ img : document.querySelector("#bg2-img"), speed: -2 }),
            new Background({ img : document.querySelector("#bg1-img"), speed: -4 }),
        ];

        // 장애물, 플레이어, 코인, 점수판 만드는 코드를 모두 reset()메서드로 옮김
        
        // 게임 상태관리
        // this.gameHandler = new GameHandler();
        // 게임 상황에 따라 변하는 거리, 코인갯수 값을 가져가기 위해 this를 써서 app전체를 인자로 받아감
        this.gameHandler = new GameHandler(this);
    }

    // 게임 리셋 함수
    reset(){
        // 장애물 만들기
        this.walls = [new Wall({ type: 'SMALL' })];

        // 플레이어 만들기
        this.player = new Player();

        // 윈도우가 리사이즈될 때 리사이즈 함수 호출하기 👉 style.css에서 반응형으로 수정함
        // window.addEventListener('resize', this.resize.bind(this));

        // 코인 만들기 : 내부 코드는 테스트용
        this.coins = [new Coin( 
            // 700 + this.walls[0].width / 2,  // x : 벽의 x좌표 - width의 절반
            // this.walls[0].y2 - this.walls[0].gapY / 2  // y : 벽의 y2좌표 - gapY의 절반값
        )];

        // 점수판 만들기
        this.score = new Score();
    }


-이렇게 옮기고 컨스트럭터의 하단에서 reset()메서드를 호출해서 처음에 한번 초기화하기!
: constructor(){
...
        // 리셋 함수 호출하여 초기화
        this.reset();
    }

-이러고나서 게임핸들러.js의 hideFinishScreen()메서드 안에서 하단에서 this.app.reset()메서드를 불러서 실행해주기!
: // 종료 화면 숨기기 함수
    hideFinishScreen(){
        // 애니메이션
        gsap.fromTo(this.finishScreen, 
            { opacity : 1}, 
            { opacity : 0, pointerEvents : "none", duration : 0.1 }
        );

        // 게임 상태 변경
        this.status = "PLAYING";

        // 앱 리셋 함수 호출
        this.app.reset();
    }


->그러면 이제 충돌나서 종료화면이 뜬 후, 리플레이버튼 클릭하면 게임이 리셋된 상태로 다시 시작하게 됨!




<보완하기>
-화면 바깥으로 플레이어가 나가도 게임오버가 되도록 해야함
-호면 바깥으로 나가는 경우 = y축이 위로 벗어나든가 아래로 벗어나는 경우 이렇게 나뉨

-App.js에서 frame()함수에서 플레이어 관련된 코드 아래에다가 if문 작성하기
: 
-플레이어의 y값이 앱의 높이값보다 크거나 플레이어의 y값에 높이값을 더한게 0보다 작으면, 게임 상태값을 finished로 바꿔주면 됨