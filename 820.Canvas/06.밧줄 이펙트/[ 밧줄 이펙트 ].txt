[밧줄 이펙트]
-현업에서는 물리알고리즘을 모아서 쉽게 사용가능하도록 만들어둔 라이브러리를 활용하겠지만, 이번 강의에서는 직접 물리알고리즘을 이해하고, 구현하는데 목적이 있음
-물리 알고리즘이 어떻게 돌아가는지 이해하기!

-x,y좌표에 대한 값 이해하기

-stick클래스가 이번 강의에서 포인트임!




<기초 뼈대 구성하기>
-style.css파일 만들고 헤드 태그에서 link로 불러오기
-canvas태그 넣기
-스크립트 태그 만들기

-styel.css에서는 html, body의 기본 마진,패딩 없애기
: @charset "utf-8";

html, body{
    margin: 0;
    padding: 0;
}


-그리고 index.js에 바로 코딩하지 말고, App.js를 만들고 거기서 작성한다음 index.js에 불러올것임
-그 이유는 index.js는 밧줄말고도 다른 웹 구성요소들이 모이는 곳이기 때문에 실전처럼 다른 곳에 빼두는 것임!
-내게 맞는 보일러플레이트를 만들어서 정착하면 됨

-js폴더 만들고 App.js파일 만들고 기초 구성하기
:export default class App{
    constructor(){

    }
    resize(){

    }
    render(){
        
    }
}

-그리고 컨스트럭터 작성하기 전에, 상단에 스태틱으로, 상수로 사용되는 변수들을 미리 작성해두기
: static width = innerWidth;
    static height =  innerHeight;
    static dpr = devicePixelRatio > 1 ? 2 : 1;
    static interval = 1000 / 60;
-전체 화면의 픽셀값들 미리 정해두기
-dpr도 1보다 크면 2, 아니면1로 해두기
-인터벌도 60fps로 동작하게끔 1000분의 60으로 해두기

-그리고 이제 컨스트럭터에서 캔버스불러오기
-그리고 ctx 변수를 2d로 만들어두기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");
    }
-이전에는 이 두개도 스태틱으로 해서 사용했었는데, 매번 스태틱으로 getContext로 객체를 만드는 것보다, 이렇게 컨스트럭터에서 써주면, 한번만 변수에 저장해두면 더 편할 수 있음


-이제 리사이즈 메서드에서 App.width와 height를 리사이즈될떄마다 변경되는 전체 화면의 가로, 세로 길이를 다시 스태틱으로 저장해주기
:     resize(){
        // 리사이즈 될 때마다 화면의 가로, 세로값 다시 지정
        App.width = innerWidth;
        App.height = innerHeight;
}
-이 값을 통해서 캔버스 css 가로세로값과 실제 캔버스의 가로세로값을 적용해주면 됨
: // 캔버스 CSS 스타일 지정
        this.canvas.style.width = App.width + 'px';
        this.canvas.style.height = App.height + 'px';

-캔버스의 사이즈를 앱의 가로/세로값에 * dpr곱해주는 이유는, dpr이 1 이상일 때 2로 통일시켜주는것임
-그 이유는 고유 캔버스 사이즈가 커질수록 .. 예를 들어 이미지 파일이 고해상도일 경우, 파일 용량이 커지는것처럼, 캔버스에서 그리는데에 영향을 끼칠 수있기 때문임!

- 캔버스 사이즈도 지정해주기
: // 캔버스 사이즈 지정
        this.canvas.width = App.width * App.dpr;
        this.canvas.height = App.height * App.dpr;


- 그리고 이제 ctx의 스케일에 dpr을 각각 곱해줘서 선명도를 높여주고, 또 낮은 dpr과 높은 dpr에서 모두 같은 모습으로 볼 수 있도록 해주기
: this.ctx.scale(App.dpr, App.dpr);


-이제 컨스트럭터에서 리사이즈 메서드를 호출해서 최초 한번 실행하도록 하고, 리사이즈 이벤트가 발생할때마다 리사이즈 함수를 실행하도록 해주기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));
    }

->근데 이렇게만 하면, 리사이즈 메서드가 실행될 때 안에서 선언된 this가 윈도우라고 인식하기 때문에 bind(this)를 추가로 메서드체인해줘서 this값을 앱으로 인식할수 있도록 함



-그리고 렌더로 넘어가서, let으로 now, delta선언하고 then = Date.now()로 현재 시간 담아주기
:     render(){
        let now, delta;
        let then = Date.now();
}
-frame()함수를 만들고, 그 안에서 리퀘스트애니메이션프레임함수에서 프레임함수를 다시 호출해서, 재귀함수로 스스로 기기의 모니터 주사율마다 프레임이 실행될수있도록 함
:         const frame = ()=>{
            requestAnimationFrame(frame);
}
=>즉 모두 같은 속도로 캔버스를 그리게 하기 위함

-그리고 아랫쪽에서 코드짜기
: now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
-델타는 나우와 덴값의 차이로, 델타가 인터벌보다 작으면 리턴을 시켜서 모니터 주사율인 60헤르쯔를 기준으로 캔버스가 애니메이션되도록 해줌

-그리고 나우에서 델타를 인터벌로 나눈 나머지값을 뺀 값을 다시 덴에 넣어주기
: then = now - (delta % App.interval);

-그리고 그 아래쪽에서 clearRect()를해서, 전체화면을 프레임마다 지우는 과정을 해주기
: this.ctx.clearRect(0, 0, App.width, App.height);

-그러고나서 우선 테스트용으로 정사각형 하나 그려서 잘 동작하는지 확인하기
: this.ctx.fillRect(100, 100, 100, 100);



-이제 이 프레임을 실행해야하니까 바로 아랫줄에서 리퀘스트애니메이션프레임으로 프레임함수 실행되도록 하기
:     render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            ///////////////////////////////////////////////////
            
            ///////////////////////////////////////////////////
            then = now - (delta % App.interval);

            this.ctx.clearRect(0, 0, App.width, App.height);

            // 테스트용 사각형 그리기
            this.ctx.fillRect(100, 100, 100, 100);
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }


-그리고 이제 다시 index.js로 돌아가서 로드이벤트로 모든게 로드되었을 때 앱 인스턴스를 생성해서 저장한 app변수를 만들고, 이 앱을 렌더함수로 실행시켜주기
: window.addEventListener("load", ()=>{
    const app = new App();
    app.render();
});






[ 닷 클래스 만들기 ]

-x,y좌표에 점을 찍고 이게 서로 스틱으로 연결되고 서로 영향을 주고 상호작용하게 만들 것임

-이제 기본적인 점을 만들어줄 것임
- js폴더에 Dot.js파일 만들고 기본 세팅하기
: 
export default class Dot{
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}


-닷은 말그대로 한 점을 말함! 그래서 필요한 인자는 딱 2개임 x,y좌표!
-이걸 this.x, this.y 선언하고 넣을건데 이번에는 this.x, this.y라고 하지 않고! 물리 라이브러리에서 하는 것처럼 "벡터"개념을 가져와서 쓸 것임

-이를 위해 벡터 클래스가 필요함
-js폴더에 Vector.js파일을 하나 만들기

-다른 라이브러리의 형식과 거의 유사하게 참조해서 우리가 사용하는 메서드만 가져와서 만들었다고 생각하면 될 것임
-이 안에다가도 클래스 기본 세팅하기
:export default class Vector{
    constructor(){
        
    }
}

-컨스트럭터 안에는 x, y만 바깥에서 받아와서 this.x,y에 저장하고 들어오는 값이 없을 때엔 0을 저장하도록 하기
:     constructor(x, y){
        this.x = x || 0;
        this.y = y || 0;
    }

-그러고나서 add()메서드를 static키워드를 붙인 것과 안 붙인 2가지 버전으로 나눠서 만들기
: static add(){

    }
    add(){
        
    }
->이러면 바깥에서 사용할 때 우리가 App.dpr App.interval, App.width와 App.height를 사용하듯이, Vector.add를 쓰면 이 스태틱 에드를 사용하게 되고, 바깥에서 뉴 벡터로 인스턴스를 만들고 그 인스턴스.add를 쓰면 아래쪽의 일반 add를 사용하게 됨!
(스태틱 키워드 공부하고 올 것)


-static으로 해서 Vector.add를 이용하면, 기존에 만들어진 인스턴스 쓰는 게 아니므로, 바깥에서 벡터1과 벡터2를 인자로 받아서 리턴으로 뉴 벡터 해서 새 인스턴스를 만들어주면 됨
-이 새 인스턴스에는 2개 인자가 필요한데, v1.x + v2.x를 x인자로, v1.y + v2.y를 y인자로 써주면 됨
: static add(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x + v2.x, v1.y + v2.y);
    }

-그리고 그냥 add메서드에서는 스태틱과는 다르게 이미 선언된 인스턴스의 x,y값을 변경해줘야하는것이니까, 인자를 x,y를 받아주면 됨
: add(x, y){

    }
-근데 다른 라이브러리들 보면 보통 인자를 1개만 받을 때와, 인자를 2개 받을 때로 나눠서 만드니까 우리도 그렇게 함!
: add(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){

        }
    }
-1개만 받는다고 x값만 받는 게 아니라, x가 아닌 다른 벡터 인스턴스를 인자로 준다는 뜻으로 이해하면 됨
->그래서 이때는 인자로 받은 x를 다른 인스턴스라고 보고 .x를 또 써주면 됨
:         if(arguments.length === 1){
            this.x += x.x;
            this.y += x.y;
        }

-인자를 2개 받는 경우는 원래 우리가 의도한것처럼 인자로 x,y값을 주는 경우임
:        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x += x;
            this.y += y;
        }


-따라서 이렇게 기본적으로 js에서 제공해주는 arguments와 length를 이용해서 메서드에 넘겨주는 인자의 갯수로 경우의수를 나눌 수 있음!

-그리고 마지막으로 return this로 더해진 벡터 인스턴스를 바로 사용할 수 있도록 리턴해주기


-그리고 이제 빼기 1을 뜻하는 sub 이라는 이름으로 스태틱메서드와 그냥 메서드를 만들어주기
-add와의 차이점은 +를 -로 바꿔주는것밖에 없으니까 복붙해서 바꿔주기
:static sub(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x - v2.x, v1.y - v2.y);
    }
sub(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            // x,y값이 아닌, 다른 Vector 인스턴스를 인자로 주는 경우
            this.x -= x.x;
            this.y -= x.y;
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x -= x;
            this.y -= y;
        }

        return this;
    }

-다음에는 일반 메서드로 멀티플라이의 약자인 mult로 곱하기 메서드를 만들기
-얘 스태틱 안 만드는 이유는 우리가 여기서는 얘 스태틱 안 쓸 것이기 때문!


-마찬가지로 멀티메서드도 들어오는 인자가 인스턴스일 수도 있고 x,y일수도 있으니까 경우의수를 나눠서 코드 짜기
-인자로 받은 x,y에 같은값을 가지는 v를 곱해주는 거라서, 길이로 판단하는게 아니라...이번에는 typeof를 사용해서 들어오는 인자의 타입으로 경우의수를 따질 것임
-들어오는 타입이 넘버면 x,y가 들어오는 것이고 아니라면 벡터로 인식하도록 하면 됨
:mult(v){
        // 들어오는 인자의 타입이 숫자인 경우
        if(typeof v === "number"){
            this.x *= v;
            this.y *= v;
        }
        // 아닌 경우 = Vector 인스턴스가 들어오는 경우
        else{
            this.x *= v.x;
            this.y *= v.y;
        }
        return this;
    }



-다음으로 setXY()를 만들기 이거는 벡터 인스턴스의 x,y값을 들어오는 인자의 x,y값으로 바로 세팅하는 역할을 함
:     setXY(x, y){
        this.x = x;
        this.y = y;

        return this;
    }


-마지막으로 distance의 약자인 dist()메서드로, 한 벡터 인스턴스로부터 다른 벡터와의 떨어진 거리값을 리턴해주는 것임
-보통 두 점 사이의 거리는 피타고라스 정의로 구할 수 있음....ㅠㅋㅋㅋ
-두 점이 있을때, 두점의 x를 dx라 하고 y를 dy라하고, 서로간의 거리는 dx의 제곱 + dy의 제곱을 루트 씌운것임......ㅎ
-따라서 dx는 this.x에서 받아온 인자.x이고, dy는 this.y에서 받아온 인자.y를 뺀 것임
-그리고 리턴할 때 dx에다 dx를 곱해서 제곱을 만들고 dy도 제곱을 만든 이 두개의 값을 더하고 Math.sqrt()로 루트를 씌워주면 됨
:     dist(v){
        const dx = this.x - v.x;
        const dy = this.y - v.y;

        return Math.sqrt(dx*dx + dy*dy);
    }


-물리 라이브러리에서 사용하는 벡터.js는 이것보다 훨씬 더 많은 메서드가 있지만 우선 간단하게 원리 이해하고 여기서 활용하는 것만 만들어봄!

-이제 우리가 만든 벡터가 잘 돌아가는지 테스트해보자


-index.js로 가서 한번 테스트해볼 것인데 따라하지 않아도 무방!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-index.js로 가서 맨 아래에다가 const v1으로 뉴 벡터로 인스턴스를 만드는데 100, 100으로 만들기
-그리고 그 아래에 v2에다가 벡터 하나 더 만들어주는데 50, 50으로 만들어주기
: const v1 = new Vector(100, 100);
const v2 = new Vector(50, 50);
console.log(v1);

->콘솔창에 x,y 좌표를 가진 벡터 인스턴스가 잘 찍힘!
->이제 여기에 바로 .add()로 v2를 인자로 넣어주면!
: console.log(v1.add(v2));
->>콘솔창 보면 "Vector {x: 150, y: 150}"라고 해서 두 값이 잘 더해진 것 확인됨!

->이번에는 콘솔에다가 v1에다가 .sub(v2)를 해주면
: console.log(v1.sub(v2));
->>다시 100,100이 잘 찍힘!
->>v1의 인스턴스값에다 윗줄에서 50을 더해주고, 아랫줄에서 다시 50을 뺴주니까 원래값인 100,100이 나오는 것임

->>그리고 argument를 하나 넣으면 벡터로 인식하고, 2개 넣으면 x,y로 인식하는지 확인하기 위해서 sub인자에다가 v2.x, v2,y라고 넣어주면
: console.log(v1.sub(v2.x, v2.y));
->>>똑같이 100, 100이 나오는것 확인됨!!


-이번엔 일반 메서드가 아니라 static을 사용해보기 위해서, const v3을 만들고 여기에다가 Vector.add()로 v1, v2를 넣어보기
: const v3 = Vector.add(v1, v2);
console.log(v3);
->이러면 150, 150을 좌표로 가지는, 새로운 인스턴스를 리턴해줘서 v3 변수에 담은 것이 콘솔에 잘 찍힘!!

-이제 곱하기 테스트!
: console.log(v3.mult(2));
->>Vector {x: 300, y: 300}라고 뜸!

-이번엔 벡터를 인자로 넣고 테스트
: console.log(v3.mult(v1));
->>Vector {x: 15000, y: 15000}
->>잘 나오는것 확인됨!!!!!

-이제 마지막으로 dist 메서드 테스트!
-v1과 v2사이의 거리 테스트해보기
: console.log(v1.dist(v2));
->>> "70.71067811865476"나옴!
->>> 100,100에서 50, 50사이의 거리인 약 70이 나오게됨!

-이렇게 벡터 클래스 만들고 스태틱 메서드와 일반 메서드를 각각 정의해서 x, y값을 테스트해봤음!


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




[ Dot 클래서 마저 만들기 ]
-백터 클래스를 활용해서 Dot클래스를 본격적으로 만들기
-기존 파티클 시스템을 구성할 때에는 this.x, y를 다이렉트로 사용했고, 덧셈 뺄셈과 같은 연산은 모두 수기로 작성하거나 util.js 파일안에서 만들고 export로 꺼내와서 사용하는 것처럼 작업했음
-이제 이렇게 벡터 클래스를 만들어서 쓰면! x,y값을 벡터에서 관리하면서 기타 연산 메서드를 쉽게 이용할 수 있다는 장점이 있음


-이제 index.js에서 테스트 했던거 다 지워버리기


-이제 Dot 클래스의 컨스트럭터에서 this.x,y정의했던거 지워주기
-이제 여기서 this.pos 선언하고 Vector인스턴스 불러오고 그 인자로 x,y넣어주기
:     constructor(x, y){
        // 벡터 인스턴스 불러와서 this.pos 정의
        this.pos = new Vector(x, y);
...
}


-속도를 구하기 위해서 oldPos라고 이전 위치변수를 정의하기
:         // 속도 구하기 위해 oldPos 정의
        this.oldPos = new Vector(x, y);

->이전에 파티클 프로젝트 만들 떄 속도를 구할때... 속도는 5, 3, 1과 같이 직접 숫자를 넣었음
-그러면 캔버스에서 "5"라고 하면....예를 들어 m/s라고 하면 1초에 이동한 거리를 m단위로 나타낸것임
-캔버스에서 속도 개념을 나타낸다면, App.js에서 render()메서드 안의 frame()함수가 1번 돌아가는 동안 이동한 거리를 속도라고 표현했었음
->즉 캔버스에서 "속도=5"라고 한다면, 한번의 프레임동안 5px만큼 이동했다는 뜻임!

-이번에는 Dot클래스의 update()메서드 안에서 속도를 vel이라고 해서 this.pos와 this.oldPos의 차이값을 가진 벡터 인스턴스라고 정의할 것임!
:     update(){
        // 속도
        let vel = Vector.sub(this.pos, this.oldPos);
    }
-즉, 이전 프레임에서의 위치(올드포스)에서 이번 프레임에서의 위치(포스) 사이의 거리가 속도를 나타낼 수 있기 때문임



-왜 이번 플젝에서는 이렇게 표현하나???
->>나중에 하나의 점이 속도가 0인데 같은 직선으로 연결된 다른 점이 속도를 가지게 되면 속도가 0인 점에도 영향을 받기 위해서는 이전위치와 현재 위치와의 차이값으로 속도를 나타내야하기 때문임!


-이제 draw()메서드 안에서 점을 그려볼것임
-이번 플젝에서는 ctx가 스태틱이 아니라 this.ctx로 앱 안에 정의되어 있기 때문에 드로우의 인자로 ctx를 밖에서 불러와야함
-그리고 ctx.fillStyle로 점의 색상을 검정색으로 해주고
-beginPath()로 그리기 시작하겠다고 선언하고
-ctx.arc()로 호를 그려줘야함
-x는 this.x가 아니라 this.pos.x이고, 마찬가지로 this.y가 아니라 this.pos.y로 해줘야함
-반지름은 10정도로 하고 호는 0부터 Math.PI * 2로 360으로 해줘서 원으로 만들어주기
-그리고 ctx.fill()로 안의 색을 채워서 점을 그려주기
-그리고 마지막으로 ctx.closePath()로 비긴패스로 열어둔 것을 닫아주기
:     draw(ctx){
        // 점 그리기
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }


-이렇게 우선 작업해두고, App.js로 돌아가서 컨스트럭터 안의 맨 하단에, this.dots = [];를 배열로 선언하고 그 안에서 뉴 닷으로 인스턴스를 생성하기
:     constructor(){
...
        // 점 생성
        this.dots = [new Dot()];
    }
-그리고 인자로 400, 50을 넣기
: this.dots = [new Dot(400, 50)];


-그리고 맨 하단의 frame()함수 안에서 clearRect()의 아래쪽에서 forEach()돌면서 dots배열의 각 점들을 update(), draw() 시켜주기
: render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            
            then = now - (delta % App.interval);
            
            this.ctx.clearRect(0, 0, App.width, App.height);
            ///////////////////////////////////////////////////

            // 테스트용 사각형 그리기
            // this.ctx.fillRect(100, 100, 100, 100);

            // 점 관련
            this.dots.forEach(dot => {
                dot.update();
                dot.draw(this.ctx);
            });
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }

-이렇게 하면 화면에 400, 50의 위치에 점이 하나 그려짐!
-지금은 점이 고정되어 있지만.. 이제 속도를 사용하면 점이 움직일 수 있음!

-이제 우리는 속도가 현재 위치에서 이전 프레임의 위치를 뺀 값이라고 했으니까, 컨스트럭터에서 처음에 초기화 시킬 때 둘의 값을 x,y로 똑같이 초기화해서 지금은 두개의 x,y값이 동일함
-이제 update()메서드에서 다르게 작업해주면됨

-vel변수 아래에다가 this.oldPos를 setXY로 this.pos.x, this.pos.y로 값을 대입하기
:     update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);
    }
-> 현재 프레임이 실행될 때 새로운 속도를 현재 포지션에 계산하기 전에, 값을 setXY로 이전 위치값에 대입해주면 말 그대로 이전위치가 됨

-이 아래쪽에서 속도.x에 0.1씩을 매 프레임마다 더해주면 어떻게 되는지 테스트해보자
-그리고 this.pos.add(vel)을 아랫줄에다가 써서, 변경된 속도값을 현재 위치에 더해주면...!
:         vel.x += 0.1;
        this.pos.add(vel);
->>그럼 점이 오른쪽으로 움직이는데 속도가 점점 빨라지는거 확인됨

-콘솔로 한번 찍어보면... 매 프레임마다 0.1씩 계속 더해져서 점점 빨라져서...가속도가 붙어서 빨리 오른쪽으로 사라지게 되는 것임

-이번엔 속도를 0.5를 주고 y로 테스트해보기
(frame함수의 clearRect()를 잠시 주석처리해서 이전의 그림이 남아있게 만들어두기)
:         vel.y += 0.5;
        this.pos.add(vel);
->이러면 점이 찍히는 모습이 다 남아있는데 아래로 갈수록 거리가 벌어져서 가속도가 붙는 걸 알 수있음


-이전에 파티클에서는 중력을 이렇게 표현했었음!
-이게 매초 또는 매 프레임마다 속도에 중력값을 더해주니까 아래로 빠르게 떨어지는 것임
-여기서는 이제 중력을 "1"이라고 상수값을 직접 더해주지 않고, 중력도 벡터클래스를 활용할것임!

-먼저 Dot의 컨스트럭터 안에서 gravity를 정의하기
: this.gravity = new Vector(0, 1);

-그리고 update()에서 vel.y + 1을 vel.add(this.gravity)로 바꿔주기
:     update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        this.pos.add(vel);
    }
->이전처럼 똑같이 동작하지만 좀더 변수화되어서 깔끔해짐


--이전에 파티클 시스템에서 우리가 마찰력도 대입했던 것을..이번에도 마찰력 구현할것임
-실제로 물리적으로 하늘에서 공을 떨굴때 하늘 높은 곳에서 떨어트리면 속도가 점점 빨라질것임
-계속 무한히 빨라지지않음! 왜냐면 공기 마찰력때문임
-그래서 어느정도 속도에 도달하면 마찰려과 중력이 상쇄되서 일정한 속도를 가지고 아래로 떨어지게됨

-이걸 파티클시스템에서 활용해서 컨페티나 불꽃놀이같은 걸 만들었었음
-이번에는 벡터를 활용해서 좀더 자세히 이해해보자!


-이제 콘솔창에서중력 더한 시점에서 vel를 확인해보면 y방향으로 1프레임당 1씩 속도가 무한히 커지는 걸 확인할 수 있음
: vel.add(this.gravity);
        console.log(vel);
        this.pos.add(vel);


-이제 Dot클래스의 컨스트럭터 안에서 friction 변수를 만들고 0.97정도의 값으로 초기화해주기
: this.friction = 0.97;

-여기에 중력값을 더하기 전에 마찰력을 먼저 현재 속도에 곱해주기
: update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);

        // 속도에 마찰력 곱하여 마찰력 부여하기
        vel.mult(this.friction);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        // console.log(vel);
        this.pos.add(vel);
    }

-그리고 콘솔 주석 해제해서 결과 확인해보면, 속도가 33.33...과 같은 어떤 시점에서 유지되는 것을 알 수 있음!

-이렇게 3d 물리 시스템을 속도, 중력, 마찰을 이용하여 2d에서 구현하는 것임!




[ stick 클래스 만들기 ]
-중력과 마찰력을 가지고 자유낙하하는 공을 만등렀으니, 이번에는 이 공을 서로 연결해주는 스틱 클래스 만들기로 함

-js폴더 안에 stick.js 파일을 만들고 클래스를 세팅하기
:export default class Stick{
  constructor(){

  }
  update(){

  }
  draw(){
    
  }
}


-dot클래스에서 x, y를 인자로 필요했다면, 스틱은?
-점 두개임! 이 두개를 서로 연결해야하니까!

-p1, p2라는 인자를 받아와서 시작점, 끝점 변수를 만들고 저장하기
:   constructor(p1, p2){
    this.startPoint = p1;
    this.endPoint = p2;
  }


-draw()메서드에서 바깥에서 ctx를 받아와서 그려주는데, 먼저 비긴패스로 패스를 그리겠따고 선언하기
-그리고 strokesStyle로 선의 색상 정하고, lineWidth로 선 두께도 지정하기
:   draw(ctx){
    // 스틱 그리기
    ctx.beginPath();
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 10;
}

-그리고 무브투로 스틱 그리기 위한 위치로 이동해주는데, 먼저 스타트포인트.pos.x, 스타트포인트.pos.y로 이동해주면됨
-그리고 lineto()로 앤드포인트의 위치로 가서 패스 그리기
:     // 스틱 그릴 위치로 이동
    ctx.moveTo(this.startPoint.pos.x, this.startPoint.pos.y);
    // 스틱 연결할 위치로 이동
    ctx.lineTo(this.endPoint.pos.x, this.endPoint.pos.y);


-그리고 이제 선으로 연결해서 그리기
-그리고 패스 닫아서 p1과 p2를 잇는 선분 그림!
:     ctx.stroke();
    ctx.closePath();


-이제 선분 하나 그리는 메서드가 완성됨

->>동작하는지 확인 위해 App.js로 가서 컨스트럭터에서 this.dots안에서 점을 하나 더 그려주기
: this.dots = [new Dot(400, 50), new Dot(500, 100)];


-그리고 이 점들을 잇는 선분을 생성하기 위해서 아랫줄에 sticks라는 인스턴스를 모아둘 배열 선언하고, 스틱 인스턴스 생성하기
:         this.sticks = [new Stick(this.dots[0], this.dots[1])];


-이렇게 한 다음 프레임함수 안에서 dots아래쪽에서 스틱 배열을 forEach 돌면서 각 스틱 인스턴스를 업데이트, 드로우 시켜주기!
:             // 선 관련
            this.sticks.forEach(stick => {
                stick.update();
                stick.draw(this.ctx);
            });

-이제 결과 확인해보면 두개가 연결되어있음!!
-점 두개는 똑같이 중력 받아서 아래로 떨어져서..잘 안보임;;;
-그러니까 이제 점 하나를 화면에 고정시켜볼 것임

-Dot.js로 가서, 컨스트럭터에서 this.pinned라는 변수를 만들고 false로 초기화해놓기
: this.pinned = false;

-그리고 업데이트 메서드 영역의 최상단에서, if문으로 조건을 걸면 됨
-this.pinned가 true면 리턴돼서 아래쪽에 있는 속도 관련 코드 읽지 않게끔!
:     update(){
        // 만약 dot이 고정되어 있다면 움직이지 않게 하기
        if(this.pinned) return;
        
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);
...
}


->속도도 없고 중력과 마찰력이 적용되지 않도록 하는 것임!

-이제 앱.js로 돌아와서 컨스트럭터 하단에서 첫번째 점을 핀으로 고정시켜보기
: this.dots[0].pinned = true;

->이러면 스타트점이 화면에 고정되고, 끝점은 계속 하강하기 때문에 이를 연결해둔 선분도 무한하게 길어지고 있음

-이때 스틱.js에서 update메서드 안에서 거리를 일정하게 유지해주는 로직을 짜서 이 두 점 사이의 거리를 처음 선언한 그 거리를 유지하도록 해주기


-먼저 로직 작성하기 전에, 잠깐 원리 설명 듣기,,,

<원리 설명>
점 두개 사이에 스틱이 연결되어 있는 상태
그리고 시작점은 고정되어 있는 상태임
두번째 프레임이 그려젔을 때에는 업데이트 안에 아무것도 작성되지 않은 상태라면, 끝점만 아래로 떨어지게 되는데... 무한히 길어지게 됨

-근데 우리는 스틱 클래스가 원래의 길이로 되돌아가려는 성질을 가지고 있어야, 업데이트돼도 계속 원래의 길이를 유지하게 됨
-원래 오리지널 길이를...랭스의 줄임말인 l로 지칭하고, 실제로 늘어나거나 줄어드는 길이를 dist라고 지칭해보자
-늘어나거나 줄어드는 dist의 거리는... 시작점과 끝점 사이의 거리값이라 생각하면 됨
-이 dist의 거리를 알고리즘을 적용시켜서 원래의 거리로 돌아가게 해줘야함

-이 dist에서 l을 뺀 차이값을 a라고 해보자
-이 실제로 늘어난 길이와 원래 오리지날 거리의 차이값인 오차 a를 통해서 원래 길이로 돌려주면 됨

-이 알고리즘의 핵심은 "늘어난 차이만큼 매 프레임마다 반 잘라서 시작점에 반 더해주고, 끝점에는 반을 빼주면"됨
= 늘어났을 때에는 늘어난 만큼 반씩 잘라주고, 줄어들었을 때에는 작아진 만큼 반씩 잘라주면 됨

-이걸 1프레임마다 반복하면 원래 길이에 일치하진 않아도 무한히 원래의 값에 가까워지게 되는 원리임

-이해를 돕기 위해 늘어났을 때만 생각했지만 줄어드는 경우도 똑같은 원리 적용하면 됨



-이 오차값 a를 어떻게 이해해서 구해서 반 잘라 나눠주면 될까...ㅎ
-두 점을 이어서 빗변삼각형??을 만들어서 계산해보면 된대 ㅎ...



....

-dx는 끝점.x에서 시작점.x를 뺀게 dx가됨
-dy는 끝점.y에서 시작점.y를 뺀게 dy임
-....
-사인과 코사인 이용하면 됨....ㅎ

-dist-L분의 ay가 코사인 세타값이됨
-사인세타는 dist-L분의 ax가 사인 세타값이 됨

-이걸 이용하면 ax값 구할 수 있음

-코사인 세타값이 알고보면 dist분의 dy랑 동일함!
->>따라서 이 두 비례식을 통해서 ay를 구할 수 있음

->>>dist-L분의 ay = dist분의 dy
->>>이 값이 코사인 세타값이됨!!

👉dist-L값을 오른쪽으로 보내면 ay값을 구할 수 있게 됨

-ax도 마찬가지로 사인세타를 이용해서 비례식으로 구하면됨
->>>dist-L분의 ax = dist분으 ㅣdx
👉dist-l값을 오른쪽에 보내면 ax를 구할 수 있게뙴



-이렇게 나온 ax, ay값을 반 잘라서 끝점에서는 그값을 빼고, 시작점에서는 그걸 더해주면... 원래의 길이에 무한하게 가까워지게됨!

-우선.... l을 먼저 구해야함
-l은 스틱 클래스 생성할때 p1과 p2를 인자로 받느 ㄴ컨스트럭터에서 두 점사이의 오리지날 거리를 구할 수 있고
-dx,dy는 업데이트 함수가 매프레임마다 실행될때 두 점좌표의 차이값으로 구할 수 있음
-그리고 dist는 dx,dy를 이용해서 피타고라스의 정의로 구하면 됨




-코드로 돌아와서... 우선 l 구하기
-스틱 클래스의 컨스트럭터 안에다가 this.length = 시작점.pos.dist()로, 우리가 벡터클래스의 메서드로 두 점사이의 거리를 리턴해주는 메서드를 만들어둔걸이용해서.. 인자로 dist.끝점.pos를 넣어서 원래의 길이 구하기
:     this.length = this.startPoint.pos.dist(this.endPoint.pos);


-그리고 이제 업데이트 메서드 안에서, dx,dy구하기
-dist로 구할 수있음!
-먼저 dx는 끝점.pos.x에서 시작점pos.x를 뺴주면 됨
-마찬가지로 dy는 끝점.y 에서 시작점.y를 빼주기
: const dx = this.endPoint.pos.x - this.startPoint.pos.x;
const dy = this.endPoint.pos.y - this.startPoint.pos.y;


-그리고 dist 선언하고 거기서 피타고라스의 정의로 구하기
:   update(){
    const dx = this.endPoint.pos.x - this.startPoint.pos.x;
    const dy = this.endPoint.pos.y - this.startPoint.pos.y;

    // 피타고라스 정의로 원래 길이 구하기
    const dist = Math.sqrt(dx*dx + dy*dy);
  }


-이제 ax, ay구하기 위한 요소들 다 구했음
-이제 ax를 offsetX라는 이름으로 정해서 아까 생각해둔 비례식을 이용해서 구하기
: const offsetX = (dist - this.length) / dist * dx;
const offsetY = (dist - this.length) / dist * dy;

-이제 이렇게 하면되는데 "(dist - this.length) / dist"요만큼이 중복됨
-중복 줄이기 위해서....diff라는 변수 만들고 거기에 저장해서 쓰기
:   update(){
    const dx = this.endPoint.pos.x - this.startPoint.pos.x;
    const dy = this.endPoint.pos.y - this.startPoint.pos.y;

    // 피타고라스 정의로 원래 길이 구하기
    const dist = Math.sqrt(dx*dx + dy*dy);

    // 늘어난 길이의 x, y구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx;
    const offsetY = diff * dy;
  }


-이제 또 시작점.x에 늘어난 길이의 절반만큼 더해주고
-y에도 늘어난 길이의 절반만큼을 더해주면 됨
:     this.startPoint.pos.x += offsetX * 0.5;
    this.startPoint.pos.y += offsetY * 0.5;

-이제 끝점에는 반대로 빼주기
:     this.endPoint.pos.x -= offsetX * 0.5;
    this.endPoint.pos.y -= offsetY * 0.5;


->>이러고 확인해보면....먼가 이상하게;; 시작점 고정해놨는데;; 고정이 풀려버림..
->>그래서 시작점, 끝점의 좌표값에 변동을 주는 코드 윗줄에서 if문으로 시작점이 고정되지 않은 경우에만 좌표값에 변동이 가도록 하기
:     // 시작점이 고정되지 않은 경우에만 적용하기
    if(!this.startPoint.pinned){
      // 시작점의 x,y 좌표에 늘어난 길이의 절반만큼 더해주기
      this.startPoint.pos.x += offsetX * 0.5;
      this.startPoint.pos.y += offsetY * 0.5;
    }
-마찬가지로 끝점도 고정되지 않은 경우에만 변동이 가도록 하기!
:     // 끝점이 고정되지 않은 경우에만 적용하기
    if(!this.endPoint.pinned){
      // 끝점의 x, y 좌표에 늘어난 길이의 절반만큼 빼주기
      this.endPoint.pos.x -= offsetX * 0.5;
      this.endPoint.pos.y -= offsetY * 0.5;
    }



->>이렇게 하면! 스틱이 늘어나지 않고 원래의 길이로 돌아가려는 성질 때문에 끝점이 계속 아래로 늘어지는 게 아니라 시작점과의 거리를 계속 유지하고 있는 모습을 볼 수 있음!!!


-이제 App.js로 돌아가서 점을 좀 늘려서 테스트해보기
-컨스트럭터 안에다가 600,50 위치에 점을 하나 더 추가해보기
:         this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50)];
->그러면 혼자 생긴 점이 바닥으로 떨어지게됨

-그러면 이제 스틱 배열에서 두번째와 세번째 점을 잇는 스틱을 하나 더 만들어보기
:         // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2])
        ];


->이러면 두번째 점에 3번째 점이 선으로 연결되는 것 확인됨!!

-이번엔 800,0위치에 점을 하나 더 만들고 3번째와 4번째 공을 잇는 스틱도 만들어보기
:         // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50), new Dot(800, 0)];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2]),
            new Stick(this.dots[2], this.dots[3]),
        ];


->그러면 이렇게 공들이 서로 유기적으로 영향 주고받으며 연결되어있고, 매 프레임마다 모두 원래의 길이로 돌아가기 위해서 계속 노력하는 스틱이 만들어짐!!



-이제 또 우리가 고려해야하는 개념이 또있음. 바로 "무게"임...
-만약 공들이 같은 무게를 가지고 있지 않고... 예를 들어 시작점은 1을갖고, 끝점은 3의 무게를 가지고 있으면...!!
-우리가 공평하게 ax,ay값을 반씩 잘라서 시작점 끝점에 똑같이 분배했던게..이제 무게가 차이나니까 분배를 다르게 시켜줘야함!!!
-즉, 3의 무게를 가지고 있는 쪽이 더 무거우니까 4분의 1만큼만 되돌아가면 되고, 1의 무게를 가지고 있는 쪽이 훨씬 더 가벼우니까 4분의 3만큼 무거운쪽으로 이동해야 한다!

-여기서도 규칙이 보이는데... 시작점은 1과 3을 더한 무게에서, 3만큼 오른쪽으로 이동하고/끝점은 1과3을 더한 무게에서 1만큼만 왼쪽으로 이동하면됨!!!


-끝점에 있는 점은 이전에는 오프셋의 절반만큼 곱하기 0.5만해서 왼쪽으로 이동했었는데, 이번에는 스타트 포인트와 엔드포인트의 무게를 더한것 분의 스타트 포인트의 무게를 곱해준 만큼만 왼쪽으로 이동하면 됨

-스타트 포인트에 있는 공은 오른쪽으로, 오프셋에서 스타트포인트의 무게와 엔드포인트의 무게를 더한 것분의엔드포인트의무게를 곱해준것 만큼만 오른쪽으로이동시켜주면됨



-이제 스타트 클래스의 업데이트 메서드 안에 있는 오프셋 정의한 부분 바로 아래쪽에서....
m이란 변수 만들고... 거기서 시작점.mass  + 끝점.mass라고 정의하고
-m1은 끝점의 mass / m,
m2는 시작점의 mss / m
-이라고 정의해주기
: // 늘어난 길이의 x, y 차이 구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx;
    const offsetY = diff * dy;

    // 무게에 따른 차이 구하기
    const m = this.startPoint.mass + this.endPoint.mass;
    const m1 = this.endPoint.mass / m;
    const m2 = this.startPoint.mass / m;


-이제 0.5를 곱해준 부분들을... 스타트포인트쪽에는 m1을 곱해주고, 끝점은 m2를 곱해주면됨!
:     // 시작점이 고정되지 않은 경우에만 적용하기
    if(!this.startPoint.pinned){
      // 시작점의 x,y 좌표에 늘어난 길이의 절반만큼 더해주기
      this.startPoint.pos.x += offsetX * m1;
      this.startPoint.pos.y += offsetY * m1;
    }

    // 끝점이 고정되지 않은 경우에만 적용하기
    if(!this.endPoint.pinned){
      // 끝점의 x, y 좌표에 늘어난 길이의 절반만큼 빼주기
      this.endPoint.pos.x -= offsetX * m2;
      this.endPoint.pos.y -= offsetY * m2;
    }



📌업데이트 함수 전체
:   update(){
    const dx = this.endPoint.pos.x - this.startPoint.pos.x;
    const dy = this.endPoint.pos.y - this.startPoint.pos.y;

    // 피타고라스 정의로 원래 길이 구하기
    const dist = Math.sqrt(dx*dx + dy*dy);

    // 늘어난 길이의 x, y 차이 구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx;
    const offsetY = diff * dy;

    // 무게에 따른 차이 구하기
    const m = this.startPoint.mass + this.endPoint.mass;
    const m1 = this.endPoint.mass / m;
    const m2 = this.startPoint.mass / m;

    // 시작점이 고정되지 않은 경우에만 적용하기
    if(!this.startPoint.pinned){
      // 시작점의 x,y 좌표에 늘어난 길이의 절반만큼 더해주기
      this.startPoint.pos.x += offsetX * m1;
      this.startPoint.pos.y += offsetY * m1;
    }

    // 끝점이 고정되지 않은 경우에만 적용하기
    if(!this.endPoint.pinned){
      // 끝점의 x, y 좌표에 늘어난 길이의 절반만큼 빼주기
      this.endPoint.pos.x -= offsetX * m2;
      this.endPoint.pos.y -= offsetY * m2;
    }
  }


-이렇게하면 식이 완성됨
-근데 우리가 mass설정 안해둬서.. 에러난것임

-이제 Dot.js의 컨스트럭터 안에다가 mass를 1로 기본적으로 초기화해주기
:         this.mass = 1;


->우리가 따로 무게를 만져준 곳 없으니까..모두 같은 무게를 갖고 있어서 결과적으로는 반반 나뉘게 되니까 아까 해둔거랑 똑같은 결고 ㅏ나옴


-무게에 따른 변화를 알아보기 위해서 우선 점을 0번과 1번만 남기고 전부 다 지우기
:         this.dots = [new Dot(400, 50), new Dot(500, 100)];
-스틱도 한개만 남기기
:         this.sticks = [new Stick(this.dots[0], this.dots[1])];

-이제 점을 100,50과 200,100위치를 추가하고
-스틱도 1,2번쨰 연결하기
:         // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(100, 50), new Dot(200, 100)];

        // 선 생성
        this.sticks = [new Stick(this.dots[0], this.dots[1]), new Stick(this.dots[2], this.dots[3])];


-그리고 인덱스2번 점도 핀으로 고정해두기
:         this.dots[2].pinned = true;



->현재 둘다 똑같이 나옴

-이제 dots[1]의 무게를 10을 줘보기
:         // 테스트 : 무게 추가
        this.dots[1].mass = 10;

->> 비슷해보이니까 '텐션'개념을 추가해서 무게감 부여하기



-Stick.js의 컨스트럭터에다 tension = 1로 초기화하기
:     this.tension = 1;

-이 텐션을 업데이트 메서드에서 offsetx,y에 각각 곱해주기
:     // 늘어난 길이의 x, y 차이 구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx * this.tension;
    const offsetY = diff * dy * this.tension;


-이 텐션은 오프셋,,오차값을 되돌려줘야하는데... 원래 곱하기 1을 한게 기본 텐션으로 되돌려주는 것이지만 만약 텐션을 0.05로 바꾸면.... 원래대로 돌아가야할 값을 20분의 1만큼만 되돌려주기 때문에 텐션이 느슨하게 되는 것임
:    this.tension = 0.05; // 탄성이 줄어서 무거울수록 늘어짐

-그리고 일정 시간이 지나면 중력과 상쇄되면서 완전히 원래 값으로는 되돌아가지 못하도록 하는 것임
-또한 무게가 더 무거운 쪽에서는 길이가 더 늘어져서, 진짜 무게가 있는 공처럼 물리 표현이 됨




-이제 다시 App.js로 가서 점 4개를 만들고 스틱으로 주루룩 연결해보면!
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));

        // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50), new Dot(800, 0)];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2]),
            new Stick(this.dots[2], this.dots[3]),
        ];

        // 점을 고정해두기
        this.dots[0].pinned = true;
    }

->>그러면 스프링처럼 탄성이 생기며 원래의 길이로 돌아가려고 함





-설명 이해 잘 안되면 다시 돌려보면 이해될거야~^^....








[ 마우스 클래스 만들기 ]
-마우스와 상호작용하여 마우스가 근처에 가면 마우스에 스틱이 달라붙게 하기 위해 마우스 클래스 만들기
-js폴더에 Mouse.js파일 만들고 클래스 세팅하기
: export default class Mouse{
  constructor(){
    
  }
}

-pos 변수 선언하고 벡터 인스턴스 생성하고 인스턴스 인자로 -1000, -1000을 넣어서 초기화하기
:   constructor(){
    // 위치
    this.pos = new Vector(-1000, -1000);
  }
-처음에 0,0같이 초기화해버리면...시작부터 0,0주변에 점이 있을 때 서로 상호작용 할 수 있기 때문에 안전하게 멀리 떨궈둔것!

-그리고 반지름 변수 선언하고 100정도 넣어두기
:     // 감지 범위
    this.radius = 100;
-얘는 공이 이 마우스 좌표를 중심으로 반지름 100이내로 들어왔을 때 마우스로 끌려가는 힘이 작동하도록 하기 위해 지정된 범위임



-캔버스위에 마우스의 움직임이 감지가되어야하니까, 캔버스 엘리먼트에 마우스 무브 이벤트가 등록되어 있어야함!
-지금은 캔버스가 this.canvas로 App.js안에 선언되어 있으므로, 우선 컨스트럭터의 인자로 캔버스를 받아오기
: export default class Mouse{
  constructor(canvas){
..
  }
}

-그리고 이 컨스트럭터 안에서 바로 이벤트 등록해주기
-pos의 setXY로 이벤트.클라이언트X,Y로 값을 바로 마우스 포지션 좌표로 세팅해주기
-마찬가지로 나중에 터치 디바이스에서도 똑같이 동작하게 만들기 위해서, 온터치무브 이벤트 등록하고 setXY인자로는 e.touches배열의 0번째에 있기 때문에 거기의 클라이언트x, y를 넣어주기
:   constructor(canvas){
        ...
    // 마우스 이벤트 등록
    canvas.onmousemove = e => this.pos.setXY(e.clientX, e.clientY);
    // 터치 이벤트 등록
    canvas.ontouchmove = e => this.pos.setXY(e.touches[0].clientX, e.touches[0].clientY);
  }



-이렇게 해두고 App.js로 돌아가서, 컨스트럭터 내부에 this.mouse는 뉴 마우스()로 임포트하고 생성하는데 인자로 this.canvas를 넣어서 초기화하기!!
:  constructor(){
        // 마우스 생성
        this.mouse = new Mouse(this.canvas);
    }



-이제 이렇게 만든 마우스 인스턴스를 활용해야하는데, 마우스가 공 근처에 가면 공이 마우스쪽으로 끌려와야함
-이렇게 하기 위해서 프레임함수 안에서 공이 업데이트 되거 있는 부분에서... 업데이트 함수의 인자로 마우스를 통쨰로 보내줘버리기
:             // 점 관련
            this.dots.forEach(dot => {
                dot.update(this.mouse);
                dot.draw(this.ctx);
            });


-그럼 이제 Dot.js로 돌아가서, 업데이트 메서드에 인자로 mouse를 넣고, 이 업데이트 메서드 하단에 로직 짜주면됨
-이제...공이 끌려오는 원리를...또 공부해보자...



<마우스에 점이 끌려오는 원리>
-마우스의 범위를 r=100이라고 했을 떄, 존재하는 공이 마우스의 범위에 들어오면, 마우스 쪽으로 끌려오게 됨
-이때 방향벡터와 힘을 통해서 끌려오게 할 수 있음

-파티클 시스템에서 간단하게 설명했던 건데... 현재x,y에서 다른 x,y로 가기 위해서 그쪽 방향으로 얼마만큼의 힘을 곱해주면된다!
-여기서는 방향벡터의 힘을 곱해주면 됨

<방향 벡터를 구하는 법>
-방향 벡터는 방향성을 가지고 있는 단위 벡터임
-단위 벡터는 가장 기본단위의 벡터로 크기를 가지고 있지 않음;

-.... 공과 마우스 포인터의 끝 지점을 벡터로 나타내서 보게되면... 각 점의 벡터는.....파란색 벡터에서 초록 벡터를 빼면 빨간 벡터가 나온대;
-(-초록색벡터)가 화살표를 뒤집힌 건데...즉...

mouse.pos - dot.pos = (dx, dy)로 표현됨!

-이 빨간색 벡터가 크기는 없고 방향성만 갖는 방향 벡터로 바꾼 뒤에 원하는 힘의 크기만큼 곱해서 나오는 벡터를 공해 더해주면 마우스게 끌려오게 됨!


<방향 벡터로 변환하는 공식>
-두 점 사이의 거리dist분의 빨간색 방향벡터의 dx, dist분의 빨간색 방향벡터의 dy
=공과 마우스포인터 사이의 거리 분의 두 점 사이의 방향 백터

-전체 거리를 나눠줬기 때문에 방향성만 갖게 됨!
-여기에 힘만 곱해주면 공을 마우스쪽으로 끌어당길 수 있게 됨!


<힘의 세기 구하는 법>
-마우스의 반지름 끝에 공이 위치해있다고 가정시, 힘은 0이됨
: r=100일때 force=0
-공과 마우스의 좌표가 일치하면 힘이 1이됨
: r=100일때 force=1

-force를 0과 1사이를 나타내게 하고, 이를 방향벡터에 곱해주면 됨


<둘이 결합>
-마우스 포인터와 범위 사이의 반지름을 radius라고 하고, 마우스포인터와 공 사이의 거리를 dist라고 했을 때...
반지름 바깥쪽에서부터 내부로 진입한 공 사이의 거리는 radius-dist가 된다

-마우스 반경 끝에 공이 위치하면 이 radius-dist=0이 되니까 힘이 작용하지 않고, 반대로 마우스포인터 위치에 공이 위치하면 이 radius-dist가 dist가 0에 가까우니까 radiuse분의 radius가 되니까 1에 가까워져서 가장 강한 힘을 받게 된다

->따라서... "1-radius분의 dist"를 하면, 0과 1 사이에 나옴



-방향 벡터와 force값을 구해서 둘을 곱해주면 된다!



<코드짜기>
-먼저 Dot.js의 업데이트 메서드 하단에서 방향 벡터를 구하기 위해, 마우스의 포지션에서 이 공의 벡터인 this.pos의 차이값 먼저 구해보기
: update(mouse){
        let {x: dx, y:dy} = Vector.sub(mouse.pos, this.pos);
}

-dx,dy는... 두 벡터의 차이를 좌표로 갖는 벡터 인스턴스에서 x,y만 추출해내면 됨
-각각 dx,dy라고 이름지음!

-그리고 direction이라는 이름으로 위에서 정의한 변수들로 방향 벡터를 만들어주기
:         const direction = new Vector(dx / dist, dy / dist);


-이제 힘 구해주기
-힘은 마우스의 반지름분의 마우스의 반지름 - 거리로 구할 수 있음
:         const force = (mouse.radius - dist) / mouse.radius;


-이제 이 force가 0~1사이값을 받는지 콘솔로 찍어서 확인해보기
:         // 힘 구하기
        const force = (mouse.radius - dist) / mouse.radius;
        // 힘이 0~1 사이값으로 생기는지 확인
        console.log(force);
-잠시 0번, 1번 점만 빼고 다른 점들 다 삭제하고, 스틱도 1개만 남기고 삭제하기
: 
        // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), ];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            
        ];



-이러고 결과보면, 마우스 좌표가 점의 위치에 가까워질수록 1이 되는 게 보임!

-근데 -값이 나오면 안되고.... 힘은 범위 바깥에 있을 때에는 항상 0이어야함
-그러면.. Dot.js로 가서 업데이트 메서드에서 dist를 정의한 부분 바로 아랫줄에다가 if문으로 dist가 마우스의 반지름보다 커지면 리턴을 시켜서, 아래 코드가실행되지 않도록 해주기!
:         // 방향 벡터 구하기 위한 변수 설정
        // 마우스 벡터와 점 벡터 사이의 차이를 갖는 벡터 인스턴스에서 x, y값만 추출
        let {x: dx, y:dy} = Vector.sub(mouse.pos, this.pos);
        // 마우스와 점 사이의 거리
        const dist = Math.sqrt(dx*dx + dy*dy);
        // 점이 마우스 범위 바깥에 존재할 경우, 리턴돼서 마이너스 값 발생하지 않도록 하기
        if(dist > mouse.radius) return;



-이제 점의 포지션에 방금 구한 방향벡터와 힘을 곱한 값을 더해주기
:         this.pos.add(direction.mult(force));

->이러면 이제 마우스 범위 안에 점이 들어올 경우, 점이 마우스에 딸려가게 된다

-근데 잘 오지만 힘이 너무 약한 것 같음
-이제 dot.js에서 최종적으로 포지션에 방향 벡터와 힘을 곱해주는 부분에서 5를 더 곱해주면 힘이 더 쎄짐!
:         this.pos.add(direction.mult(force).mult(5));


->이러면 더 강하게 끌려오기는 하는데, 공이 떨리는 현상 발생함
-한 프레임에 공과 마우스가 닿은 시점에서 강한 힘을 받아서 반대쪽으로 좌표가 이동하는데, 이동된 좌표에서도 다시 강한힘을 받아서 다시 가까워지기때문에..자꾸 오른쪽왼쪽 왔다갔다 움직이게 됨 그래서 떨리는 모습을 보임


-따라서 우리는 force값이 0.8이상의 값을 갖게 되면,this.pos.setXY로 마우스의 포지션 값을 설정해줘서, 공의 위치를 마우스의 위치로 붙여주기
:         // 힘의 강도에 따른 움직임 여부 설정
        // 일정 강도 이상의 힘을 받으면 점의 위치를 마우스의 위치로 붙여주기
        if(force > 0.8){
            this.pos.setXY(mouse.pos.x, mouse.pos.y);
        }


-그리고 0.8보다 작아질 경우에는 아까 작성했던 코드 동작하도록 하기
:         // 힘의 강도에 따른 움직임 여부 설정
        // 일정 강도 이상의 힘을 받으면 점의 위치를 마우스의 위치로 붙여주기
        if(force > 0.8){
            this.pos.setXY(mouse.pos.x, mouse.pos.y);
        }
        else{
            // 점의 위치에 방향 벡터와 힘을 곱한 값 더해주기 : 5를 추가로 곱해서 힘을 더 강하게 함
            this.pos.add(direction.mult(force).mult(5));
        }

->>떨림 보정되고 마우스에 딱붙게 됨


-근데 자세히보면... 많이 늘어났을 때.. 선분이 두 점을 잇지 못하고 끊기는 현상 발생함 ㅠㅠ
-이를 해결하기 위해서 App.js로 가서, 프레임함수에서 점을 forEach 돌면서 업데이트하고 그리는 코드 다음에, 스틱을 업데이트하고 그리고있기 떄문임
-닷과 스틱이 따로 업데이트,그려지기 때문임..그래서 유기적으로 동작하지 않는 것!

-따라서, 점과 스틱 배열이 각각 forEach로 돌면서 각각 update를 시킨다음에, 점과 스틱 배열이 각각 forEach돌면서 각각 draw해야한다
:             // 점, 선 관련
            // 유기적으로 동작하기 위해 따로 update, draw 시킴
            this.dots.forEach(dot => {
                dot.update(this.mouse);
            });
            this.sticks.forEach(stick => {
                stick.update();
            });

            this.dots.forEach(dot => {
                dot.draw(this.ctx);
            });
            this.sticks.forEach(stick => {
                stick.draw(this.ctx);
            });


-이렇게 빈 공간 없이 잘 늘어남

<이제 너무 늘어나는 것 조정하기>
-Stick.js에서 컨스트럭터의 텐션변수 값을 0.5로 수정
:     this.tension = 0.5; // 탄성이 줄어서 무거울수록 늘어짐

-App.js로 가서 다시 점과 스틱 수 늘리기
:         // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50), new Dot(800, 0),];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2]),
            new Stick(this.dots[2], this.dots[3]),
        ];






<Rope 클래스 만들기>
-이제 로프 클래스를 만들어서 지금까지 작업했던것처럼 점,선 하나씩 만들지말고 공장처럼 찍어내보도록 하자

-그런데 밧줄 만들기 전에, 알고리즘 좀 보완하기^^,.................미리 좀 해라....


1.보완 1번
-어떤 시점에 공이 마우스오 ㅏ가까워도 튕겨져나가는 경우가 있음
-dot클래스의 업데이트 메서드와 관련있음
-업데이트 메서드에 가서 보면, 상단에서 먼저 속도를 구하고 포지션에 적용한 다음 force값을 계산해서 다시 포지션에 적용하고 있음
-근데 스틱 클래스에서 또! 유기적으로 스틱을 통해서 공들의 포지션을 변경하고 있음
-게다가 App.js에 가서 프레임함수를 보면... dot을 먼저 업데이트한 다음에 스틱을 업데이트 하고 있음

-따라서 현재 프레임에서 dot업데이트 마지막 부분에서.. force가 0.6보다 커질 경우 마우스 포지션에 맞춰 공의 포지션을 세팅하더라도... 그 다음 프레임에서 스틱으로 인해서 변경된 포지션과..마찬가지로 중력 가속도 영향으로 인해 또 포지션이 변경될 수있음
-그래서 0.6보다 크다고 하고 내려왔는데 저런 내용들 때문에 값이 바껴서 작아질 수 있음
-그래서 튕겨나가는 현상이 발생하는 것임


-이문제 해결하기 위해서 속도 반영하는 구문을 맨 마지막 else구문 안으로 옮겨줘야함
-그리고 dist가 마우스의 반지름보다 크면 리턴하는 부분도 지워주고,
-그와 같은 내용을 force를 정의하는 부분에서 만들어주면 됨
-Math의 max로 첫번째 인자에 기존 force에 할당한 내용을 넣고 두번째 인자로 0을 넣어주면... 첫번째 인자 값이 0보다 작아질 경우에는 0이 최대값이기 때문에 거리의 차이가 음수일때 force를 0으로 계속 나타낼 수 있음!

:     update(mouse){
        // 만약 dot이 고정되어 있다면 움직이지 않게 하기
        if(this.pinned) return;

        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);

        // 속도에 마찰력 곱하여 마찰력 부여하기
        vel.mult(this.friction);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        // console.log(vel);
        // this.pos.add(vel); // 👉 하단의 else문으로 이동

        // 방향 벡터 구하기 위한 변수 설정
        // 마우스 벡터와 점 벡터 사이의 차이를 갖는 벡터 인스턴스에서 x, y값만 추출
        let {x: dx, y:dy} = Vector.sub(mouse.pos, this.pos);
        // 마우스와 점 사이의 거리
        const dist = Math.sqrt(dx*dx + dy*dy);
        // 점이 마우스 범위 바깥에 존재할 경우, 리턴돼서 마이너스 값 발생하지 않도록 하기
        // if(dist > mouse.radius) return; // 👉force 부분으로 이동

        // 방향 벡터
        const direction = new Vector(dx / dist, dy / dist);

        // 힘 구하기 : 점이 마우스 범위 바깥에 존재할 경우(마이너스 값)와 0을 비교해서 최대값을 할당하기 = 마이너스값과 0을 비교하면 0이 큰 값이므로, 항상 0이 할당됨
        const force = Math.max((mouse.radius - dist) / mouse.radius, 0);
        // 힘이 0~1 사이값으로 생기는지 확인
        // console.log(force);

        // 힘의 강도에 따른 움직임 여부 설정
        // 일정 강도 이상의 힘을 받으면 점의 위치를 마우스의 위치로 붙여주기
        if(force > 0.8){
            this.pos.setXY(mouse.pos.x, mouse.pos.y);
        }
        else{
            // 위치에 속도 더해주기
            this.pos.add(vel);
            // 점의 위치에 방향 벡터와 힘을 곱한 값 더해주기 : 5를 추가로 곱해서 힘을 더 강하게 함
            this.pos.add(direction.mult(force).mult(5));
        }
    }




2.보완 2번
-현재 유기적으로 연결된 점과 선이 많지 않아서 큰 문제가 안보이는데, 나중에 연결점이 많아지면... 한 프레임만 돌면서 점과 선을 업데이트를 한번씩만 해주면.. 다 반영되지 못하는 경우가 있음
-그 경우, 반영되지 못한 부분이 다음 프레임으로 넘어가면서 사이드이펙트가 발생할 수 있음
-따라서 App.js에서 한 점이 다른 점에 영향을 주는 부분이 stick의 업데이트 메서드 실행 부분인데, 이 부분을 한번만 실행하는 것이 아니라, 가능한 만큼 많이 시켜주면.. 그만큼 사이드 이펙트가 실행될 확률이 적어짐!

-따라서 for문으로 우선 10번 정도를 돌면서.. 스틱의 업데이트 구문을 반복시켜주면 됨
-테스트해본결과 이터레이션을 10번정도 도는게, 사이드이펙트도 안 생기고 퍼포먼스도 적당 한것 같다고 함....
: render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

           ...

            // 점, 선 관련
            // 유기적으로 동작하기 위해 따로 update, draw 시킴
            this.dots.forEach(dot => {
                dot.update(this.mouse);
            });
            // 한 점이 다른 점에 영향을 주게 만드는 선을 업데이트 하는 횟수를 늘려서 처리할 양이 많아질 경우에 발생할 수 있는 사이드 이펙트를 방지하기 위해 update메서드 여러번 실행하기
            // this.sticks.forEach(stick => {
            //     stick.update();
            // });
            for(let i=0; i < 10; i++){
                this.sticks.forEach(stick => {
                    stick.update();
                });
            }

            this.dots.forEach(dot => {
                dot.draw(this.ctx);
            });
            this.sticks.forEach(stick => {
                stick.draw(this.ctx);
            });
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }



-현재 여기서 잠재적 버그 해결했지만 큰 변화 보이지 않음
-일단 보기에는... 텐션이 좀 더 딱딱해져서 잘 안늘어나는 것처럼 보이게 됨
-그 이유는... 텐션을 0.몇으로 낮게 줘서.. 원래 길이로 돌아오는 것을 늦춰주었더라도.. 한 프레임에서 스틱 업데이트를 여러번 반복시켜서... 그 업데이트 메서드가 반복해서 실행되는 횟수만큼 빨리 돌아오게 되는 것임
-원래는 텐션을 0.1을 줘서 10분의 1만큼만 되돌아오려고 하려던 것이... 10번을 돌면서 10분의 1을 10번 반복하니까... 1만큼 되돌아오게 되는 것임...!
-그래서 결과적으로 텐션이 높아져서..딱딱해 보이는 것임

-이건 텐션을 지금보다 더 낮게 주면 해결됨

-Stick.js의 컨스트럭터에서 tension을 0.3으로 주면 아까처럼 적당히 늘어지게 됨
:   constructor(p1, p2){
    // 시작점
    this.startPoint = p1;
    // 끝점
    this.endPoint = p2;

    // 원래 길이
    this.length = this.startPoint.pos.dist(this.endPoint.pos);

    // 텐션
    // this.tension = 1;
    // this.tension = 0.5; // 탄성이 줄어서 무거울수록 늘어짐
    this.tension = 0.3; // 한 프레임에서 stick의 update()메서드를 여러번 호출해서, 이전보다 텐션값을 낮게 주어야 함
  }



<로프 클래스 만들기>
-이제 js폴더에서 Rope.js파일을 만들기
: export default class Rope{
  constructor(){

  }
  update(){

  }
  draw(){
    
  }
}

-바깥에서 config 옵션 가지고 올 것임
:  constructor(config){
    // 점의 위치
    this.x = config.x;
    this.y = config.y;

-먼저 밧줄 제일 위에 0번째 공이 위치할 x,y좌표를 가져오기 위해서 this.x, y로 받아오기
-또는 바깥에서 입력된 값이 없을 때를 대비해서 디폴트 값으로 10을 넣어주기
-그리고 gap이라고..점과 점사이의 거리로 초기 스틱의 길이라고 보면됨
-똑같이 config로 바깥에서 받아오거나 디폴트값으로 50넣어주기
-스틱의 업데이트 반복 횟수도 밖에서 받아오거나, 마찬가지로 10으로 초기화해주기
:     // 생성할 점의 갯수 : 밖에서 입력값을 안 줄 때에는 10 넣기
    this.segments = config.segments || 10;
    // 점과 점 사이의 거리
    this.gap = config.gap || 50;
    // stick의 업데이트 반복 횟수
    this.iterations = config.iterations || 10;



-dots과 sticks도 만들어서 빈 배열로 초기화해주기
:     // 점 배열
    this.dots = [];
    // 선 배열
    this.sticks = [];


-로프 생성하는 메서드 만들어주기
-create()란 이름으로 메서드 만들기
-점이 먼저 있어야하니까 for문 돌면서 0부터 segments까지 돌면서 i++해주기
-점 배열에다가 새로 만든 점 인스턴스를 푸시해주기
:   // 로프 생성하기
  create(){
    for(let i = 0; i < this.segments; i++){
      this.dots.push(new Dot);
    }
  }

-그리고 new Dot의 인스턴스 인자값으로 this.x, y + i * this.gap을 넣어주면됨
-이러면 각 점들이 y축 방향으로 this.gap만큼 서로 떨어져서 생성됨 (x축 방향은 다 같은 값이니까 세로로는 한 줄로 서있는 모양임)
:   create(){
    for(let i = 0; i < this.segments; i++){
      // 점 생성하기
      this.dots.push(new Dot(this.x, this.y + this.gap*i));
    }
  }


-이제 점을 연결하는 선분 생성하기
-마찬가지로 for문 돌면서 segments의 -1만큼만 돌면서 이터레이션해주기
-즉, 선분은 점의 갯수보다 1개가 적어야함
-그리고 빈 배열에 푸시로 스틱 인스턴스를 생성해서 넣기
-인스턴스의 인자로는 dots의 인덱스번호갸 i번째, dots의 인덱스번호가 i+1번째를 순서대로 넣으면...  i번째의 점과 i+1번째의 점을 서로 연결하게 됨
:   create(){
    // 점 생성하기
    for(let i = 0; i < this.segments; i++){
      this.dots.push(new Dot(this.x, this.y + this.gap*i));
    }
    // 선 생성하기
    for(let i = 0; i < this.segments - 1; i++){
      this.sticks.push(new Stick(this.dots[i], this.dots[i + 1]));
    }
  }



-이제 이렇게 만든 크리에이트 메서드를 컨스트럭터 안의 제일 하단에서 실행해주기
:   constructor(config){
    // 점의 위치
    this.x = config.x;
    this.y = config.y;

    // 생성할 점의 갯수 : 밖에서 입력값을 안 줄 때에는 10 넣기
    this.segments = config.segments || 10;
    // 점과 점 사이의 거리
    this.gap = config.gap || 50;
    // stick의 업데이트 반복 횟수
    this.iterations = config.iterations || 10;

    // 점 배열
    this.dots = [];
    // 선 배열
    this.sticks = [];

    // 생성 함수 호출
    this.create();
  }



-업데이트 함수 안에서 app.js안에 있는 점과 선의 업데이트 구문을 모두 잘라내서 이 안에 넣어주기
(((App.js)))
            // 유기적으로 동작하기 위해 따로 update, draw 시킴
            this.dots.forEach(dot => {
                dot.update(this.mouse);
            });
            // 한 점이 다른 점에 영향을 주게 만드는 선을 업데이트 하는 횟수를 늘려서 처리할 양이 많아질 경우에 발생할 수 있는 사이드 이펙트를 방지하기 위해 update메서드 여러번 실행하기
            // this.sticks.forEach(stick => {
            //     stick.update();
            // });
            for(let i=0; i < 10; i++){
                this.sticks.forEach(stick => {
                    stick.update();
                });
            }

->이부분 잘라내기


(((Rope.js)))
  update(){
    // 유기적으로 동작하기 위해 따로 update, draw 시킴
    this.dots.forEach(dot => {
      dot.update(this.mouse);
    });
    // 한 점이 다른 점에 영향을 주게 만드는 선을 업데이트 하는 횟수를 늘려서 처리할 양이 많아질 경우에 발생할 수 있는 사이드 이펙트를 방지하기 위해 update메서드 여러번 실행하기
    for(let i=0; i < 10; i++){
      this.sticks.forEach(stick => {
          stick.update();
      });
    }
  }
-이렇게 붙여넣기


-그리고 상수 10을 넣어서 반복시킨 것을 this.iterations로 바꿔주기
:   update(){
    // 유기적으로 동작하기 위해 따로 update, draw 시킴
    this.dots.forEach(dot => {
      dot.update(this.mouse);
    });
    // 한 점이 다른 점에 영향을 주게 만드는 선을 업데이트 하는 횟수를 늘려서 처리할 양이 많아질 경우에 발생할 수 있는 사이드 이펙트를 방지하기 위해 update메서드 여러번 실행하기
    for(let i=0; i < this.iterations; i++){
      this.sticks.forEach(stick => {
          stick.update();
      });
    }
  }




-그리고 이제 this.mouse도 바깥에서 마우스를 보내준거를 받아와서 쓰도록 this.를 빼버리기
:   update(mouse){
    this.dots.forEach(dot => {
      dot.update(mouse);
    });
    // 한 점이 다른 점에 영향을 주게 만드는 선을 업데이트 하는 횟수를 늘려서 처리할 양이 많아질 경우에 발생할 수 있는 사이드 이펙트를 방지하기 위해 update메서드 여러번 실행하기
    for(let i=0; i < this.iterations; i++){
      this.sticks.forEach(stick => {
          stick.update();
      });
    }
  }


-draw메서드도 마찬가지로 App.js에서 draw되는 부분을 모두 잘라내서 rope.js의 draw메서드에서 붙여주기
:   draw(){
    this.dots.forEach(dot => {
      dot.draw(this.ctx);
    });
    this.sticks.forEach(stick => {
      stick.draw(this.ctx);
    });
  }

-그리고ctx도 바깥에서 가져와서 전달해주도록 this.ctx에서 ctx로 바꿔주고 draw에 인자 추가하기
:   draw(ctx){
    this.dots.forEach(dot => {
      dot.draw(ctx);
    });
    this.sticks.forEach(stick => {
      stick.draw(ctx);
    });
  }



-이제 테스트 위해 App.js로 가서 컨스트럭터 안에다가, 기존에 하나씩 작성한 점과 선 관련 코드 모두 지우기
(((App.js의 constructor에서 지울 부분)))
: // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50), new Dot(800, 0),];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2]),
            new Stick(this.dots[2], this.dots[3]),
        ];

        // 점을 고정해두기
        this.dots[0].pinned = true;


-이제 this.ropes를 빈 배열로 초기화하기
-그리고 우선 테스트 위해 1개만 그려볼것이므로, rope_1 변수를 만들고 로프 인스턴스를 하나 만들어주기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));

        // 마우스 생성
        this.mouse = new Mouse(this.canvas);

        // 점, 선을 한번에 만들어내는 로프 생성
        this.ropes = [];
        const rope_1 = new Rope();
    }


-그리고 config값으로 객체를 만들어서 x : 400, y : 100을 넣고 배열에 푸시하기
:         // 점, 선을 한번에 만들어내는 로프 생성
        this.ropes = [];
        const rope_1 = new Rope({ x: 400, y: 100 });
        this.ropes.push(rope_1);


-그리고 아래 frame함수 안에서 기존에 지워진 코드 위치에서 로프 배열을 forEach를 돌면서 업데이트, 드로우해주기
:const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            
            then = now - (delta % App.interval);
            
            this.ctx.clearRect(0, 0, App.width, App.height);
            ///////////////////////////////////////////////////

            // 테스트용 사각형 그리기
            // this.ctx.fillRect(100, 100, 100, 100);

            // 점, 선 관련 : 유기적으로 동작하기 위해 따로 update, draw 시킴 👉 모두 Rope.js로 옮김
            // 점, 선을 한번에 그리는 로프 관련
            this.ropes.forEach(rope => {
                rope.update();
                rope.draw();
            });

        };



-그리고 업데이트 메서드에는 this.mouse를 인자로 보내주고, darw인자에는 ctx를 인자로 보내주기
:             this.ropes.forEach(rope => {
                rope.update(this.mouse);
                rope.draw(this.ctx);
            });



-이제 로프가 잘 그려지긴 하는데, 핀으로 고정하지 않아서 아래로 떨어져버림

-Rope.js로 돌아가서 핀을 해주는 메서드를 만들어주기 (업데이트 메서드 위에다 만들기)
-컨스트럭터 하단에서 pin이라는 메서드를 만들고 인자로는 index를 가져오게 함
-그리고 점 배열의 인덱스번호번째 점에 pinned가 true라고 해주기
:   // 점을 화면에 고정하기
  pin(index){
    this.dots[index].pinned = true;
  }


-이제 다시 app.js로 돌아와서 로프1을 정의한 부분 아래에다가 로프1에 핀으로 0을 넣으면 고정됨
:         // 테스트위해 로프 1개 만들어보기
        const rope_1 = new Rope({ x: 400, y: 100 });
        rope_1.pin(0);
        this.ropes.push(rope_1);



-





[ 응용하기 ]
-이걸 활용해보기

-App.js로 돌아와서 컨스트럭터 안에 있는 로프 그리는 내용 지우기
((지울 내용))
        // 점, 선을 한번에 만들어내는 로프 생성
        this.ropes = [];

        // 테스트위해 로프 1개 만들어보기
        const rope_1 = new Rope({ x: 400, y: 100 });
        rope_1.pin(0);
        this.ropes.push(rope_1);


-리사이즈 메서드 안의 맨 하단에 this.initRopes라는 메서드를 만들고 이걸로 리사이즈할때마다 로프배열 초기화하고 새로 생성해주도록 하기
:     resize(){
        // 리사이즈 될 때마다 화면의 가로, 세로값 다시 지정
        App.width = innerWidth;
        App.height = innerHeight;

        // 캔버스 사이즈 지정
        this.canvas.width = App.width * App.dpr;
        this.canvas.height = App.height * App.dpr;

        // 캔버스 CSS 스타일 지정
        this.canvas.style.width = App.width + 'px';
        this.canvas.style.height = App.height + 'px';

        // 선명도 높이기 : dpr다른 기기들 모두 같은 모습 볼 수 있게 함
        this.ctx.scale(App.dpr, App.dpr);

        // 리사이즈 될 때마다 로프 배열 초기화, 새로 생성하기
        this.initRopes();
    }



-그리고 resize메서드 바로 아래에 이닛로프스 메서드를 만들고, 제일 먼저 ropes를 만들고 빈 배열로 초기화하기
:     initRopes(){
        this.ropes = [];
    }


-생성해줄 로프의 갯수를 TOTAL로 만들어주기
:     initRopes(){
        this.ropes = [];
        
        // 생성할 로프의 갯수
        const TOTAL = 0;
    }

-이닛로프스로 리사이즈메서드에서 쓰는 이유가, 이 토탈의 갯수를 화면 사이즈마다 다르게 할 것이기 때문
-화면의 가로사이즈app.width에 0.06정도를 곱해주면, 적당히 화면의 가로사이즈에 맞는 밧줄의 갯수를 나타내줌
:     initRopes(){
        this.ropes = [];

        // 생성할 로프의 갯수 : 화면 가로사이즈에 맞게 갯수 생성
        const TOTAL = App.width * 0.06;
    }


-가로 사이즈에 맞게 적당히 만들어줌


-이 토탈을 for문으로 돌면서 로프 변수를 만들고 로프 인스턴스를 생성해서, x,y값과 기타 옵션을 조정해주면됨
:         for(let i = 0; i < TOTAL; i++){
            // 로프 인스턴스 생성
            const rope = new Rope();
        }

-밧줄이 화면 천장에 매달려있는 효과를 주고, 화면의 가로 사이즈에서 적당히 랜덤한 위치에 로프 생성하고 싶기 때문에, 우선 랜덤 유틸 함수가 필요함

-js폴더 안에 utils.js란 파일 생성하기
-여기서 랜덤넘버비트윈 함수를 만들기
-이전에 만들었던 것과 동일하게 최소값과 최대값 사이에서 랜덤값을 뽑아내는 함수를 하나 만들기
: // 최소값, 최대값 사이에서 랜덤한 값 하나를 리턴하는 함수
export const randomNumBetween = (min, max)=>{
  return Math.random() * (max - min) + min;
};


-돌아와서, 아까 인스턴스 생성하는 곳의 인자로 x값을 앱의 가로값을 넣는데, 우선 랜덤한 값을 넣어주기 위해서 랜덤함수를 쓰고, 그 안에서 최소값, 최대값을 넣어야하는데...양사이드에 생기면 잘 안보이고 별로니까 적당히 안쪽에서 생기도록 양 사이드에 패딩을 줘야함!
:         for(let i = 0; i < TOTAL; i++){
            // 로프 인스턴스 생성
            const rope = new Rope({
                x: randomNumBetween(App.width*0.3, App.width*0.7)
            });
        }


-그리고 y좌표는 천장에 매달려있어야하니까 0을 넣어주면 됨

        for(let i = 0; i < TOTAL; i++){
            // 로프 인스턴스 생성
            const rope = new Rope({
                x: randomNumBetween(App.width*0.3, App.width*0.7),
                y: 0
            });
        }


-그리고 화면에 고정되어 있도록 pin처리를 해줘야함
:         for(let i = 0; i < TOTAL; i++){
            // 로프 인스턴스 생성
            const rope = new Rope({
                x: randomNumBetween(App.width*0.3, App.width*0.7),
                y: 0
            });
            
            // 로프 화면에 고정하기 위해 핀으로 꼽기
            rope.pin(0);
        }


-이렇게 생성한 인스턴스를 ropes배열에 순서대로 담기
:             // 로프 화면에 고정하기 위해 핀으로 꼽기
            rope.pin(0);

            // 로프 배열에 담기
            this.ropes.push(rope);




<<너무 못생긴 모습 좀 이쁘게 고쳐주기>>
-Sick.js로 가서 먼저 draw()메서드로 가서, lineWidth를 1로 만들어서 선분을 얇게 해주기
:   draw(ctx){
    // 스틱 관련
    ctx.beginPath();
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 1;

-그리고 Dot.js로 가서 점도 작게 만들어주면 됨
-draw()메서드로 가서... 지금은 arc형태로 공을 그렸는데, 이제 이거를 아주 작은 정사각형 형태로 만들 것임
-왜냐면 아주 작은 원과 정사각형은 육안으로 보기에는 별 차이가 없지만, 정사각형으로 그리면 코드가 짧아지기 때문!
-퍼포먼스에도 더 좋음!


-그래서 우선 지금 선분 그리는 것을 다 지우기
((지울 내용))
    draw(ctx){
        // 점 그리기
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }

-그래서 우선 ctx.fillStyle를 #999로 해서 stick.js의 daraw에서 그리는 선분과 색상을 동일하게 맞춰주기
:     draw(ctx){
        // 점 그리기
        ctx.fillStyle = "#999";
    }

-그리고 fillRect()로 정사각형을 그려주는데, 시작x위치는 this.pos.x에서 this.mass만큼을 빼주기
-y는 this.pos.y에서 this.mass를 빼주기
-width는 this.mass*2를 하고 height도 mass에다가 2를 곱해서 넣기
:     draw(ctx){
        // 점 그리기
        ctx.fillStyle = "#999";
        ctx.fillRect(this.pos.x - this.mass, this.pos.y - this.mass, this.mass*2, this.mass*2);
    }


-그리고 로프가 잘 보이게 하기 위해서 배경색을 어둡게 만들어주기
-css로 가서.. 배경색을 #1f1f1f로 해주기
: html, body{
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1f1f1f;
}



-일단 이렇게만 해두면 x값은 화면 가로 사이즈에 맞춰서 적당히 갯수가 조절되는데, 공과 공 사이의 선분은 우리가 적당히 상수값을 줘서 그대로임
-그래서 화면 세로 사이즈가 달라져도 그 사이즈 그대로 고정되어 있기 때문에, 이 역시 반응형으로 만들어줘야함

-gap도 마찬가지로 랜덤함수를 써서 랜덤값을 넣어주는데, 최소값으로는 앱의 세로크기*0.05, 최대값은 앱의 세로크기*0.08정도로 사이즈를 넣어주기
:         for(let i = 0; i < TOTAL; i++){
            // 로프 인스턴스 생성
            const rope = new Rope({
                x: randomNumBetween(App.width*0.3, App.width*0.7),
                y: 0,
                gap: randomNumBetween(App.height*0.05, App.height*0.08)
            });
-이렇게 넣으면 각 로프들의 길이가 랜덤하게 들쭉날쭉한 모양으로 만들어지게됨!
-또한 리사이즈하면 화면ㅅ ㅏ이즈에 맞게 길이가 조절됨!!



<<밧줄 하단에 전구 달기>>

-이제 데코를 위해 밧줄 맨 하단에 전구를 달아보기로 함
-assets폴더 만들고 그 안에 전구 이미지 파일을 넣어주기

-이 이미지 파일은 25px 25px의 아주 작은 파일임
-캔버스에서 빛이 글로우되는 이펙트를 보여주려면.... 블러가 아주 많이 들어가야함
-그런데 이미지 파일의 화질이 좋으면..블러처리가 잘 안되기 때문에, 낮은 픽셀의 이미지 파일을 강제로 캔버스에서 크기를 키워서 그리면 글로잉효과 만들 수 있음

-또 캔버스에서 직접 그라데이션을 하거나 비슷한 효과를 내기 위해서는 cpu 연산량에서도 무리가 될 수 있음
-그래서 이미지를 적절히 사용하는 것도 좋은 팁임!!


-이제  html파일로 가서 이미지 태그를 하나 만들고 이미지를 불러오기
:    <!-- 불빛 이미지 -->
    <img src="./assets/glowing.png" id="light-img" class="asset-img" alt="노랗게 빛나는 불빛">
    <!-- 캔버스 -->
    <canvas></canvas>


-이제 css파일로 가서 html파일에 불러온 이미지가 화면 상에서는 안 보이게 만들기
: /* 이미지 파일 안보이게 숨기기 */
.asset-img{
    display: none;
}


-그리고 Dot.js로 가서 컨스트럭터 하단에서 lightImg변수를 만들고 쿼리 셀렉터로 방금 만든 이미지 불러오기
    constructor(x, y){
...
        // 무게
        this.mass = 1;

        // 불빛 이미지 불러오기
        this.lightImg = document.querySelector("#light-img");
    }
-그리고 이미지의 크기를 15로 초기화해주기
:         // 불빛 이미지 사이즈
        this.lightSize = 15;


-그리고 darw메서드의 아래쪽에다가 drawLight메서드를 만들고, 마찬가지로 ctx를 바깥에서 불러오게 만들기
:     draw(ctx){
 ....
    }
    // 불빛 이미지 그리기
    drawLight(ctx){

    }



-drawImage로 이미지를 넣어주고, x,y값은 순서대로 pos.x-lightSize/2를 해주고, y값도 y좌표값에서 이미지사이즈를 나누기2해주기
-그리고 width,height는 lightSize를 넣어서 정사각형 그대로 그려주면 됨
:     // 불빛 이미지 그리기
    drawLight(ctx){
        ctx.drawImage(
            this.lightImg,
            this.pos.x - this.lightSize / 2,
            this.pos.y - this.lightSize / 2,
            this.lightSize,
            this.lightSize
        );
    }


-이제 Rope.js로 가서, draw()메서드 안의 하단에서 모든 점,선 그리는 작업이 끝난 후에... 가장 끝에 있는 공에다가 불빛을 그려주면 됨
:   draw(ctx){
    this.dots.forEach(dot => {
      dot.draw(ctx);
    });
    this.sticks.forEach(stick => {
      stick.draw(ctx);
    });

    // 로프 최하단에 불빛 달아주기
    this.dots[this.dots.length - 1].drawLight(ctx);
  }


-이러면 전구가 달린 것처럼 달림!


-마지막으로 인터렉션 재미를 추가하기 위해 로프를 잡아당기면 줄이 끊어지는 효과 부여하기
-rope.js로 가서, pin()메서드 아랫줄에서 checkPullingOut()이라는 메서드를 만들기
:   // 점을 화면에 고정하기
  pin(index){
    this.dots[index].pinned = true;
  }

  // 선분 늘어나는 길이 체크하기
  checkPullingOut(){
    
  }
-특정 조건을 만족하면 로프를 뽑아주는 메서드를 만들면 됨

-로프를 뽑기 위해서는 '악력'개념을 계산해서 넣어줘야함
-복잡한 알고리즘 빼고^^..잡아 당길 때 늘어나는 stick의 길이와 원래의 stick의 길이를 비교해서 일정 비율을 넘어가면 뽑아지게 만들기
-"뽑힌다"는 의미는 pin()으로 0번째 공이 고정되어 있는데 이 ture로 고정되어 있는 것을 false로 바꿔서 핀이 풀리게 만든다는 뜻임



-실제로 늘어난 선의 길이 체크해야하는데, 0번째 선의 길이를 기준으로 체크할것임
-이 checkPullingOut()메서드 안에서 
-벡터 인스턴스의 dist메서드로 0번째 점과 첫번째 점의 사이의 거리(dist)를 알아내어서 dist변수에 담기
:     // 0번째 점과 1번째 점 사이의 거리 알아내기
    const dist = this.dots[0].pos.dist(this.dots[1].pos);

-그리고 dist / 0번째 선분의 오리지널 길이가 1.2보다 크면, 0번째 점의 pin을 false로 바꿔서 
선분이 1.2배 늘어나는 순간이 되면 핀을 풀어주기
:     // 0번째 선분의 원래 길이보다 1.2배 이상 늘어나면 pin 해제하기
    if((dist / this.sticks[0].length) > 1.2){
      this.dots[0].pinned =false;
    }


-이제 Rope.js의 update()메서드 안에서 최상단에서 이 check어쩌고 메서드를 실행해주기!
:   update(mouse){
    // 선분 늘어나는 길이 체크->핀 해제하기
    this.checkPullingOut();
    
    this.dots.forEach(dot => {
      dot.update(mouse);
    });
    // 한 점이 다른 점에 영향을 주게 만드는 선을 업데이트 하는 횟수를 늘려서 처리할 양이 많아질 경우에 발생할 수 있는 사이드 이펙트를 방지하기 위해 update메서드 여러번 실행하기
    for(let i=0; i < this.iterations; i++){
      this.sticks.forEach(stick => {
          stick.update();
      });
    }
  }



-마우스를 천천히 움직여서 줄이 천천히 늘어나게되면 로프가 뽑히게 됨...

1.2가 아니라1.4로 값을 올리면...털(?)이 잘 안뽑히게 된다...^^;;;










