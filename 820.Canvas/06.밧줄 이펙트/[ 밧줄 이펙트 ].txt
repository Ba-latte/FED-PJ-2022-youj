[밧줄 이펙트]
-현업에서는 물리알고리즘을 모아서 쉽게 사용가능하도록 만들어둔 라이브러리를 활용하겠지만, 이번 강의에서는 직접 물리알고리즘을 이해하고, 구현하는데 목적이 있음
-물리 알고리즘이 어떻게 돌아가는지 이해하기!

-x,y좌표에 대한 값 이해하기

-stick클래스가 이번 강의에서 포인트임!



<기초 뼈대 구성하기>
-style.css파일 만들고 헤드 태그에서 link로 불러오기
-canvas태그 넣기
-스크립트 태그 만들기

-styel.css에서는 html, body의 기본 마진,패딩 없애기
: @charset "utf-8";

html, body{
    margin: 0;
    padding: 0;
}


-그리고 index.js에 바로 코딩하지 말고, App.js를 만들고 거기서 작성한다음 index.js에 불러올것임
-그 이유는 index.js는 밧줄말고도 다른 웹 구성요소들이 모이는 곳이기 때문에 실전처럼 다른 곳에 빼두는 것임!
-내게 맞는 보일러플레이트를 만들어서 정착하면 됨

-js폴더 만들고 App.js파일 만들고 기초 구성하기
:export default class App{
    constructor(){

    }
    resize(){

    }
    render(){
        
    }
}

-그리고 컨스트럭터 작성하기 전에, 상단에 스태틱으로, 상수로 사용되는 변수들을 미리 작성해두기
: static width = innerWidth;
    static height =  innerHeight;
    static dpr = devicePixelRatio > 1 ? 2 : 1;
    static interval = 1000 / 60;
-전체 화면의 픽셀값들 미리 정해두기
-dpr도 1보다 크면 2, 아니면1로 해두기
-인터벌도 60fps로 동작하게끔 1000분의 60으로 해두기

-그리고 이제 컨스트럭터에서 캔버스불러오기
-그리고 ctx 변수를 2d로 만들어두기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");
    }
-이전에는 이 두개도 스태틱으로 해서 사용했었는데, 매번 스태틱으로 getContext로 객체를 만드는 것보다, 이렇게 컨스트럭터에서 써주면, 한번만 변수에 저장해두면 더 편할 수 있음


-이제 리사이즈 메서드에서 App.width와 height를 리사이즈될떄마다 변경되는 전체 화면의 가로, 세로 길이를 다시 스태틱으로 저장해주기
:     resize(){
        // 리사이즈 될 때마다 화면의 가로, 세로값 다시 지정
        App.width = innerWidth;
        App.height = innerHeight;
}
-이 값을 통해서 캔버스 css 가로세로값과 실제 캔버스의 가로세로값을 적용해주면 됨
: // 캔버스 CSS 스타일 지정
        this.canvas.style.width = App.width + 'px';
        this.canvas.style.height = App.height + 'px';

-캔버스의 사이즈를 앱의 가로/세로값에 * dpr곱해주는 이유는, dpr이 1 이상일 때 2로 통일시켜주는것임
-그 이유는 고유 캔버스 사이즈가 커질수록 .. 예를 들어 이미지 파일이 고해상도일 경우, 파일 용량이 커지는것처럼, 캔버스에서 그리는데에 영향을 끼칠 수있기 때문임!

- 캔버스 사이즈도 지정해주기
: // 캔버스 사이즈 지정
        this.canvas.width = App.width * App.dpr;
        this.canvas.height = App.height * App.dpr;


- 그리고 이제 ctx의 스케일에 dpr을 각각 곱해줘서 선명도를 높여주고, 또 낮은 dpr과 높은 dpr에서 모두 같은 모습으로 볼 수 있도록 해주기
: this.ctx.scale(App.dpr, App.dpr);


-이제 컨스트럭터에서 리사이즈 메서드를 호출해서 최초 한번 실행하도록 하고, 리사이즈 이벤트가 발생할때마다 리사이즈 함수를 실행하도록 해주기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));
    }

->근데 이렇게만 하면, 리사이즈 메서드가 실행될 때 안에서 선언된 this가 윈도우라고 인식하기 때문에 bind(this)를 추가로 메서드체인해줘서 this값을 앱으로 인식할수 있도록 함



-그리고 렌더로 넘어가서, let으로 now, delta선언하고 then = Date.now()로 현재 시간 담아주기
:     render(){
        let now, delta;
        let then = Date.now();
}
-frame()함수를 만들고, 그 안에서 리퀘스트애니메이션프레임함수에서 프레임함수를 다시 호출해서, 재귀함수로 스스로 기기의 모니터 주사율마다 프레임이 실행될수있도록 함
:         const frame = ()=>{
            requestAnimationFrame(frame);
}
=>즉 모두 같은 속도로 캔버스를 그리게 하기 위함

-그리고 아랫쪽에서 코드짜기
: now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
-델타는 나우와 덴값의 차이로, 델타가 인터벌보다 작으면 리턴을 시켜서 모니터 주사율인 60헤르쯔를 기준으로 캔버스가 애니메이션되도록 해줌

-그리고 나우에서 델타를 인터벌로 나눈 나머지값을 뺀 값을 다시 덴에 넣어주기
: then = now - (delta % App.interval);

-그리고 그 아래쪽에서 clearRect()를해서, 전체화면을 프레임마다 지우는 과정을 해주기
: this.ctx.clearRect(0, 0, App.width, App.height);

-그러고나서 우선 테스트용으로 정사각형 하나 그려서 잘 동작하는지 확인하기
: this.ctx.fillRect(100, 100, 100, 100);



-이제 이 프레임을 실행해야하니까 바로 아랫줄에서 리퀘스트애니메이션프레임으로 프레임함수 실행되도록 하기
:     render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            ///////////////////////////////////////////////////
            
            ///////////////////////////////////////////////////
            then = now - (delta % App.interval);

            this.ctx.clearRect(0, 0, App.width, App.height);

            // 테스트용 사각형 그리기
            this.ctx.fillRect(100, 100, 100, 100);
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }


-그리고 이제 다시 index.js로 돌아가서 로드이벤트로 모든게 로드되었을 때 앱 인스턴스를 생성해서 저장한 app변수를 만들고, 이 앱을 렌더함수로 실행시켜주기
: window.addEventListener("load", ()=>{
    const app = new App();
    app.render();
});






[ 닷 클래스 만들기 ]

-x,y좌표에 점을 찍고 이게 서로 스틱으로 연결되고 서로 영향을 주고 상호작용하게 만들 것임

-이제 기본적인 점을 만들어줄 것임
- js폴더에 Dot.js파일 만들고 기본 세팅하기
: 
export default class Dot{
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}


-닷은 말그대로 한 점을 말함! 그래서 필요한 인자는 딱 2개임 x,y좌표!
-이걸 this.x, this.y 선언하고 넣을건데 이번에는 this.x, this.y라고 하지 않고! 물리 라이브러리에서 하는 것처럼 "벡터"개념을 가져와서 쓸 것임

-이를 위해 벡터 클래스가 필요함
-js폴더에 Vector.js파일을 하나 만들기

-다른 라이브러리의 형식과 거의 유사하게 참조해서 우리가 사용하는 메서드만 가져와서 만들었다고 생각하면 될 것임
-이 안에다가도 클래스 기본 세팅하기
:export default class Vector{
    constructor(){
        
    }
}

-컨스트럭터 안에는 x, y만 바깥에서 받아와서 this.x,y에 저장하고 들어오는 값이 없을 때엔 0을 저장하도록 하기
:     constructor(x, y){
        this.x = x || 0;
        this.y = y || 0;
    }

-그러고나서 add()메서드를 static키워드를 붙인 것과 안 붙인 2가지 버전으로 나눠서 만들기
: static add(){

    }
    add(){
        
    }
->이러면 바깥에서 사용할 때 우리가 App.dpr App.interval, App.width와 App.height를 사용하듯이, Vector.add를 쓰면 이 스태틱 에드를 사용하게 되고, 바깥에서 뉴 벡터로 인스턴스를 만들고 그 인스턴스.add를 쓰면 아래쪽의 일반 add를 사용하게 됨!
(스태틱 키워드 공부하고 올 것)


-static으로 해서 Vector.add를 이용하면, 기존에 만들어진 인스턴스 쓰는 게 아니므로, 바깥에서 벡터1과 벡터2를 인자로 받아서 리턴으로 뉴 벡터 해서 새 인스턴스를 만들어주면 됨
-이 새 인스턴스에는 2개 인자가 필요한데, v1.x + v2.x를 x인자로, v1.y + v2.y를 y인자로 써주면 됨
: static add(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x + v2.x, v1.y + v2.y);
    }

-그리고 그냥 add메서드에서는 스태틱과는 다르게 이미 선언된 인스턴스의 x,y값을 변경해줘야하는것이니까, 인자를 x,y를 받아주면 됨
: add(x, y){

    }
-근데 다른 라이브러리들 보면 보통 인자를 1개만 받을 때와, 인자를 2개 받을 때로 나눠서 만드니까 우리도 그렇게 함!
: add(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){

        }
    }
-1개만 받는다고 x값만 받는 게 아니라, x가 아닌 다른 벡터 인스턴스를 인자로 준다는 뜻으로 이해하면 됨
->그래서 이때는 인자로 받은 x를 다른 인스턴스라고 보고 .x를 또 써주면 됨
:         if(arguments.length === 1){
            this.x += x.x;
            this.y += x.y;
        }

-인자를 2개 받는 경우는 원래 우리가 의도한것처럼 인자로 x,y값을 주는 경우임
:        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x += x;
            this.y += y;
        }


-따라서 이렇게 기본적으로 js에서 제공해주는 arguments와 length를 이용해서 메서드에 넘겨주는 인자의 갯수로 경우의수를 나눌 수 있음!

-그리고 마지막으로 return this로 더해진 벡터 인스턴스를 바로 사용할 수 있도록 리턴해주기


-그리고 이제 빼기 1을 뜻하는 sub 이라는 이름으로 스태틱메서드와 그냥 메서드를 만들어주기
-add와의 차이점은 +를 -로 바꿔주는것밖에 없으니까 복붙해서 바꿔주기
:static sub(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x - v2.x, v1.y - v2.y);
    }
sub(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            // x,y값이 아닌, 다른 Vector 인스턴스를 인자로 주는 경우
            this.x -= x.x;
            this.y -= x.y;
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x -= x;
            this.y -= y;
        }

        return this;
    }

-다음에는 일반 메서드로 멀티플라이의 약자인 mult로 곱하기 메서드를 만들기
-얘 스태틱 안 만드는 이유는 우리가 여기서는 얘 스태틱 안 쓸 것이기 때문!


-마찬가지로 멀티메서드도 들어오는 인자가 인스턴스일 수도 있고 x,y일수도 있으니까 경우의수를 나눠서 코드 짜기
-인자로 받은 x,y에 같은값을 가지는 v를 곱해주는 거라서, 길이로 판단하는게 아니라...이번에는 typeof를 사용해서 들어오는 인자의 타입으로 경우의수를 따질 것임
-들어오는 타입이 넘버면 x,y가 들어오는 것이고 아니라면 벡터로 인식하도록 하면 됨
:mult(v){
        // 들어오는 인자의 타입이 숫자인 경우
        if(typeof v === "number"){
            this.x *= v;
            this.y *= v;
        }
        // 아닌 경우 = Vector 인스턴스가 들어오는 경우
        else{
            this.x *= v.x;
            this.y *= v.y;
        }
        return this;
    }



-다음으로 setXY()를 만들기 이거는 벡터 인스턴스의 x,y값을 들어오는 인자의 x,y값으로 바로 세팅하는 역할을 함
:     setXY(x, y){
        this.x = x;
        this.y = y;

        return this;
    }


-마지막으로 distance의 약자인 dist()메서드로, 한 벡터 인스턴스로부터 다른 벡터와의 떨어진 거리값을 리턴해주는 것임
-보통 두 점 사이의 거리는 피타고라스 정의로 구할 수 있음....ㅠㅋㅋㅋ
-두 점이 있을때, 두점의 x를 dx라 하고 y를 dy라하고, 서로간의 거리는 dx의 제곱 + dy의 제곱을 루트 씌운것임......ㅎ
-따라서 dx는 this.x에서 받아온 인자.x이고, dy는 this.y에서 받아온 인자.y를 뺀 것임
-그리고 리턴할 때 dx에다 dx를 곱해서 제곱을 만들고 dy도 제곱을 만든 이 두개의 값을 더하고 Math.sqrt()로 루트를 씌워주면 됨
:     dist(v){
        const dx = this.x - v.x;
        const dy = this.y - v.y;

        return Math.sqrt(dx*dx + dy*dy);
    }


-물리 라이브러리에서 사용하는 벡터.js는 이것보다 훨씬 더 많은 메서드가 있지만 우선 간단하게 원리 이해하고 여기서 활용하는 것만 만들어봄!

-이제 우리가 만든 벡터가 잘 돌아가는지 테스트해보자


-index.js로 가서 한번 테스트해볼 것인데 따라하지 않아도 무방!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-index.js로 가서 맨 아래에다가 const v1으로 뉴 벡터로 인스턴스를 만드는데 100, 100으로 만들기
-그리고 그 아래에 v2에다가 벡터 하나 더 만들어주는데 50, 50으로 만들어주기
: const v1 = new Vector(100, 100);
const v2 = new Vector(50, 50);
console.log(v1);

->콘솔창에 x,y 좌표를 가진 벡터 인스턴스가 잘 찍힘!
->이제 여기에 바로 .add()로 v2를 인자로 넣어주면!
: console.log(v1.add(v2));
->>콘솔창 보면 "Vector {x: 150, y: 150}"라고 해서 두 값이 잘 더해진 것 확인됨!

->이번에는 콘솔에다가 v1에다가 .sub(v2)를 해주면
: console.log(v1.sub(v2));
->>다시 100,100이 잘 찍힘!
->>v1의 인스턴스값에다 윗줄에서 50을 더해주고, 아랫줄에서 다시 50을 뺴주니까 원래값인 100,100이 나오는 것임

->>그리고 argument를 하나 넣으면 벡터로 인식하고, 2개 넣으면 x,y로 인식하는지 확인하기 위해서 sub인자에다가 v2.x, v2,y라고 넣어주면
: console.log(v1.sub(v2.x, v2.y));
->>>똑같이 100, 100이 나오는것 확인됨!!


-이번엔 일반 메서드가 아니라 static을 사용해보기 위해서, const v3을 만들고 여기에다가 Vector.add()로 v1, v2를 넣어보기
: const v3 = Vector.add(v1, v2);
console.log(v3);
->이러면 150, 150을 좌표로 가지는, 새로운 인스턴스를 리턴해줘서 v3 변수에 담은 것이 콘솔에 잘 찍힘!!

-이제 곱하기 테스트!
: console.log(v3.mult(2));
->>Vector {x: 300, y: 300}라고 뜸!

-이번엔 벡터를 인자로 넣고 테스트
: console.log(v3.mult(v1));
->>Vector {x: 15000, y: 15000}
->>잘 나오는것 확인됨!!!!!

-이제 마지막으로 dist 메서드 테스트!
-v1과 v2사이의 거리 테스트해보기
: console.log(v1.dist(v2));
->>> "70.71067811865476"나옴!
->>> 100,100에서 50, 50사이의 거리인 약 70이 나오게됨!

-이렇게 벡터 클래스 만들고 스태틱 메서드와 일반 메서드를 각각 정의해서 x, y값을 테스트해봤음!


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




[ Dot 클래서 마저 만들기 ]
-백터 클래스를 활용해서 Dot클래스를 본격적으로 만들기
-기존 파티클 시스템을 구성할 때에는 this.x, y를 다이렉트로 사용했고, 덧셈 뺄셈과 같은 연산은 모두 수기로 작성하거나 util.js 파일안에서 만들고 export로 꺼내와서 사용하는 것처럼 작업했음
-이제 이렇게 벡터 클래스를 만들어서 쓰면! x,y값을 벡터에서 관리하면서 기타 연산 메서드를 쉽게 이용할 수 있다는 장점이 있음


-이제 index.js에서 테스트 했던거 다 지워버리기


-이제 Dot 클래스의 컨스트럭터에서 this.x,y정의했던거 지워주기
-이제 여기서 this.pos 선언하고 Vector인스턴스 불러오고 그 인자로 x,y넣어주기
:     constructor(x, y){
        // 벡터 인스턴스 불러와서 this.pos 정의
        this.pos = new Vector(x, y);
...
}


-속도를 구하기 위해서 oldPos라고 이전 위치변수를 정의하기
:         // 속도 구하기 위해 oldPos 정의
        this.oldPos = new Vector(x, y);

->이전에 파티클 프로젝트 만들 떄 속도를 구할때... 속도는 5, 3, 1과 같이 직접 숫자를 넣었음
-그러면 캔버스에서 "5"라고 하면....예를 들어 m/s라고 하면 1초에 이동한 거리를 m단위로 나타낸것임
-캔버스에서 속도 개념을 나타낸다면, App.js에서 render()메서드 안의 frame()함수가 1번 돌아가는 동안 이동한 거리를 속도라고 표현했었음
->즉 캔버스에서 "속도=5"라고 한다면, 한번의 프레임동안 5px만큼 이동했다는 뜻임!

-이번에는 Dot클래스의 update()메서드 안에서 속도를 vel이라고 해서 this.pos와 this.oldPos의 차이값을 가진 벡터 인스턴스라고 정의할 것임!
:     update(){
        // 속도
        let vel = Vector.sub(this.pos, this.oldPos);
    }
-즉, 이전 프레임에서의 위치(올드포스)에서 이번 프레임에서의 위치(포스) 사이의 거리가 속도를 나타낼 수 있기 때문임



-왜 이번 플젝에서는 이렇게 표현하나???
->>나중에 하나의 점이 속도가 0인데 같은 직선으로 연결된 다른 점이 속도를 가지게 되면 속도가 0인 점에도 영향을 받기 위해서는 이전위치와 현재 위치와의 차이값으로 속도를 나타내야하기 때문임!


-이제 draw()메서드 안에서 점을 그려볼것임
-이번 플젝에서는 ctx가 스태틱이 아니라 this.ctx로 앱 안에 정의되어 있기 때문에 드로우의 인자로 ctx를 밖에서 불러와야함
-그리고 ctx.fillStyle로 점의 색상을 검정색으로 해주고
-beginPath()로 그리기 시작하겠다고 선언하고
-ctx.arc()로 호를 그려줘야함
-x는 this.x가 아니라 this.pos.x이고, 마찬가지로 this.y가 아니라 this.pos.y로 해줘야함
-반지름은 10정도로 하고 호는 0부터 Math.PI * 2로 360으로 해줘서 원으로 만들어주기
-그리고 ctx.fill()로 안의 색을 채워서 점을 그려주기
-그리고 마지막으로 ctx.closePath()로 비긴패스로 열어둔 것을 닫아주기
:     draw(ctx){
        // 점 그리기
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }


-이렇게 우선 작업해두고, App.js로 돌아가서 컨스트럭터 안의 맨 하단에, this.dots = [];를 배열로 선언하고 그 안에서 뉴 닷으로 인스턴스를 생성하기
:     constructor(){
...
        // 점 생성
        this.dots = [new Dot()];
    }
-그리고 인자로 400, 50을 넣기
: this.dots = [new Dot(400, 50)];


-그리고 맨 하단의 frame()함수 안에서 clearRect()의 아래쪽에서 forEach()돌면서 dots배열의 각 점들을 update(), draw() 시켜주기
: render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            
            then = now - (delta % App.interval);
            
            this.ctx.clearRect(0, 0, App.width, App.height);
            ///////////////////////////////////////////////////

            // 테스트용 사각형 그리기
            // this.ctx.fillRect(100, 100, 100, 100);

            // 점 관련
            this.dots.forEach(dot => {
                dot.update();
                dot.draw(this.ctx);
            });
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }

-이렇게 하면 화면에 400, 50의 위치에 점이 하나 그려짐!
-지금은 점이 고정되어 있지만.. 이제 속도를 사용하면 점이 움직일 수 있음!

-이제 우리는 속도가 현재 위치에서 이전 프레임의 위치를 뺀 값이라고 했으니까, 컨스트럭터에서 처음에 초기화 시킬 때 둘의 값을 x,y로 똑같이 초기화해서 지금은 두개의 x,y값이 동일함
-이제 update()메서드에서 다르게 작업해주면됨

-vel변수 아래에다가 this.oldPos를 setXY로 this.pos.x, this.pos.y로 값을 대입하기
:     update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);
    }
-> 현재 프레임이 실행될 때 새로운 속도를 현재 포지션에 계산하기 전에, 값을 setXY로 이전 위치값에 대입해주면 말 그대로 이전위치가 됨

-이 아래쪽에서 속도.x에 0.1씩을 매 프레임마다 더해주면 어떻게 되는지 테스트해보자
-그리고 this.pos.add(vel)을 아랫줄에다가 써서, 변경된 속도값을 현재 위치에 더해주면...!
:         vel.x += 0.1;
        this.pos.add(vel);
->>그럼 점이 오른쪽으로 움직이는데 속도가 점점 빨라지는거 확인됨

-콘솔로 한번 찍어보면... 매 프레임마다 0.1씩 계속 더해져서 점점 빨라져서...가속도가 붙어서 빨리 오른쪽으로 사라지게 되는 것임

-이번엔 속도를 0.5를 주고 y로 테스트해보기
(frame함수의 clearRect()를 잠시 주석처리해서 이전의 그림이 남아있게 만들어두기)
:         vel.y += 0.5;
        this.pos.add(vel);
->이러면 점이 찍히는 모습이 다 남아있는데 아래로 갈수록 거리가 벌어져서 가속도가 붙는 걸 알 수있음


-이전에 파티클에서는 중력을 이렇게 표현했었음!
-이게 매초 또는 매 프레임마다 속도에 중력값을 더해주니까 아래로 빠르게 떨어지는 것임
-여기서는 이제 중력을 "1"이라고 상수값을 직접 더해주지 않고, 중력도 벡터클래스를 활용할것임!

-먼저 Dot의 컨스트럭터 안에서 gravity를 정의하기
: this.gravity = new Vector(0, 1);

-그리고 update()에서 vel.y + 1을 vel.add(this.gravity)로 바꿔주기
:     update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        this.pos.add(vel);
    }
->이전처럼 똑같이 동작하지만 좀더 변수화되어서 깔끔해짐


--이전에 파티클 시스템에서 우리가 마찰력도 대입했던 것을..이번에도 마찰력 구현할것임
-실제로 물리적으로 하늘에서 공을 떨굴때 하늘 높은 곳에서 떨어트리면 속도가 점점 빨라질것임
-계속 무한히 빨라지지않음! 왜냐면 공기 마찰력때문임
-그래서 어느정도 속도에 도달하면 마찰려과 중력이 상쇄되서 일정한 속도를 가지고 아래로 떨어지게됨

-이걸 파티클시스템에서 활용해서 컨페티나 불꽃놀이같은 걸 만들었었음
-이번에는 벡터를 활용해서 좀더 자세히 이해해보자!


-이제 콘솔창에서중력 더한 시점에서 vel를 확인해보면 y방향으로 1프레임당 1씩 속도가 무한히 커지는 걸 확인할 수 있음
: vel.add(this.gravity);
        console.log(vel);
        this.pos.add(vel);


-이제 Dot클래스의 컨스트럭터 안에서 friction 변수를 만들고 0.97정도의 값으로 초기화해주기
: this.friction = 0.97;

-여기에 중력값을 더하기 전에 마찰력을 먼저 현재 속도에 곱해주기
: update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);

        // 속도에 마찰력 곱하여 마찰력 부여하기
        vel.mult(this.friction);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        // console.log(vel);
        this.pos.add(vel);
    }

-그리고 콘솔 주석 해제해서 결과 확인해보면, 속도가 33.33...과 같은 어떤 시점에서 유지되는 것을 알 수 있음!

-이렇게 3d 물리 시스템을 속도, 중력, 마찰을 이용하여 2d에서 구현하는 것임!




[ stick 클래스 만들기 ]
-중력과 마찰력을 가지고 자유낙하하는 공을 만등렀으니, 이번에는 이 공을 서로 연결해주는 스틱 클래스 만들기로 함

-js폴더 안에 stick.js 파일을 만들고 클래스를 세팅하기
:export default class Stick{
  constructor(){

  }
  update(){

  }
  draw(){
    
  }
}


-dot클래스에서 x, y를 인자로 필요했다면, 스틱은?
-점 두개임! 이 두개를 서로 연결해야하니까!

-p1, p2라는 인자를 받아와서 시작점, 끝점 변수를 만들고 저장하기
:   constructor(p1, p2){
    this.startPoint = p1;
    this.endPoint = p2;
  }


-draw()메서드에서 바깥에서 ctx를 받아와서 그려주는데, 먼저 비긴패스로 패스를 그리겠따고 선언하기
-그리고 strokesStyle로 선의 색상 정하고, lineWidth로 선 두께도 지정하기
:   draw(ctx){
    // 스틱 그리기
    ctx.beginPath();
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 10;
}

-그리고 무브투로 스틱 그리기 위한 위치로 이동해주는데, 먼저 스타트포인트.pos.x, 스타트포인트.pos.y로 이동해주면됨
-그리고 lineto()로 앤드포인트의 위치로 가서 패스 그리기
:     // 스틱 그릴 위치로 이동
    ctx.moveTo(this.startPoint.pos.x, this.startPoint.pos.y);
    // 스틱 연결할 위치로 이동
    ctx.lineTo(this.endPoint.pos.x, this.endPoint.pos.y);


-그리고 이제 선으로 연결해서 그리기
-그리고 패스 닫아서 p1과 p2를 잇는 선분 그림!
:     ctx.stroke();
    ctx.closePath();


-이제 선분 하나 그리는 메서드가 완성됨

->>동작하는지 확인 위해 App.js로 가서 컨스트럭터에서 this.dots안에서 점을 하나 더 그려주기
: this.dots = [new Dot(400, 50), new Dot(500, 100)];


-그리고 이 점들을 잇는 선분을 생성하기 위해서 아랫줄에 sticks라는 인스턴스를 모아둘 배열 선언하고, 스틱 인스턴스 생성하기
:         this.sticks = [new Stick(this.dots[0], this.dots[1])];


-이렇게 한 다음 프레임함수 안에서 dots아래쪽에서 스틱 배열을 forEach 돌면서 각 스틱 인스턴스를 업데이트, 드로우 시켜주기!
:             // 선 관련
            this.sticks.forEach(stick => {
                stick.update();
                stick.draw(this.ctx);
            });

-이제 결과 확인해보면 두개가 연결되어있음!!
-점 두개는 똑같이 중력 받아서 아래로 떨어져서..잘 안보임;;;
-그러니까 이제 점 하나를 화면에 고정시켜볼 것임

-Dot.js로 가서, 컨스트럭터에서 this.pinned라는 변수를 만들고 false로 초기화해놓기
: this.pinned = false;

-그리고 업데이트 메서드 영역의 최상단에서, if문으로 조건을 걸면 됨
-this.pinned가 true면 리턴돼서 아래쪽에 있는 속도 관련 코드 읽지 않게끔!
:     update(){
        // 만약 dot이 고정되어 있다면 움직이지 않게 하기
        if(this.pinned) return;
        
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);
...
}


->속도도 없고 중력과 마찰력이 적용되지 않도록 하는 것임!

-이제 앱.js로 돌아와서 컨스트럭터 하단에서 첫번째 점을 핀으로 고정시켜보기
: this.dots[0].pinned = true;

->이러면 스타트점이 화면에 고정되고, 끝점은 계속 하강하기 때문에 이를 연결해둔 선분도 무한하게 길어지고 있음

-이때 스틱.js에서 update메서드 안에서 거리를 일정하게 유지해주는 로직을 짜서 이 두 점 사이의 거리를 처음 선언한 그 거리를 유지하도록 해주기


-먼저 로직 작성하기 전에, 잠깐 원리 설명 듣기,,,

<원리 설명>
점 두개 사이에 스틱이 연결되어 있는 상태
그리고 시작점은 고정되어 있는 상태임
두번째 프레임이 그려젔을 때에는 업데이트 안에 아무것도 작성되지 않은 상태라면, 끝점만 아래로 떨어지게 되는데... 무한히 길어지게 됨

-근데 우리는 스틱 클래스가 원래의 길이로 되돌아가려는 성질을 가지고 있어야, 업데이트돼도 계속 원래의 길이를 유지하게 됨
-원래 오리지널 길이를...랭스의 줄임말인 l로 지칭하고, 실제로 늘어나거나 줄어드는 길이를 dist라고 지칭해보자
-늘어나거나 줄어드는 dist의 거리는... 시작점과 끝점 사이의 거리값이라 생각하면 됨
-이 dist의 거리를 알고리즘을 적용시켜서 원래의 거리로 돌아가게 해줘야함

-이 dist에서 l을 뺀 차이값을 a라고 해보자
-이 실제로 늘어난 길이와 원래 오리지날 거리의 차이값인 오차 a를 통해서 원래 길이로 돌려주면 됨

-이 알고리즘의 핵심은 "늘어난 차이만큼 매 프레임마다 반 잘라서 시작점에 반 더해주고, 끝점에는 반을 빼주면"됨
= 늘어났을 때에는 늘어난 만큼 반씩 잘라주고, 줄어들었을 때에는 작아진 만큼 반씩 잘라주면 됨

-이걸 1프레임마다 반복하면 원래 길이에 일치하진 않아도 무한히 원래의 값에 가까워지게 되는 원리임

-이해를 돕기 위해 늘어났을 때만 생각했지만 줄어드는 경우도 똑같은 원리 적용하면 됨



-이 오차값 a를 어떻게 이해해서 구해서 반 잘라 나눠주면 될까...ㅎ
-두 점을 이어서 빗변삼각형??을 만들어서 계산해보면 된대 ㅎ...



....

-dx는 끝점.x에서 시작점.x를 뺀게 dx가됨
-dy는 끝점.y에서 시작점.y를 뺀게 dy임
-....
-사인과 코사인 이용하면 됨....ㅎ

-dist-L분의 ay가 코사인 세타값이됨
-사인세타는 dist-L분의 ax가 사인 세타값이 됨

-이걸 이용하면 ax값 구할 수 있음

-코사인 세타값이 알고보면 dist분의 dy랑 동일함!
->>따라서 이 두 비례식을 통해서 ay를 구할 수 있음

->>>dist-L분의 ay = dist분의 dy
->>>이 값이 코사인 세타값이됨!!

👉dist-L값을 오른쪽으로 보내면 ay값을 구할 수 있게 됨

-ax도 마찬가지로 사인세타를 이용해서 비례식으로 구하면됨
->>>dist-L분의 ax = dist분으 ㅣdx
👉dist-l값을 오른쪽에 보내면 ax를 구할 수 있게뙴



-이렇게 나온 ax, ay값을 반 잘라서 끝점에서는 그값을 빼고, 시작점에서는 그걸 더해주면... 원래의 길이에 무한하게 가까워지게됨!

-우선.... l을 먼저 구해야함
-l은 스틱 클래스 생성할때 p1과 p2를 인자로 받느 ㄴ컨스트럭터에서 두 점사이의 오리지날 거리를 구할 수 있고
-dx,dy는 업데이트 함수가 매프레임마다 실행될때 두 점좌표의 차이값으로 구할 수 있음
-그리고 dist는 dx,dy를 이용해서 피타고라스의 정의로 구하면 됨




-코드로 돌아와서... 우선 l 구하기
-스틱 클래스의 컨스트럭터 안에다가 this.length = 시작점.pos.dist()로, 우리가 벡터클래스의 메서드로 두 점사이의 거리를 리턴해주는 메서드를 만들어둔걸이용해서.. 인자로 dist.끝점.pos를 넣어서 원래의 길이 구하기
:     this.length = this.startPoint.pos.dist(this.endPoint.pos);


-그리고 이제 업데이트 메서드 안에서, dx,dy구하기
-dist로 구할 수있음!
-먼저 dx는 끝점.pos.x에서 시작점pos.x를 뺴주면 됨
-마찬가지로 dy는 끝점.y 에서 시작점.y를 빼주기
: const dx = this.endPoint.pos.x - this.startPoint.pos.x;
const dy = this.endPoint.pos.y - this.startPoint.pos.y;


-그리고 dist 선언하고 거기서 피타고라스의 정의로 구하기
:   update(){
    const dx = this.endPoint.pos.x - this.startPoint.pos.x;
    const dy = this.endPoint.pos.y - this.startPoint.pos.y;

    // 피타고라스 정의로 원래 길이 구하기
    const dist = Math.sqrt(dx*dx + dy*dy);
  }


-이제 ax, ay구하기 위한 요소들 다 구했음
-이제 ax를 offsetX라는 이름으로 정해서 아까 생각해둔 비례식을 이용해서 구하기
: const offsetX = (dist - this.length) / dist * dx;
const offsetY = (dist - this.length) / dist * dy;

-이제 이렇게 하면되는데 "(dist - this.length) / dist"요만큼이 중복됨
-중복 줄이기 위해서....diff라는 변수 만들고 거기에 저장해서 쓰기
:   update(){
    const dx = this.endPoint.pos.x - this.startPoint.pos.x;
    const dy = this.endPoint.pos.y - this.startPoint.pos.y;

    // 피타고라스 정의로 원래 길이 구하기
    const dist = Math.sqrt(dx*dx + dy*dy);

    // 늘어난 길이의 x, y구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx;
    const offsetY = diff * dy;
  }


-이제 또 시작점.x에 늘어난 길이의 절반만큼 더해주고
-y에도 늘어난 길이의 절반만큼을 더해주면 됨
:     this.startPoint.pos.x += offsetX * 0.5;
    this.startPoint.pos.y += offsetY * 0.5;

-이제 끝점에는 반대로 빼주기
:     this.endPoint.pos.x -= offsetX * 0.5;
    this.endPoint.pos.y -= offsetY * 0.5;


->>이러고 확인해보면....먼가 이상하게;; 시작점 고정해놨는데;; 고정이 풀려버림..
->>그래서 시작점, 끝점의 좌표값에 변동을 주는 코드 윗줄에서 if문으로 시작점이 고정되지 않은 경우에만 좌표값에 변동이 가도록 하기
:     // 시작점이 고정되지 않은 경우에만 적용하기
    if(!this.startPoint.pinned){
      // 시작점의 x,y 좌표에 늘어난 길이의 절반만큼 더해주기
      this.startPoint.pos.x += offsetX * 0.5;
      this.startPoint.pos.y += offsetY * 0.5;
    }
-마찬가지로 끝점도 고정되지 않은 경우에만 변동이 가도록 하기!
:     // 끝점이 고정되지 않은 경우에만 적용하기
    if(!this.endPoint.pinned){
      // 끝점의 x, y 좌표에 늘어난 길이의 절반만큼 빼주기
      this.endPoint.pos.x -= offsetX * 0.5;
      this.endPoint.pos.y -= offsetY * 0.5;
    }



->>이렇게 하면! 스틱이 늘어나지 않고 원래의 길이로 돌아가려는 성질 때문에 끝점이 계속 아래로 늘어지는 게 아니라 시작점과의 거리를 계속 유지하고 있는 모습을 볼 수 있음!!!


-이제 App.js로 돌아가서 점을 좀 늘려서 테스트해보기
-컨스트럭터 안에다가 600,50 위치에 점을 하나 더 추가해보기
:         this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50)];
->그러면 혼자 생긴 점이 바닥으로 떨어지게됨

-그러면 이제 스틱 배열에서 두번째와 세번째 점을 잇는 스틱을 하나 더 만들어보기
:         // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2])
        ];


->이러면 두번째 점에 3번째 점이 선으로 연결되는 것 확인됨!!

-이번엔 800,0위치에 점을 하나 더 만들고 3번째와 4번째 공을 잇는 스틱도 만들어보기
:         // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50), new Dot(800, 0)];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2]),
            new Stick(this.dots[2], this.dots[3]),
        ];


->그러면 이렇게 공들이 서로 유기적으로 영향 주고받으며 연결되어있고, 매 프레임마다 모두 원래의 길이로 돌아가기 위해서 계속 노력하는 스틱이 만들어짐!!



-이제 또 우리가 고려해야하는 개념이 또있음. 바로 "무게"임...
-만약 공들이 같은 무게를 가지고 있지 않고... 예를 들어 시작점은 1을갖고, 끝점은 3의 무게를 가지고 있으면...!!
-우리가 공평하게 ax,ay값을 반씩 잘라서 시작점 끝점에 똑같이 분배했던게..이제 무게가 차이나니까 분배를 다르게 시켜줘야함!!!
-즉, 3의 무게를 가지고 있는 쪽이 더 무거우니까 4분의 1만큼만 되돌아가면 되고, 1의 무게를 가지고 있는 쪽이 훨씬 더 가벼우니까 4분의 3만큼 무거운쪽으로 이동해야 한다!

-여기서도 규칙이 보이는데... 시작점은 1과 3을 더한 무게에서, 3만큼 오른쪽으로 이동하고/끝점은 1과3을 더한 무게에서 1만큼만 왼쪽으로 이동하면됨!!!


-끝점에 있는 점은 이전에는 오프셋의 절반만큼 곱하기 0.5만해서 왼쪽으로 이동했었는데, 이번에는 스타트 포인트와 엔드포인트의 무게를 더한것 분의 스타트 포인트의 무게를 곱해준 만큼만 왼쪽으로 이동하면 됨

-스타트 포인트에 있는 공은 오른쪽으로, 오프셋에서 스타트포인트의 무게와 엔드포인트의 무게를 더한 것분의엔드포인트의무게를 곱해준것 만큼만 오른쪽으로이동시켜주면됨



-이제 스타트 클래스의 업데이트 메서드 안에 있는 오프셋 정의한 부분 바로 아래쪽에서....
m이란 변수 만들고... 거기서 시작점.mass  + 끝점.mass라고 정의하고
-m1은 끝점의 mass / m,
m2는 시작점의 mss / m
-이라고 정의해주기
: // 늘어난 길이의 x, y 차이 구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx;
    const offsetY = diff * dy;

    // 무게에 따른 차이 구하기
    const m = this.startPoint.mass + this.endPoint.mass;
    const m1 = this.endPoint.mass / m;
    const m2 = this.startPoint.mass / m;


-이제 0.5를 곱해준 부분들을... 스타트포인트쪽에는 m1을 곱해주고, 끝점은 m2를 곱해주면됨!
:     // 시작점이 고정되지 않은 경우에만 적용하기
    if(!this.startPoint.pinned){
      // 시작점의 x,y 좌표에 늘어난 길이의 절반만큼 더해주기
      this.startPoint.pos.x += offsetX * m1;
      this.startPoint.pos.y += offsetY * m1;
    }

    // 끝점이 고정되지 않은 경우에만 적용하기
    if(!this.endPoint.pinned){
      // 끝점의 x, y 좌표에 늘어난 길이의 절반만큼 빼주기
      this.endPoint.pos.x -= offsetX * m2;
      this.endPoint.pos.y -= offsetY * m2;
    }



📌업데이트 함수 전체
:   update(){
    const dx = this.endPoint.pos.x - this.startPoint.pos.x;
    const dy = this.endPoint.pos.y - this.startPoint.pos.y;

    // 피타고라스 정의로 원래 길이 구하기
    const dist = Math.sqrt(dx*dx + dy*dy);

    // 늘어난 길이의 x, y 차이 구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx;
    const offsetY = diff * dy;

    // 무게에 따른 차이 구하기
    const m = this.startPoint.mass + this.endPoint.mass;
    const m1 = this.endPoint.mass / m;
    const m2 = this.startPoint.mass / m;

    // 시작점이 고정되지 않은 경우에만 적용하기
    if(!this.startPoint.pinned){
      // 시작점의 x,y 좌표에 늘어난 길이의 절반만큼 더해주기
      this.startPoint.pos.x += offsetX * m1;
      this.startPoint.pos.y += offsetY * m1;
    }

    // 끝점이 고정되지 않은 경우에만 적용하기
    if(!this.endPoint.pinned){
      // 끝점의 x, y 좌표에 늘어난 길이의 절반만큼 빼주기
      this.endPoint.pos.x -= offsetX * m2;
      this.endPoint.pos.y -= offsetY * m2;
    }
  }


-이렇게하면 식이 완성됨
-근데 우리가 mass설정 안해둬서.. 에러난것임

-이제 Dot.js의 컨스트럭터 안에다가 mass를 1로 기본적으로 초기화해주기
:         this.mass = 1;


->우리가 따로 무게를 만져준 곳 없으니까..모두 같은 무게를 갖고 있어서 결과적으로는 반반 나뉘게 되니까 아까 해둔거랑 똑같은 결고 ㅏ나옴


-무게에 따른 변화를 알아보기 위해서 우선 점을 0번과 1번만 남기고 전부 다 지우기
:         this.dots = [new Dot(400, 50), new Dot(500, 100)];
-스틱도 한개만 남기기
:         this.sticks = [new Stick(this.dots[0], this.dots[1])];

-이제 점을 100,50과 200,100위치를 추가하고
-스틱도 1,2번쨰 연결하기
:         // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(100, 50), new Dot(200, 100)];

        // 선 생성
        this.sticks = [new Stick(this.dots[0], this.dots[1]), new Stick(this.dots[2], this.dots[3])];


-그리고 인덱스2번 점도 핀으로 고정해두기
:         this.dots[2].pinned = true;



->현재 둘다 똑같이 나옴

-이제 dots[1]의 무게를 10을 줘보기
:         // 테스트 : 무게 추가
        this.dots[1].mass = 10;

->> 비슷해보이니까 '텐션'개념을 추가해서 무게감 부여하기



-Stick.js의 컨스트럭터에다 tension = 1로 초기화하기
:     this.tension = 1;

-이 텐션을 업데이트 메서드에서 offsetx,y에 각각 곱해주기
:     // 늘어난 길이의 x, y 차이 구하기
    const diff = (dist - this.length) / dist;
    const offsetX = diff * dx * this.tension;
    const offsetY = diff * dy * this.tension;


-이 텐션은 오프셋,,오차값을 되돌려줘야하는데... 원래 곱하기 1을 한게 기본 텐션으로 되돌려주는 것이지만 만약 텐션을 0.05로 바꾸면.... 원래대로 돌아가야할 값을 20분의 1만큼만 되돌려주기 때문에 텐션이 느슨하게 되는 것임
:    this.tension = 0.05; // 탄성이 줄어서 무거울수록 늘어짐

-그리고 일정 시간이 지나면 중력과 상쇄되면서 완전히 원래 값으로는 되돌아가지 못하도록 하는 것임
-또한 무게가 더 무거운 쪽에서는 길이가 더 늘어져서, 진짜 무게가 있는 공처럼 물리 표현이 됨




-이제 다시 App.js로 가서 점 4개를 만들고 스틱으로 주루룩 연결해보면!
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));

        // 점 생성
        this.dots = [new Dot(400, 50), new Dot(500, 100), new Dot(600, 50), new Dot(800, 0)];

        // 선 생성
        this.sticks = [
            new Stick(this.dots[0], this.dots[1]),
            new Stick(this.dots[1], this.dots[2]),
            new Stick(this.dots[2], this.dots[3]),
        ];

        // 점을 고정해두기
        this.dots[0].pinned = true;
    }

->>그러면 스프링처럼 탄성이 생기며 원래의 길이로 돌아가려고 함





-설명 이해 잘 안되면 다시 돌려보면 이해될거야~^^....





