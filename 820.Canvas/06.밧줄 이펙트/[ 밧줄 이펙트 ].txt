[밧줄 이펙트]
-현업에서는 물리알고리즘을 모아서 쉽게 사용가능하도록 만들어둔 라이브러리를 활용하겠지만, 이번 강의에서는 직접 물리알고리즘을 이해하고, 구현하는데 목적이 있음
-물리 알고리즘이 어떻게 돌아가는지 이해하기!

-x,y좌표에 대한 값 이해하기

-stick클래스가 이번 강의에서 포인트임!



<기초 뼈대 구성하기>
-style.css파일 만들고 헤드 태그에서 link로 불러오기
-canvas태그 넣기
-스크립트 태그 만들기

-styel.css에서는 html, body의 기본 마진,패딩 없애기
: @charset "utf-8";

html, body{
    margin: 0;
    padding: 0;
}


-그리고 index.js에 바로 코딩하지 말고, App.js를 만들고 거기서 작성한다음 index.js에 불러올것임
-그 이유는 index.js는 밧줄말고도 다른 웹 구성요소들이 모이는 곳이기 때문에 실전처럼 다른 곳에 빼두는 것임!
-내게 맞는 보일러플레이트를 만들어서 정착하면 됨

-js폴더 만들고 App.js파일 만들고 기초 구성하기
:export default class App{
    constructor(){

    }
    resize(){

    }
    render(){
        
    }
}

-그리고 컨스트럭터 작성하기 전에, 상단에 스태틱으로, 상수로 사용되는 변수들을 미리 작성해두기
: static width = innerWidth;
    static height =  innerHeight;
    static dpr = devicePixelRatio > 1 ? 2 : 1;
    static interval = 1000 / 60;
-전체 화면의 픽셀값들 미리 정해두기
-dpr도 1보다 크면 2, 아니면1로 해두기
-인터벌도 60fps로 동작하게끔 1000분의 60으로 해두기

-그리고 이제 컨스트럭터에서 캔버스불러오기
-그리고 ctx 변수를 2d로 만들어두기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");
    }
-이전에는 이 두개도 스태틱으로 해서 사용했었는데, 매번 스태틱으로 getContext로 객체를 만드는 것보다, 이렇게 컨스트럭터에서 써주면, 한번만 변수에 저장해두면 더 편할 수 있음


-이제 리사이즈 메서드에서 App.width와 height를 리사이즈될떄마다 변경되는 전체 화면의 가로, 세로 길이를 다시 스태틱으로 저장해주기
:     resize(){
        // 리사이즈 될 때마다 화면의 가로, 세로값 다시 지정
        App.width = innerWidth;
        App.height = innerHeight;
}
-이 값을 통해서 캔버스 css 가로세로값과 실제 캔버스의 가로세로값을 적용해주면 됨
: // 캔버스 CSS 스타일 지정
        this.canvas.style.width = App.width + 'px';
        this.canvas.style.height = App.height + 'px';

-캔버스의 사이즈를 앱의 가로/세로값에 * dpr곱해주는 이유는, dpr이 1 이상일 때 2로 통일시켜주는것임
-그 이유는 고유 캔버스 사이즈가 커질수록 .. 예를 들어 이미지 파일이 고해상도일 경우, 파일 용량이 커지는것처럼, 캔버스에서 그리는데에 영향을 끼칠 수있기 때문임!

- 캔버스 사이즈도 지정해주기
: // 캔버스 사이즈 지정
        this.canvas.width = App.width * App.dpr;
        this.canvas.height = App.height * App.dpr;


- 그리고 이제 ctx의 스케일에 dpr을 각각 곱해줘서 선명도를 높여주고, 또 낮은 dpr과 높은 dpr에서 모두 같은 모습으로 볼 수 있도록 해주기
: this.ctx.scale(App.dpr, App.dpr);


-이제 컨스트럭터에서 리사이즈 메서드를 호출해서 최초 한번 실행하도록 하고, 리사이즈 이벤트가 발생할때마다 리사이즈 함수를 실행하도록 해주기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));
    }

->근데 이렇게만 하면, 리사이즈 메서드가 실행될 때 안에서 선언된 this가 윈도우라고 인식하기 때문에 bind(this)를 추가로 메서드체인해줘서 this값을 앱으로 인식할수 있도록 함



-그리고 렌더로 넘어가서, let으로 now, delta선언하고 then = Date.now()로 현재 시간 담아주기
:     render(){
        let now, delta;
        let then = Date.now();
}
-frame()함수를 만들고, 그 안에서 리퀘스트애니메이션프레임함수에서 프레임함수를 다시 호출해서, 재귀함수로 스스로 기기의 모니터 주사율마다 프레임이 실행될수있도록 함
:         const frame = ()=>{
            requestAnimationFrame(frame);
}
=>즉 모두 같은 속도로 캔버스를 그리게 하기 위함

-그리고 아랫쪽에서 코드짜기
: now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
-델타는 나우와 덴값의 차이로, 델타가 인터벌보다 작으면 리턴을 시켜서 모니터 주사율인 60헤르쯔를 기준으로 캔버스가 애니메이션되도록 해줌

-그리고 나우에서 델타를 인터벌로 나눈 나머지값을 뺀 값을 다시 덴에 넣어주기
: then = now - (delta % App.interval);

-그리고 그 아래쪽에서 clearRect()를해서, 전체화면을 프레임마다 지우는 과정을 해주기
: this.ctx.clearRect(0, 0, App.width, App.height);

-그러고나서 우선 테스트용으로 정사각형 하나 그려서 잘 동작하는지 확인하기
: this.ctx.fillRect(100, 100, 100, 100);



-이제 이 프레임을 실행해야하니까 바로 아랫줄에서 리퀘스트애니메이션프레임으로 프레임함수 실행되도록 하기
:     render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            ///////////////////////////////////////////////////
            
            ///////////////////////////////////////////////////
            then = now - (delta % App.interval);

            this.ctx.clearRect(0, 0, App.width, App.height);

            // 테스트용 사각형 그리기
            this.ctx.fillRect(100, 100, 100, 100);
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }


-그리고 이제 다시 index.js로 돌아가서 로드이벤트로 모든게 로드되었을 때 앱 인스턴스를 생성해서 저장한 app변수를 만들고, 이 앱을 렌더함수로 실행시켜주기
: window.addEventListener("load", ()=>{
    const app = new App();
    app.render();
});






[ 닷 클래스 만들기 ]

-x,y좌표에 점을 찍고 이게 서로 스틱으로 연결되고 서로 영향을 주고 상호작용하게 만들 것임

-이제 기본적인 점을 만들어줄 것임
- js폴더에 Dot.js파일 만들고 기본 세팅하기
: 
export default class Dot{
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}


-닷은 말그대로 한 점을 말함! 그래서 필요한 인자는 딱 2개임 x,y좌표!
-이걸 this.x, this.y 선언하고 넣을건데 이번에는 this.x, this.y라고 하지 않고! 물리 라이브러리에서 하는 것처럼 "벡터"개념을 가져와서 쓸 것임

-이를 위해 벡터 클래스가 필요함
-js폴더에 Vector.js파일을 하나 만들기

-다른 라이브러리의 형식과 거의 유사하게 참조해서 우리가 사용하는 메서드만 가져와서 만들었다고 생각하면 될 것임
-이 안에다가도 클래스 기본 세팅하기
:export default class Vector{
    constructor(){
        
    }
}

-컨스트럭터 안에는 x, y만 바깥에서 받아와서 this.x,y에 저장하고 들어오는 값이 없을 때엔 0을 저장하도록 하기
:     constructor(x, y){
        this.x = x || 0;
        this.y = y || 0;
    }

-그러고나서 add()메서드를 static키워드를 붙인 것과 안 붙인 2가지 버전으로 나눠서 만들기
: static add(){

    }
    add(){
        
    }
->이러면 바깥에서 사용할 때 우리가 App.dpr App.interval, App.width와 App.height를 사용하듯이, Vector.add를 쓰면 이 스태틱 에드를 사용하게 되고, 바깥에서 뉴 벡터로 인스턴스를 만들고 그 인스턴스.add를 쓰면 아래쪽의 일반 add를 사용하게 됨!
(스태틱 키워드 공부하고 올 것)


-static으로 해서 Vector.add를 이용하면, 기존에 만들어진 인스턴스 쓰는 게 아니므로, 바깥에서 벡터1과 벡터2를 인자로 받아서 리턴으로 뉴 벡터 해서 새 인스턴스를 만들어주면 됨
-이 새 인스턴스에는 2개 인자가 필요한데, v1.x + v2.x를 x인자로, v1.y + v2.y를 y인자로 써주면 됨
: static add(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x + v2.x, v1.y + v2.y);
    }

-그리고 그냥 add메서드에서는 스태틱과는 다르게 이미 선언된 인스턴스의 x,y값을 변경해줘야하는것이니까, 인자를 x,y를 받아주면 됨
: add(x, y){

    }
-근데 다른 라이브러리들 보면 보통 인자를 1개만 받을 때와, 인자를 2개 받을 때로 나눠서 만드니까 우리도 그렇게 함!
: add(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){

        }
    }
-1개만 받는다고 x값만 받는 게 아니라, x가 아닌 다른 벡터 인스턴스를 인자로 준다는 뜻으로 이해하면 됨
->그래서 이때는 인자로 받은 x를 다른 인스턴스라고 보고 .x를 또 써주면 됨
:         if(arguments.length === 1){
            this.x += x.x;
            this.y += x.y;
        }

-인자를 2개 받는 경우는 원래 우리가 의도한것처럼 인자로 x,y값을 주는 경우임
:        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x += x;
            this.y += y;
        }


-따라서 이렇게 기본적으로 js에서 제공해주는 arguments와 length를 이용해서 메서드에 넘겨주는 인자의 갯수로 경우의수를 나눌 수 있음!

-그리고 마지막으로 return this로 더해진 벡터 인스턴스를 바로 사용할 수 있도록 리턴해주기


-그리고 이제 빼기 1을 뜻하는 sub 이라는 이름으로 스태틱메서드와 그냥 메서드를 만들어주기
-add와의 차이점은 +를 -로 바꿔주는것밖에 없으니까 복붙해서 바꿔주기
:static sub(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x - v2.x, v1.y - v2.y);
    }
sub(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            // x,y값이 아닌, 다른 Vector 인스턴스를 인자로 주는 경우
            this.x -= x.x;
            this.y -= x.y;
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x -= x;
            this.y -= y;
        }

        return this;
    }

-다음에는 일반 메서드로 멀티플라이의 약자인 mult로 곱하기 메서드를 만들기
-얘 스태틱 안 만드는 이유는 우리가 여기서는 얘 스태틱 안 쓸 것이기 때문!


-마찬가지로 멀티메서드도 들어오는 인자가 인스턴스일 수도 있고 x,y일수도 있으니까 경우의수를 나눠서 코드 짜기
-인자로 받은 x,y에 같은값을 가지는 v를 곱해주는 거라서, 길이로 판단하는게 아니라...이번에는 typeof를 사용해서 들어오는 인자의 타입으로 경우의수를 따질 것임
-들어오는 타입이 넘버면 x,y가 들어오는 것이고 아니라면 벡터로 인식하도록 하면 됨
:mult(v){
        // 들어오는 인자의 타입이 숫자인 경우
        if(typeof v === "number"){
            this.x *= v;
            this.y *= v;
        }
        // 아닌 경우 = Vector 인스턴스가 들어오는 경우
        else{
            this.x *= v.x;
            this.y *= v.y;
        }
        return this;
    }



-다음으로 setXY()를 만들기 이거는 벡터 인스턴스의 x,y값을 들어오는 인자의 x,y값으로 바로 세팅하는 역할을 함
:     setXY(x, y){
        this.x = x;
        this.y = y;

        return this;
    }


-마지막으로 distance의 약자인 dist()메서드로, 한 벡터 인스턴스로부터 다른 벡터와의 떨어진 거리값을 리턴해주는 것임
-보통 두 점 사이의 거리는 피타고라스 정의로 구할 수 있음....ㅠㅋㅋㅋ
-두 점이 있을때, 두점의 x를 dx라 하고 y를 dy라하고, 서로간의 거리는 dx의 제곱 + dy의 제곱을 루트 씌운것임......ㅎ
-따라서 dx는 this.x에서 받아온 인자.x이고, dy는 this.y에서 받아온 인자.y를 뺀 것임
-그리고 리턴할 때 dx에다 dx를 곱해서 제곱을 만들고 dy도 제곱을 만든 이 두개의 값을 더하고 Math.sqrt()로 루트를 씌워주면 됨
:     dist(v){
        const dx = this.x - v.x;
        const dy = this.y - v.y;

        return Math.sqrt(dx*dx + dy*dy);
    }


-물리 라이브러리에서 사용하는 벡터.js는 이것보다 훨씬 더 많은 메서드가 있지만 우선 간단하게 원리 이해하고 여기서 활용하는 것만 만들어봄!

-이제 우리가 만든 벡터가 잘 돌아가는지 테스트해보자


-index.js로 가서 한번 테스트해볼 것인데 따라하지 않아도 무방!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-index.js로 가서 맨 아래에다가 const v1으로 뉴 벡터로 인스턴스를 만드는데 100, 100으로 만들기
-그리고 그 아래에 v2에다가 벡터 하나 더 만들어주는데 50, 50으로 만들어주기
: const v1 = new Vector(100, 100);
const v2 = new Vector(50, 50);
console.log(v1);

->콘솔창에 x,y 좌표를 가진 벡터 인스턴스가 잘 찍힘!
->이제 여기에 바로 .add()로 v2를 인자로 넣어주면!
: console.log(v1.add(v2));
->>콘솔창 보면 "Vector {x: 150, y: 150}"라고 해서 두 값이 잘 더해진 것 확인됨!

->이번에는 콘솔에다가 v1에다가 .sub(v2)를 해주면
: console.log(v1.sub(v2));
->>다시 100,100이 잘 찍힘!
->>v1의 인스턴스값에다 윗줄에서 50을 더해주고, 아랫줄에서 다시 50을 뺴주니까 원래값인 100,100이 나오는 것임

->>그리고 argument를 하나 넣으면 벡터로 인식하고, 2개 넣으면 x,y로 인식하는지 확인하기 위해서 sub인자에다가 v2.x, v2,y라고 넣어주면
: console.log(v1.sub(v2.x, v2.y));
->>>똑같이 100, 100이 나오는것 확인됨!!


-이번엔 일반 메서드가 아니라 static을 사용해보기 위해서, const v3을 만들고 여기에다가 Vector.add()로 v1, v2를 넣어보기
: const v3 = Vector.add(v1, v2);
console.log(v3);
->이러면 150, 150을 좌표로 가지는, 새로운 인스턴스를 리턴해줘서 v3 변수에 담은 것이 콘솔에 잘 찍힘!!

-이제 곱하기 테스트!
: console.log(v3.mult(2));
->>Vector {x: 300, y: 300}라고 뜸!

-이번엔 벡터를 인자로 넣고 테스트
: console.log(v3.mult(v1));
->>Vector {x: 15000, y: 15000}
->>잘 나오는것 확인됨!!!!!

-이제 마지막으로 dist 메서드 테스트!
-v1과 v2사이의 거리 테스트해보기
: console.log(v1.dist(v2));
->>> "70.71067811865476"나옴!
->>> 100,100에서 50, 50사이의 거리인 약 70이 나오게됨!

-이렇게 벡터 클래스 만들고 스태틱 메서드와 일반 메서드를 각각 정의해서 x, y값을 테스트해봤음!


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~














