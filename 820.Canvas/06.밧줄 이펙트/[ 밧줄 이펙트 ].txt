[밧줄 이펙트]
-현업에서는 물리알고리즘을 모아서 쉽게 사용가능하도록 만들어둔 라이브러리를 활용하겠지만, 이번 강의에서는 직접 물리알고리즘을 이해하고, 구현하는데 목적이 있음
-물리 알고리즘이 어떻게 돌아가는지 이해하기!

-x,y좌표에 대한 값 이해하기

-stick클래스가 이번 강의에서 포인트임!



<기초 뼈대 구성하기>
-style.css파일 만들고 헤드 태그에서 link로 불러오기
-canvas태그 넣기
-스크립트 태그 만들기

-styel.css에서는 html, body의 기본 마진,패딩 없애기
: @charset "utf-8";

html, body{
    margin: 0;
    padding: 0;
}


-그리고 index.js에 바로 코딩하지 말고, App.js를 만들고 거기서 작성한다음 index.js에 불러올것임
-그 이유는 index.js는 밧줄말고도 다른 웹 구성요소들이 모이는 곳이기 때문에 실전처럼 다른 곳에 빼두는 것임!
-내게 맞는 보일러플레이트를 만들어서 정착하면 됨

-js폴더 만들고 App.js파일 만들고 기초 구성하기
:export default class App{
    constructor(){

    }
    resize(){

    }
    render(){
        
    }
}

-그리고 컨스트럭터 작성하기 전에, 상단에 스태틱으로, 상수로 사용되는 변수들을 미리 작성해두기
: static width = innerWidth;
    static height =  innerHeight;
    static dpr = devicePixelRatio > 1 ? 2 : 1;
    static interval = 1000 / 60;
-전체 화면의 픽셀값들 미리 정해두기
-dpr도 1보다 크면 2, 아니면1로 해두기
-인터벌도 60fps로 동작하게끔 1000분의 60으로 해두기

-그리고 이제 컨스트럭터에서 캔버스불러오기
-그리고 ctx 변수를 2d로 만들어두기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");
    }
-이전에는 이 두개도 스태틱으로 해서 사용했었는데, 매번 스태틱으로 getContext로 객체를 만드는 것보다, 이렇게 컨스트럭터에서 써주면, 한번만 변수에 저장해두면 더 편할 수 있음


-이제 리사이즈 메서드에서 App.width와 height를 리사이즈될떄마다 변경되는 전체 화면의 가로, 세로 길이를 다시 스태틱으로 저장해주기
:     resize(){
        // 리사이즈 될 때마다 화면의 가로, 세로값 다시 지정
        App.width = innerWidth;
        App.height = innerHeight;
}
-이 값을 통해서 캔버스 css 가로세로값과 실제 캔버스의 가로세로값을 적용해주면 됨
: // 캔버스 CSS 스타일 지정
        this.canvas.style.width = App.width + 'px';
        this.canvas.style.height = App.height + 'px';

-캔버스의 사이즈를 앱의 가로/세로값에 * dpr곱해주는 이유는, dpr이 1 이상일 때 2로 통일시켜주는것임
-그 이유는 고유 캔버스 사이즈가 커질수록 .. 예를 들어 이미지 파일이 고해상도일 경우, 파일 용량이 커지는것처럼, 캔버스에서 그리는데에 영향을 끼칠 수있기 때문임!

- 캔버스 사이즈도 지정해주기
: // 캔버스 사이즈 지정
        this.canvas.width = App.width * App.dpr;
        this.canvas.height = App.height * App.dpr;


- 그리고 이제 ctx의 스케일에 dpr을 각각 곱해줘서 선명도를 높여주고, 또 낮은 dpr과 높은 dpr에서 모두 같은 모습으로 볼 수 있도록 해주기
: this.ctx.scale(App.dpr, App.dpr);


-이제 컨스트럭터에서 리사이즈 메서드를 호출해서 최초 한번 실행하도록 하고, 리사이즈 이벤트가 발생할때마다 리사이즈 함수를 실행하도록 해주기
:     constructor(){
        // 캔버스 불러오기
        this.canvas = document.querySelector("canvas");
        this.ctx = this.canvas.getContext("2d");

        // 실행
        this.resize();
        // 윈도우 리사이즈시
        window.addEventListener("resize", this.resize.bind(this));
    }

->근데 이렇게만 하면, 리사이즈 메서드가 실행될 때 안에서 선언된 this가 윈도우라고 인식하기 때문에 bind(this)를 추가로 메서드체인해줘서 this값을 앱으로 인식할수 있도록 함



-그리고 렌더로 넘어가서, let으로 now, delta선언하고 then = Date.now()로 현재 시간 담아주기
:     render(){
        let now, delta;
        let then = Date.now();
}
-frame()함수를 만들고, 그 안에서 리퀘스트애니메이션프레임함수에서 프레임함수를 다시 호출해서, 재귀함수로 스스로 기기의 모니터 주사율마다 프레임이 실행될수있도록 함
:         const frame = ()=>{
            requestAnimationFrame(frame);
}
=>즉 모두 같은 속도로 캔버스를 그리게 하기 위함

-그리고 아랫쪽에서 코드짜기
: now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
-델타는 나우와 덴값의 차이로, 델타가 인터벌보다 작으면 리턴을 시켜서 모니터 주사율인 60헤르쯔를 기준으로 캔버스가 애니메이션되도록 해줌

-그리고 나우에서 델타를 인터벌로 나눈 나머지값을 뺀 값을 다시 덴에 넣어주기
: then = now - (delta % App.interval);

-그리고 그 아래쪽에서 clearRect()를해서, 전체화면을 프레임마다 지우는 과정을 해주기
: this.ctx.clearRect(0, 0, App.width, App.height);

-그러고나서 우선 테스트용으로 정사각형 하나 그려서 잘 동작하는지 확인하기
: this.ctx.fillRect(100, 100, 100, 100);



-이제 이 프레임을 실행해야하니까 바로 아랫줄에서 리퀘스트애니메이션프레임으로 프레임함수 실행되도록 하기
:     render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            ///////////////////////////////////////////////////
            
            ///////////////////////////////////////////////////
            then = now - (delta % App.interval);

            this.ctx.clearRect(0, 0, App.width, App.height);

            // 테스트용 사각형 그리기
            this.ctx.fillRect(100, 100, 100, 100);
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }


-그리고 이제 다시 index.js로 돌아가서 로드이벤트로 모든게 로드되었을 때 앱 인스턴스를 생성해서 저장한 app변수를 만들고, 이 앱을 렌더함수로 실행시켜주기
: window.addEventListener("load", ()=>{
    const app = new App();
    app.render();
});






[ 닷 클래스 만들기 ]

-x,y좌표에 점을 찍고 이게 서로 스틱으로 연결되고 서로 영향을 주고 상호작용하게 만들 것임

-이제 기본적인 점을 만들어줄 것임
- js폴더에 Dot.js파일 만들고 기본 세팅하기
: 
export default class Dot{
    constructor(){

    }
    update(){

    }
    draw(){
        
    }
}


-닷은 말그대로 한 점을 말함! 그래서 필요한 인자는 딱 2개임 x,y좌표!
-이걸 this.x, this.y 선언하고 넣을건데 이번에는 this.x, this.y라고 하지 않고! 물리 라이브러리에서 하는 것처럼 "벡터"개념을 가져와서 쓸 것임

-이를 위해 벡터 클래스가 필요함
-js폴더에 Vector.js파일을 하나 만들기

-다른 라이브러리의 형식과 거의 유사하게 참조해서 우리가 사용하는 메서드만 가져와서 만들었다고 생각하면 될 것임
-이 안에다가도 클래스 기본 세팅하기
:export default class Vector{
    constructor(){
        
    }
}

-컨스트럭터 안에는 x, y만 바깥에서 받아와서 this.x,y에 저장하고 들어오는 값이 없을 때엔 0을 저장하도록 하기
:     constructor(x, y){
        this.x = x || 0;
        this.y = y || 0;
    }

-그러고나서 add()메서드를 static키워드를 붙인 것과 안 붙인 2가지 버전으로 나눠서 만들기
: static add(){

    }
    add(){
        
    }
->이러면 바깥에서 사용할 때 우리가 App.dpr App.interval, App.width와 App.height를 사용하듯이, Vector.add를 쓰면 이 스태틱 에드를 사용하게 되고, 바깥에서 뉴 벡터로 인스턴스를 만들고 그 인스턴스.add를 쓰면 아래쪽의 일반 add를 사용하게 됨!
(스태틱 키워드 공부하고 올 것)


-static으로 해서 Vector.add를 이용하면, 기존에 만들어진 인스턴스 쓰는 게 아니므로, 바깥에서 벡터1과 벡터2를 인자로 받아서 리턴으로 뉴 벡터 해서 새 인스턴스를 만들어주면 됨
-이 새 인스턴스에는 2개 인자가 필요한데, v1.x + v2.x를 x인자로, v1.y + v2.y를 y인자로 써주면 됨
: static add(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x + v2.x, v1.y + v2.y);
    }

-그리고 그냥 add메서드에서는 스태틱과는 다르게 이미 선언된 인스턴스의 x,y값을 변경해줘야하는것이니까, 인자를 x,y를 받아주면 됨
: add(x, y){

    }
-근데 다른 라이브러리들 보면 보통 인자를 1개만 받을 때와, 인자를 2개 받을 때로 나눠서 만드니까 우리도 그렇게 함!
: add(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){

        }
    }
-1개만 받는다고 x값만 받는 게 아니라, x가 아닌 다른 벡터 인스턴스를 인자로 준다는 뜻으로 이해하면 됨
->그래서 이때는 인자로 받은 x를 다른 인스턴스라고 보고 .x를 또 써주면 됨
:         if(arguments.length === 1){
            this.x += x.x;
            this.y += x.y;
        }

-인자를 2개 받는 경우는 원래 우리가 의도한것처럼 인자로 x,y값을 주는 경우임
:        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x += x;
            this.y += y;
        }


-따라서 이렇게 기본적으로 js에서 제공해주는 arguments와 length를 이용해서 메서드에 넘겨주는 인자의 갯수로 경우의수를 나눌 수 있음!

-그리고 마지막으로 return this로 더해진 벡터 인스턴스를 바로 사용할 수 있도록 리턴해주기


-그리고 이제 빼기 1을 뜻하는 sub 이라는 이름으로 스태틱메서드와 그냥 메서드를 만들어주기
-add와의 차이점은 +를 -로 바꿔주는것밖에 없으니까 복붙해서 바꿔주기
:static sub(v1, v2){
        // Vector 인스턴스 생성해서 리턴해주기
        return new Vector(v1.x - v2.x, v1.y - v2.y);
    }
sub(x, y){
        // 인자를 1개만 받을 경우
        if(arguments.length === 1){
            // x,y값이 아닌, 다른 Vector 인스턴스를 인자로 주는 경우
            this.x -= x.x;
            this.y -= x.y;
        }
        // 인자를 2개 받을 경우
        else if(arguments.length === 2){
            // x,y값을 인자로 주는 경우임
            this.x -= x;
            this.y -= y;
        }

        return this;
    }

-다음에는 일반 메서드로 멀티플라이의 약자인 mult로 곱하기 메서드를 만들기
-얘 스태틱 안 만드는 이유는 우리가 여기서는 얘 스태틱 안 쓸 것이기 때문!


-마찬가지로 멀티메서드도 들어오는 인자가 인스턴스일 수도 있고 x,y일수도 있으니까 경우의수를 나눠서 코드 짜기
-인자로 받은 x,y에 같은값을 가지는 v를 곱해주는 거라서, 길이로 판단하는게 아니라...이번에는 typeof를 사용해서 들어오는 인자의 타입으로 경우의수를 따질 것임
-들어오는 타입이 넘버면 x,y가 들어오는 것이고 아니라면 벡터로 인식하도록 하면 됨
:mult(v){
        // 들어오는 인자의 타입이 숫자인 경우
        if(typeof v === "number"){
            this.x *= v;
            this.y *= v;
        }
        // 아닌 경우 = Vector 인스턴스가 들어오는 경우
        else{
            this.x *= v.x;
            this.y *= v.y;
        }
        return this;
    }



-다음으로 setXY()를 만들기 이거는 벡터 인스턴스의 x,y값을 들어오는 인자의 x,y값으로 바로 세팅하는 역할을 함
:     setXY(x, y){
        this.x = x;
        this.y = y;

        return this;
    }


-마지막으로 distance의 약자인 dist()메서드로, 한 벡터 인스턴스로부터 다른 벡터와의 떨어진 거리값을 리턴해주는 것임
-보통 두 점 사이의 거리는 피타고라스 정의로 구할 수 있음....ㅠㅋㅋㅋ
-두 점이 있을때, 두점의 x를 dx라 하고 y를 dy라하고, 서로간의 거리는 dx의 제곱 + dy의 제곱을 루트 씌운것임......ㅎ
-따라서 dx는 this.x에서 받아온 인자.x이고, dy는 this.y에서 받아온 인자.y를 뺀 것임
-그리고 리턴할 때 dx에다 dx를 곱해서 제곱을 만들고 dy도 제곱을 만든 이 두개의 값을 더하고 Math.sqrt()로 루트를 씌워주면 됨
:     dist(v){
        const dx = this.x - v.x;
        const dy = this.y - v.y;

        return Math.sqrt(dx*dx + dy*dy);
    }


-물리 라이브러리에서 사용하는 벡터.js는 이것보다 훨씬 더 많은 메서드가 있지만 우선 간단하게 원리 이해하고 여기서 활용하는 것만 만들어봄!

-이제 우리가 만든 벡터가 잘 돌아가는지 테스트해보자


-index.js로 가서 한번 테스트해볼 것인데 따라하지 않아도 무방!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-index.js로 가서 맨 아래에다가 const v1으로 뉴 벡터로 인스턴스를 만드는데 100, 100으로 만들기
-그리고 그 아래에 v2에다가 벡터 하나 더 만들어주는데 50, 50으로 만들어주기
: const v1 = new Vector(100, 100);
const v2 = new Vector(50, 50);
console.log(v1);

->콘솔창에 x,y 좌표를 가진 벡터 인스턴스가 잘 찍힘!
->이제 여기에 바로 .add()로 v2를 인자로 넣어주면!
: console.log(v1.add(v2));
->>콘솔창 보면 "Vector {x: 150, y: 150}"라고 해서 두 값이 잘 더해진 것 확인됨!

->이번에는 콘솔에다가 v1에다가 .sub(v2)를 해주면
: console.log(v1.sub(v2));
->>다시 100,100이 잘 찍힘!
->>v1의 인스턴스값에다 윗줄에서 50을 더해주고, 아랫줄에서 다시 50을 뺴주니까 원래값인 100,100이 나오는 것임

->>그리고 argument를 하나 넣으면 벡터로 인식하고, 2개 넣으면 x,y로 인식하는지 확인하기 위해서 sub인자에다가 v2.x, v2,y라고 넣어주면
: console.log(v1.sub(v2.x, v2.y));
->>>똑같이 100, 100이 나오는것 확인됨!!


-이번엔 일반 메서드가 아니라 static을 사용해보기 위해서, const v3을 만들고 여기에다가 Vector.add()로 v1, v2를 넣어보기
: const v3 = Vector.add(v1, v2);
console.log(v3);
->이러면 150, 150을 좌표로 가지는, 새로운 인스턴스를 리턴해줘서 v3 변수에 담은 것이 콘솔에 잘 찍힘!!

-이제 곱하기 테스트!
: console.log(v3.mult(2));
->>Vector {x: 300, y: 300}라고 뜸!

-이번엔 벡터를 인자로 넣고 테스트
: console.log(v3.mult(v1));
->>Vector {x: 15000, y: 15000}
->>잘 나오는것 확인됨!!!!!

-이제 마지막으로 dist 메서드 테스트!
-v1과 v2사이의 거리 테스트해보기
: console.log(v1.dist(v2));
->>> "70.71067811865476"나옴!
->>> 100,100에서 50, 50사이의 거리인 약 70이 나오게됨!

-이렇게 벡터 클래스 만들고 스태틱 메서드와 일반 메서드를 각각 정의해서 x, y값을 테스트해봤음!


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




[ Dot 클래서 마저 만들기 ]
-백터 클래스를 활용해서 Dot클래스를 본격적으로 만들기
-기존 파티클 시스템을 구성할 때에는 this.x, y를 다이렉트로 사용했고, 덧셈 뺄셈과 같은 연산은 모두 수기로 작성하거나 util.js 파일안에서 만들고 export로 꺼내와서 사용하는 것처럼 작업했음
-이제 이렇게 벡터 클래스를 만들어서 쓰면! x,y값을 벡터에서 관리하면서 기타 연산 메서드를 쉽게 이용할 수 있다는 장점이 있음


-이제 index.js에서 테스트 했던거 다 지워버리기


-이제 Dot 클래스의 컨스트럭터에서 this.x,y정의했던거 지워주기
-이제 여기서 this.pos 선언하고 Vector인스턴스 불러오고 그 인자로 x,y넣어주기
:     constructor(x, y){
        // 벡터 인스턴스 불러와서 this.pos 정의
        this.pos = new Vector(x, y);
...
}


-속도를 구하기 위해서 oldPos라고 이전 위치변수를 정의하기
:         // 속도 구하기 위해 oldPos 정의
        this.oldPos = new Vector(x, y);

->이전에 파티클 프로젝트 만들 떄 속도를 구할때... 속도는 5, 3, 1과 같이 직접 숫자를 넣었음
-그러면 캔버스에서 "5"라고 하면....예를 들어 m/s라고 하면 1초에 이동한 거리를 m단위로 나타낸것임
-캔버스에서 속도 개념을 나타낸다면, App.js에서 render()메서드 안의 frame()함수가 1번 돌아가는 동안 이동한 거리를 속도라고 표현했었음
->즉 캔버스에서 "속도=5"라고 한다면, 한번의 프레임동안 5px만큼 이동했다는 뜻임!

-이번에는 Dot클래스의 update()메서드 안에서 속도를 vel이라고 해서 this.pos와 this.oldPos의 차이값을 가진 벡터 인스턴스라고 정의할 것임!
:     update(){
        // 속도
        let vel = Vector.sub(this.pos, this.oldPos);
    }
-즉, 이전 프레임에서의 위치(올드포스)에서 이번 프레임에서의 위치(포스) 사이의 거리가 속도를 나타낼 수 있기 때문임



-왜 이번 플젝에서는 이렇게 표현하나???
->>나중에 하나의 점이 속도가 0인데 같은 직선으로 연결된 다른 점이 속도를 가지게 되면 속도가 0인 점에도 영향을 받기 위해서는 이전위치와 현재 위치와의 차이값으로 속도를 나타내야하기 때문임!


-이제 draw()메서드 안에서 점을 그려볼것임
-이번 플젝에서는 ctx가 스태틱이 아니라 this.ctx로 앱 안에 정의되어 있기 때문에 드로우의 인자로 ctx를 밖에서 불러와야함
-그리고 ctx.fillStyle로 점의 색상을 검정색으로 해주고
-beginPath()로 그리기 시작하겠다고 선언하고
-ctx.arc()로 호를 그려줘야함
-x는 this.x가 아니라 this.pos.x이고, 마찬가지로 this.y가 아니라 this.pos.y로 해줘야함
-반지름은 10정도로 하고 호는 0부터 Math.PI * 2로 360으로 해줘서 원으로 만들어주기
-그리고 ctx.fill()로 안의 색을 채워서 점을 그려주기
-그리고 마지막으로 ctx.closePath()로 비긴패스로 열어둔 것을 닫아주기
:     draw(ctx){
        // 점 그리기
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }


-이렇게 우선 작업해두고, App.js로 돌아가서 컨스트럭터 안의 맨 하단에, this.dots = [];를 배열로 선언하고 그 안에서 뉴 닷으로 인스턴스를 생성하기
:     constructor(){
...
        // 점 생성
        this.dots = [new Dot()];
    }
-그리고 인자로 400, 50을 넣기
: this.dots = [new Dot(400, 50)];


-그리고 맨 하단의 frame()함수 안에서 clearRect()의 아래쪽에서 forEach()돌면서 dots배열의 각 점들을 update(), draw() 시켜주기
: render(){
        let now, delta;
        let then = Date.now();

        const frame = ()=>{
            requestAnimationFrame(frame);

            now = Date.now();
            delta = now - then;
            if(delta < App.interval) return;
            
            then = now - (delta % App.interval);
            
            this.ctx.clearRect(0, 0, App.width, App.height);
            ///////////////////////////////////////////////////

            // 테스트용 사각형 그리기
            // this.ctx.fillRect(100, 100, 100, 100);

            // 점 관련
            this.dots.forEach(dot => {
                dot.update();
                dot.draw(this.ctx);
            });
        };
        // 프레임 함수 실행
        requestAnimationFrame(frame);
    }

-이렇게 하면 화면에 400, 50의 위치에 점이 하나 그려짐!
-지금은 점이 고정되어 있지만.. 이제 속도를 사용하면 점이 움직일 수 있음!

-이제 우리는 속도가 현재 위치에서 이전 프레임의 위치를 뺀 값이라고 했으니까, 컨스트럭터에서 처음에 초기화 시킬 때 둘의 값을 x,y로 똑같이 초기화해서 지금은 두개의 x,y값이 동일함
-이제 update()메서드에서 다르게 작업해주면됨

-vel변수 아래에다가 this.oldPos를 setXY로 this.pos.x, this.pos.y로 값을 대입하기
:     update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);
    }
-> 현재 프레임이 실행될 때 새로운 속도를 현재 포지션에 계산하기 전에, 값을 setXY로 이전 위치값에 대입해주면 말 그대로 이전위치가 됨

-이 아래쪽에서 속도.x에 0.1씩을 매 프레임마다 더해주면 어떻게 되는지 테스트해보자
-그리고 this.pos.add(vel)을 아랫줄에다가 써서, 변경된 속도값을 현재 위치에 더해주면...!
:         vel.x += 0.1;
        this.pos.add(vel);
->>그럼 점이 오른쪽으로 움직이는데 속도가 점점 빨라지는거 확인됨

-콘솔로 한번 찍어보면... 매 프레임마다 0.1씩 계속 더해져서 점점 빨라져서...가속도가 붙어서 빨리 오른쪽으로 사라지게 되는 것임

-이번엔 속도를 0.5를 주고 y로 테스트해보기
(frame함수의 clearRect()를 잠시 주석처리해서 이전의 그림이 남아있게 만들어두기)
:         vel.y += 0.5;
        this.pos.add(vel);
->이러면 점이 찍히는 모습이 다 남아있는데 아래로 갈수록 거리가 벌어져서 가속도가 붙는 걸 알 수있음


-이전에 파티클에서는 중력을 이렇게 표현했었음!
-이게 매초 또는 매 프레임마다 속도에 중력값을 더해주니까 아래로 빠르게 떨어지는 것임
-여기서는 이제 중력을 "1"이라고 상수값을 직접 더해주지 않고, 중력도 벡터클래스를 활용할것임!

-먼저 Dot의 컨스트럭터 안에서 gravity를 정의하기
: this.gravity = new Vector(0, 1);

-그리고 update()에서 vel.y + 1을 vel.add(this.gravity)로 바꿔주기
:     update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        this.pos.add(vel);
    }
->이전처럼 똑같이 동작하지만 좀더 변수화되어서 깔끔해짐


--이전에 파티클 시스템에서 우리가 마찰력도 대입했던 것을..이번에도 마찰력 구현할것임
-실제로 물리적으로 하늘에서 공을 떨굴때 하늘 높은 곳에서 떨어트리면 속도가 점점 빨라질것임
-계속 무한히 빨라지지않음! 왜냐면 공기 마찰력때문임
-그래서 어느정도 속도에 도달하면 마찰려과 중력이 상쇄되서 일정한 속도를 가지고 아래로 떨어지게됨

-이걸 파티클시스템에서 활용해서 컨페티나 불꽃놀이같은 걸 만들었었음
-이번에는 벡터를 활용해서 좀더 자세히 이해해보자!


-이제 콘솔창에서중력 더한 시점에서 vel를 확인해보면 y방향으로 1프레임당 1씩 속도가 무한히 커지는 걸 확인할 수 있음
: vel.add(this.gravity);
        console.log(vel);
        this.pos.add(vel);


-이제 Dot클래스의 컨스트럭터 안에서 friction 변수를 만들고 0.97정도의 값으로 초기화해주기
: this.friction = 0.97;

-여기에 중력값을 더하기 전에 마찰력을 먼저 현재 속도에 곱해주기
: update(){
        // 속도 정의
        let vel = Vector.sub(this.pos, this.oldPos);

        this.oldPos.setXY(this.pos.x, this.pos.y);

        // 속도에 마찰력 곱하여 마찰력 부여하기
        vel.mult(this.friction);
        
        // 속도에 중력 더하여 가속도 붙이기
        vel.add(this.gravity);
        // console.log(vel);
        this.pos.add(vel);
    }

-그리고 콘솔 주석 해제해서 결과 확인해보면, 속도가 33.33...과 같은 어떤 시점에서 유지되는 것을 알 수 있음!

-이렇게 3d 물리 시스템을 속도, 중력, 마찰을 이용하여 2d에서 구현하는 것임!




