[ 불꽃 놀이 ]
1.보일러 플레이트의 두가지 방법
2.파티클과 폭죽의 기본 원리
3.파티클 원모양으로 만들업괴
4.불꽃놀이 꼬리 만들기
6.스파크 작업과 기타 꾸미기 작업


[ 보일러 플레이트의 두가지 방법 ]
-이번에는 모든 코드를 한번에 넣지 말고 각 파일로 클래스별로 나누어 작업하기로 함


가장먼저 해야할 것 : html에 만든 캔버스 요소 가져오기
그리고 캔버스 안에 있는 도구인 컨텍스트 를 써야하니까 가져오기

그리고 윈도우 전역 변수의 디바이스픽셀레이시오를 가져와서 dpr 설정하기


1.기본 세팅
// 02.불꽃놀이 - index.js

const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

const dpr = window.devicePixelRatio;

const fps = 60;
const interval = 1000 / fps;
let now, delta;
let then = Date.now();

// 캔버스 사이즈 미리 선언
let canvasWidth, canvasHeight;

// 초기화함수 만들기
function init(){
    // 캔버스 사이즈 담기
    canvasWidth = innerWidth;
    canvasHeight = innerHeight;

    // 캔버스 사이즈 담당하는 2가지 방법으로 사이즈 조절하기
    // 1.고유사이즈 지정하기
    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;
    ctx.scale(dpr, dpr);

    // 2.css로 강제로 늘리거나 줄이기
    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";
}


// animate 함수 만들기 : 이제 이걸 랜더라고 할 예정
function render(){
    // fps 개념 도입해서 모든 모니터에서 동일한 움직임 보이게 하기
    requestAnimationFrame(render);
    
    now = Date.now();
    delta = now - then;

    if(delta < interval) return;

    // 메인 로직 : 기본적인 fps 작업
    ctx.fillRect(100, 100, 200, 200);


    then = now - (delta % interval);
}



window.addEventListener("load", ()=>{
    init();
    render();
});

window.addEventListener("resize", ()=>{
    init();
});



2. 지금까지 작성한 보일러 플레이트를 각각 다른 파일로 만들어서 클래스로 만들어서 써볼 예정임
-스크래치로 빠르게 작업할 때 이 파일 필요할 수 있으니까 따로 파일로 만들어서 가지고 있기 추천함~!!


[ 보일러 플레이트 클래스로 만들기 ]
-먼저 class만들고 컨스트럭처 만들어서 그 안에 기본 고정값들 넣고 this세팅하기
-그리고 캔버스 사이즈 담아둔 변수도 가져와서 this세팅하기
:고정캔버스타겟사이즈 옮기기

-그리고 js파일 새로 만들고 그안에 옮기기 : 캔버스옵션.js

- 그리고 익스포트로 내보기

-그리고 캔버스 옵션 클래스를 부모 클래스로 상속받아온 캔버스 클래스를 만들기!
-자식 클래스의 constructor에서 super()를 쓰면 부모 클래스에서 정의한 변수, 메서드들을 this로 쉽게 가져다 쓸 수 있음

-그리고 이닛함수 그대로 복사해서 캔버스 클래스 안으로 옮겨주고 안으 ㅣ모든 값을 this처리하기

-그리고 랜더 함수도 그대로 가지고 들어오기

-그리고 상단에 가만 두었던 랜더 관련 변수들도 가지고 들어오기

-그리고 프레임 함수 만들어서 실행될 로직들 담고, render대신 프레임 넣기

-그리고 할당형 변수로 프레임 함수를 만들었기 때문에 아래쪽에서 최초 호출해주기

-이 정의한 클래스를 가지고 아래쪽에서 인스턴스 만들기





중복되는 필수 세팅을 보일러플레이트로 구성해서 기본 세팅하는 법 배움


[ 파티클과 폭죽의 기본원리 ]
-이제 파티클 만들기

1. 기본 세팅
-파티클.js파일을 만들고 기본 옵션 가져와서 써야하니까 상단에 임포트하기
-그리고 상속받아와서 파티클 클래스 만들기
-앞으로 파티클 다룰 때 기본적으로 사용할 메서드들인 업데이트, 드로우 함수 만들어두기

-주의할점은 상속받아오는 변수나 메서드 이런것들을 사용하기 위해서는 자식 클래스의 constructor에 super()를 써줘야 받아올 수 있음

-그리고 이 파티클 클래스도 꺼내서 다른 파일에서 써야 하므로 익스포트 시켜주기

-바깥에서 받아올 값인 x,y 인자로 쓰고 this.x,y로 좌표값 담아두기

-그리고 드로우 함수에서 그림 그리기
-원 그리는 기본 로직대로 짜기

-이제 캔버스 클래스의 컨스트럭터에서 여러 파티클들 만들어내서 담을 배열 만들기

-그리고 캔버스 클래스에서 파티클을 만들 메서드 만들기
그리고 파티클 개수 담을 변수 만들고 할당하고, 그 개수만큼 반복문 돌아서 new 해서 파티클 만들고 배열에다가 푸시로 담기!

-이 파티클 생성 함수를 이닛이 끝나면 젤 마지막에 실행되도록 아래에 적기!

-그럼 이제 this.파티클즈 배열 안에 1개가 들어갔으니까 1번만큼 그려지도록 랜더에서 그려지게 만들어ㅑㅇ함
-상자 그리는 코드 지우고 this.prticles를 forEach()문 돌아서 각 파티클을 업데이트, 드로우 함수 순서대로 실행시키기


[ 이제 파티클에 속도 붙여서 잘 움직이는지 확인하기 ]
-우선 만들어지고 그러고나서 움직이도록(?) 업데이트와 드로우를 따로 구분해두었으니까 이제 우리는 업데이트 함수에 가서 속도 붙일 것임
->이렇게만 하면 프레임 지우는 함수 넣지 않아서 계속 덮어 씌워져서 선이 그려짐;;

-이제 랜덤함수에 가서 리턴 밑에다가 캔버스 전체 지우는 클리어함수 넣을수 있지만..우리는 색상을 매 프레임 상단에 색칠해서 지우는 역할+배경색 역할하는 방식으로 하기로 함

-캔버스 배경 색도 옵션 클래스에 넣기

-그리고 랜더메서드로 돌아와서 프레임 함수 안에다가 리턴 아래쪽에서 클리어함수로 지워내고 만들고 지워내고 만들고 반복하는 방식으로 원을 떨어지는것 처럼 만드는 게 아니라
-계속 배경색을 덧칠해서 덮어씌우는 방식으로 원이 떨어지는 것처럼 만들기


-그리고 공 색도 잘보이게 바꾸기


-그리고 이제 파티클 만드는 곳으로 돌아가서 점을 랜덤 위치에 만들어 주도록 하기
-랜덤수 리턴하는 유틸성?함수가 있어야 함
-이제 랜덤수 만드는 함수 담을 파일 만들기

-거기에서 최소값, 최대값을 인자로 받아와서 그 사이에서 랜덤숫자를 리턴하는 함수 만들고 익스포트하기!

-그리고 파티클 만드는 함수에서 x값, y값을 랜덤수로 만들기



-이제 파티클 갯수 늘려서 여러개 만들기


-불꽃놀이를 만들려면..이제 파티클들이 한 점에서 동시에 시작해서 사방으로 퍼져야함
-그러면 x와 y가 처음 생성될때엔 같은 값으로 만들어졌다가 속도만 각각 다르게 만들면 됨

-우선 x,y를 for문 바깥으로 빼면 xy가 똑같아서 한 점에서 생성됨

-그리고 파티클 클래스의 컨스트럭터로 각각의 랜덤속도를 for문 안에서 생성해서 보내주면 됨


->10개라서 폭죽처럼 터지는 것 같지만,, 파티클을 2000개로 늘리면.... 폭죽이 원모양으로 퍼지는게 아니라 네모난 상자모양으로 퍼지게 됨

->또다른 문제! 공이 화면 밖으로 나가도 랜더 함수 안에서 보이지도 않는 2천개의 파티클에 애니메이션과 드로우를 계속 그려내고 있기 때문에, cpu에서 계속 돌아가므로 나중에 성능에 문제 될 수 있음

-그래서 이 파티클들을 없앨 것임

-퍼지기 전에 파티클들이 각각 투명도값을 가지고 있다가 파티클들이 퍼지면서 업데이트 로직이 실행될 때 투명도 값을 0으로 계속 감소시켜주다가 0이되면 파티클들배열에서 지워주면! 완전히 사라지게 됨!!

-우선 파티클 클래스에다 투명도 담을 변수 만들기
-처음에는 1로 초기화해주고 업데이트함수에서 투명도값을 점점 감소시킴

-그리고 현재 파티클 색상이 #fff로 되어 있으니까 이걸 rgba형식으로 바꿔주기
->이러면 이제 파티클들이 터지면서 투명하게 됨


-이제 배열에서 완전히 없애주기
-파티클들 배열에서 파티클을 각각 뽑아낸 후에 각 파티클을 업데이트하고 드로우 한 다음! 
-만약 어느 파티클이라도 투명도가 0보다 작아진다면 배열에서 빼낸다는 조건문을 걸기

-팁! 파티클들이 다 지워졌는지 확인하고 싶다면, 개발자도구에서 더보기>퍼포먼스 모니터에 들어가보면 CPU 사용량이 나옴
-계속 랜더하기 때문에 컴에 따라서 3퍼에서 5퍼가 기본으로 나올 것임
-만약 파티클 지우지 않은 상태라면 갑자기 cpu가 20퍼정도로 사용량이 늘어남



[ 폭죽 모양을 우리가 원하는 모양으로 만드는 법 ]
-폭죽 모양 제대로 구성하는 법

1.왜 폭죽이 사각형 모양으로 퍼젔을까?
-...그래프^^

2,동그란 모양으로 퍼지게 하는 원리
-vx,vy그래프에서 원 모양을 그릴 수 있다면...실제 x와 y값이 해당 값만큼 더해질테니까 퍼지는 것도 원 모양으로 퍼질 것임!
-그러면 우리는 반지름이 1인 원을 그리고 원의 라인을 따라서 점의 좌표를 알 수 있으면...문제 해결!

-원 둘레에 있는 점의 좌표는 반지름이 1이니까... 삼각형 그리면됨^^

-사인 코사인^^.....
-.......

-vx,vy값 구하기....
-랜덤 반지름 구하기
const r = randomNumBetween(0, 3);



[ 중력 적용하기 + 프릭션? 적용하기 ]
-아래로 떨어질 때 보다 자연스러워보임
-우주에서 불꽃놀이 하는것처럼 보이는게 아니라 속도가 0에 수렴하게 되면서 보다 자연스러워짐


-그럼 이제 파티클 클래스 안에서 중력값 변수에 담아서 만들어주고 업데이트 함수 위쪽에서 속도에다가 중력을 누적해서 더해주면 점점 아래로 빠르게 떨어짐

-또 마찰?을 부여해서 점점 느려지게 만들기

-index.js로 돌아와서 랜덤 r값이 0~3이라 원이 작게 만들어지니까 이제 값을 수정해서 크기 키움 -> 이때 0.2를 곱해주면 보다 중앙에서 뭉쳤다가 퍼지므로 보다 자연스러워짐

-그리고 모두 다같이 투명도가 같은 값으로 줄어드니까... 이제는 투명도도 랜덤으로 바뀌게 만들기
->그러면 이제 투명도를 다 똑같이 1부터 시작하는 게 아니라 랜덤값에서부터 시작하면 됨!

-파티클생성 함수로 가서 투명도도 랜덤으로 뽑아내서 만들게 하기


-그리고 이제 프레임함수로 돌아와서.. 계속 배경색을 덮어 씌우고 있는데 여기에 + '10'을 해주면 #000000 헥사코드 뒤에 + 10을 붙이게 되는 것이므로! rgba의 맨 마지막 값인 알파값(투명도)을 설정하게 되는 것임

-이렇게 하면 각 파티클이 매 프레임마다 움직이되 점차 잔상이 남는 형태로..만들어져서 폭죽처럼 됨 꼬리가 만들어지는 것처럼 됨

->즉, 투명도가 10밖에 안되니까 여러번 덧칠해야 완전한 검은색으로 덧칠해서 안보이게 만드는 것임!



-이제 또 한가지 문제! 작은 화면이나 큰 화면에서나 똑같은 사이즈!!
-화면크기 상관없이 비슷하게 만들어야 함

-만약 innerWidth를 써서 랜덤r을 구하게 되면... 화면 가로가 작아지거나 화면 가로가 클 때는 비슷한 사이즈 비율로 원을 만들 수 있어서 괜찮아보이지만
-세로 화면이 작아지면 그 문제 해결하지 못하고....
-innerHeight값을 써서 랜덤 r을 구하면 반대문제가 생김...

-따라서 우리는 피타고라스정의 통해서 빗변의 길이를 통해서...랜덤 반지름r을...구하도록 함^^...
-이걸 구하는 것은 유틸성 함수므로 그곳에다 만듬


[ 화면의 빗변 값을 구하는 함수 만들기 ]
-밑변과 높이를 받아와서 밑변의 제곱 더하기 높이의 제곱을 루트로 씌우면 됨!

-그리고 랜덤 r에다가 빗변구하는 함수를 곱하고 또 거기에 0.0001을 곱해주면 사이즈에 유동적으로 대응해서 적당한 크기의 폭죽이 만들어짐


[ 꼬리 만들기 ]
-



[ 꼬리 만들기 ]
-화면 밑에서부터 꼬리가 발사돼서 어느 지점에서 멈추면 그곳에서부터 폭죽 터지는 효과 만들기

1.tail.js 파일 만들고 클래스 테일 만들고 내보내기
-캔버스 옵션은 상속받기
-상단에 임포트도 해야함

2.꼬리에 들어가는 값
-보통 파티클에 x,y vx, vy를 넣지만 y는 아래에 고정해두고 꼬리가 하늘로 올라갈때는 vy값에 따라 바뀌기 때문에 x와 vy값만 적용하면 됨
-그리고 색이 다르게 만들것이라서 색도 받아오도록 함

3.그리고 업데이트함수와 드로우 함수 만들기
-업데이트 함수 안에는 현재 업데이트한 값이 y에 vy더해주는 것바께 없으니까 일단 이것만 적기

-드로우에서는 꼬리도 작은 원을 쏘아올리는 거싱라서 ctx로 원을 그리기

4.index.js에서 꼬리를 따로 관리하기 위해서 this.particles라는 배열처럼 빈 배열 일단 초기화해주기

5.크리에이트 테일 함수 만들기
-파티클 만들때처럼 똑같이 해주면 되는데 여기는 1불꽃놀이에 1꼬리니까 하나만 만들어주면 됨

-그리고 랜덤수 만들때 최대값을 화면의 가로값으로 한다면.. 화면사이즈가 500픽셀일때 최대값이 걸려서 500이 잡힌다면 맨 가에쪽이라서 꼬리 안보이고 잘릴 수 있음!
-그러니까 양 사이드에 딱 붙어서 생성되지는 않도록 적당히... 최대값을 줄여서 작성하면 되는데
-여기에서는... * 0.2 해서 20퍼센트를 줄이기로 함


6.프레임함수에서 발사하기

-하지만 아직 안나옴! 왜? 업데이트와 드로우를 아직 안해줘서!

-forEach()돌면서 배열에 담아둔 꼬리를 업데이트, 드로우 해주기

->근데 이러면 쉼없이 꼬리가 등장함...
-왜냐하면 프레임함수가 실행될떄마다 꼬리가 만들어지고 있기 대문임

->그래서 랜덤으로 크리에이트테일 실행하기 위해 제어문 검
- 랜덤값이 0.03보다 작으면 만들기로 함
-프레임 함수는 1초에 수십번 실행되기 떄문에 0.03이라는 값도 적은 확률이 아님!

-지금은 속도에 마찰이 없으니까 화면 위로 사라져버리니까 이제 마찰을 넣기로 함



7.마찰 넣기
-테일 클레스에 friction을 만들어 넣기
-업데이트 함수에서 vy에 friction을 누적해서 곱해넣기

->근데 이렇게만 한다면 꼬리가 화면 가운데에서 멈춰버림...
-조금 더 상단에서 멈추게 하고 싶다면 방법이 2가지가 있음

-프릭션을 약하게하거나
-vy값을 더 세게하면 됨

-우리는 프릭션값을 약하게 해서 올림
-그리고 각각 다른 vy값을 미세하게 조정하기로 함

-index.js의 craeteTail 에서 vy값을 고정값이 아닌 랜덤값으로 정해줄건데 이제 -15에서 -20사이의 값을 랜덤하게 넣어주기로 함



->이제 남은 문제! 화면의 높이를 줄여버리면... 화면 밖으로 나가버리거나... 속도가 너무 빨라보이거나..이런 문제가 발생함!
-이럴때엔 vy에 -15부터 -20사이의 고정값이 아닌! 화면 비율에 맞는 가변값을 주면 됨!
-이번에는 화면의 세로값만 고려하면돼서 캔버스높이값을 넣어서 랜덤값을 만듦!


->이제 거의 멈춰지는 시점에 불꽃이 터지게 만들면 됨!
-멈춰지는 시점 체크하는 곳! 바로 index.js에서 tials배열이 루프?가 되는 곳!
-테일즈 배열 돌며 업데이트,드로우 한 아래쪽에서!
꼬리의 속도가 거의 0이 되는 시점!에서 테일을 테일즈에서 스플라이스로 제거하고 크리에이트파티클로 파티클 만들어주면 됨!


->근데 이렇게 하면 현재 파티클은 랜덤한 위치에서 만들어져서 터지기 때문에....
꼬리가 사라지는 그 위치에서 터지지 않음!

-꼬리가 사라지는 시점의 xy값을 craete파티클즈 메서드 안에 넣어주면 됨!

-0이 되는 시점에서 크리에이트 파티클즈할 때 x와 y 값, 색상값까지 인자로 가지고 들어가도록 함

-그리고 크리에이트파티클즈 함수로 가서 파라미터로 xy색상을 넣은 후
기존에 있던 x,y값 지우면 바로 받아온 값을 가지고 인스턴스를 만들게 됨!

-그러고나서 파티클 클래스ㅔㅇ 가서 컬러값 받아와서 this.으로 받아주고
현재 rgb값으로 컬러를 만들기 떄문에 적어줄 때에도 rgb형태로 적어줘야 함!


8.다듬기
-먼저 꼬리가 멈추는 시점에 투명도도 0으로 수렴하게 만들기
-꼬리 클래스의 업데이트 함수 안에서 투명도 = - vy로 하면 처음에 음수로 시작하다가 점점 0으로 수렴하게 됨

-인덱스파일에서 보면 vy가 -1보다 커지는 시점에 폭죽 시작되니까.... 투명도 = -vy로 하면 0이 되기도 전에 파티클이 터져서 효과가 없음!

-그러면... 인덱스 파일의 꼬리 끝나는 시점에서 파티클 터지는 제어문에서! vy가 -0.7보다 커졌을떄라고 수정하고 
-꼬리 클래스의 업데이트메서드 안에서 -vy 뒤에 * 0.1 정도를 곱해주고,
-드로우 메서드 에서 fillstyle에서 rgba뒤에 알파 갑을 1 말고 위에 업데이트 메서드에서 정의한 투명도 값을 넣어주면!
-투명도가 잘 적용되서 마지막에 안보이게 됨!

->다음으로 꼬리가 일직선으로만 올라가니까 단순해보임!
-그래서 x값을 고정시켜서 일직선으로 올라가는 것이 아니라, 살짝 좌우로 흔들면서 올라가게 만들어보자


9.꼬리가 올라갈 때 좌우로 흔들리면서 올라가도록 만들기
--1과 1사이를 왔다갔다하는 값을 계속 더해주면 꼬불꼬불하면서 올라갈 것임
-이 값은... math.사인이나 코사인에서 가져오면 됨!
-우리는 math.코사인을 쓰기로 함!

-꼬리 클래스에 있는 업데이트 함수 안에서 this.y 정의 아래에 this.x += 코사인값 해주면 됨
-이때 필요한 각도값..을 컨스트럭터에 만들어주기
-그리고 업데이트 함수에서 앵글에 +=1씩 해주기
->근데 이렇게만 하면 값이 작아서 잘 보이지 않음

-그래서 한 20정도를 곱해주면.... 더 꼬불꼬불해지지만.... 끝까지 꼬불꼬불해서...이상함!

-우리가 원하는 것은! vy가 0으로 수렴할 때(멈출때) 이 꼬불한 정도도 0으로 수렴하면 좋음
-그러면 이제... 20대신에 this.vy를 곱해주고 꼬불한 정도를 좀 줄이기위해서 또 0.2를 곱하면?!
->그러면 격하게 꼬불거리다가 점점 직선이 되어서 없어지는 모습이 생김!

->이제 모두 같은 모양새니까 조금 랜덤한 느낌 주기위해서 컨스트럭터에서 정의한 앵글을 0~2사이 중 랜덤값이 나오게끔 해주면 보다 다양한 느낌이 듦!







