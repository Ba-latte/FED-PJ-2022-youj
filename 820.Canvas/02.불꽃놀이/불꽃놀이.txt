[ 불꽃 놀이 ]
1.보일러 플레이트의 두가지 방법
2.파티클과 폭죽의 기본 원리
3.파티클 원모양으로 만들업괴
4.불꽃놀이 꼬리 만들기
6.스파크 작업과 기타 꾸미기 작업


[ 보일러 플레이트의 두가지 방법 ]
-이번에는 모든 코드를 한번에 넣지 말고 각 파일로 클래스별로 나누어 작업하기로 함


가장먼저 해야할 것 : html에 만든 캔버스 요소 가져오기
그리고 캔버스 안에 있는 도구인 컨텍스트 를 써야하니까 가져오기

그리고 윈도우 전역 변수의 디바이스픽셀레이시오를 가져와서 dpr 설정하기


1.기본 세팅
// 02.불꽃놀이 - index.js

const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

const dpr = window.devicePixelRatio;

const fps = 60;
const interval = 1000 / fps;
let now, delta;
let then = Date.now();

// 캔버스 사이즈 미리 선언
let canvasWidth, canvasHeight;

// 초기화함수 만들기
function init(){
    // 캔버스 사이즈 담기
    canvasWidth = innerWidth;
    canvasHeight = innerHeight;

    // 캔버스 사이즈 담당하는 2가지 방법으로 사이즈 조절하기
    // 1.고유사이즈 지정하기
    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;
    ctx.scale(dpr, dpr);

    // 2.css로 강제로 늘리거나 줄이기
    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";
}


// animate 함수 만들기 : 이제 이걸 랜더라고 할 예정
function render(){
    // fps 개념 도입해서 모든 모니터에서 동일한 움직임 보이게 하기
    requestAnimationFrame(render);
    
    now = Date.now();
    delta = now - then;

    if(delta < interval) return;

    // 메인 로직 : 기본적인 fps 작업
    ctx.fillRect(100, 100, 200, 200);


    then = now - (delta % interval);
}



window.addEventListener("load", ()=>{
    init();
    render();
});

window.addEventListener("resize", ()=>{
    init();
});



2. 지금까지 작성한 보일러 플레이트를 각각 다른 파일로 만들어서 클래스로 만들어서 써볼 예정임
-스크래치로 빠르게 작업할 때 이 파일 필요할 수 있으니까 따로 파일로 만들어서 가지고 있기 추천함~!!


[ 보일러 플레이트 클래스로 만들기 ]
-먼저 class만들고 컨스트럭처 만들어서 그 안에 기본 고정값들 넣고 this세팅하기
-그리고 캔버스 사이즈 담아둔 변수도 가져와서 this세팅하기
:고정캔버스타겟사이즈 옮기기

-그리고 js파일 새로 만들고 그안에 옮기기 : 캔버스옵션.js

- 그리고 익스포트로 내보기

-그리고 캔버스 옵션 클래스를 부모 클래스로 상속받아온 캔버스 클래스를 만들기!
-자식 클래스의 constructor에서 super()를 쓰면 부모 클래스에서 정의한 변수, 메서드들을 this로 쉽게 가져다 쓸 수 있음

-그리고 이닛함수 그대로 복사해서 캔버스 클래스 안으로 옮겨주고 안으 ㅣ모든 값을 this처리하기

-그리고 랜더 함수도 그대로 가지고 들어오기

-그리고 상단에 가만 두었던 랜더 관련 변수들도 가지고 들어오기

-그리고 프레임 함수 만들어서 실행될 로직들 담고, render대신 프레임 넣기

-그리고 할당형 변수로 프레임 함수를 만들었기 때문에 아래쪽에서 최초 호출해주기

-이 정의한 클래스를 가지고 아래쪽에서 인스턴스 만들기





중복되는 필수 세팅을 보일러플레이트로 구성해서 기본 세팅하는 법 배움


[ 파티클과 폭죽의 기본원리 ]
-이제 파티클 만들기

1. 기본 세팅
-파티클.js파일을 만들고 기본 옵션 가져와서 써야하니까 상단에 임포트하기
-그리고 상속받아와서 파티클 클래스 만들기
-앞으로 파티클 다룰 때 기본적으로 사용할 메서드들인 업데이트, 드로우 함수 만들어두기

-주의할점은 상속받아오는 변수나 메서드 이런것들을 사용하기 위해서는 자식 클래스의 constructor에 super()를 써줘야 받아올 수 있음

-그리고 이 파티클 클래스도 꺼내서 다른 파일에서 써야 하므로 익스포트 시켜주기

-바깥에서 받아올 값인 x,y 인자로 쓰고 this.x,y로 좌표값 담아두기

-그리고 드로우 함수에서 그림 그리기
-원 그리는 기본 로직대로 짜기

-이제 캔버스 클래스의 컨스트럭터에서 여러 파티클들 만들어내서 담을 배열 만들기

-그리고 캔버스 클래스에서 파티클을 만들 메서드 만들기
그리고 파티클 개수 담을 변수 만들고 할당하고, 그 개수만큼 반복문 돌아서 new 해서 파티클 만들고 배열에다가 푸시로 담기!

-이 파티클 생성 함수를 이닛이 끝나면 젤 마지막에 실행되도록 아래에 적기!

-그럼 이제 this.파티클즈 배열 안에 1개가 들어갔으니까 1번만큼 그려지도록 랜더에서 그려지게 만들어ㅑㅇ함
-상자 그리는 코드 지우고 this.prticles를 forEach()문 돌아서 각 파티클을 업데이트, 드로우 함수 순서대로 실행시키기


[ 이제 파티클에 속도 붙여서 잘 움직이는지 확인하기 ]
-우선 만들어지고 그러고나서 움직이도록(?) 업데이트와 드로우를 따로 구분해두었으니까 이제 우리는 업데이트 함수에 가서 속도 붙일 것임
->이렇게만 하면 프레임 지우는 함수 넣지 않아서 계속 덮어 씌워져서 선이 그려짐;;

-이제 랜덤함수에 가서 리턴 밑에다가 캔버스 전체 지우는 클리어함수 넣을수 있지만..우리는 색상을 매 프레임 상단에 색칠해서 지우는 역할+배경색 역할하는 방식으로 하기로 함

-캔버스 배경 색도 옵션 클래스에 넣기

-그리고 랜더메서드로 돌아와서 프레임 함수 안에다가 리턴 아래쪽에서 클리어함수로 지워내고 만들고 지워내고 만들고 반복하는 방식으로 원을 떨어지는것 처럼 만드는 게 아니라
-계속 배경색을 덧칠해서 덮어씌우는 방식으로 원이 떨어지는 것처럼 만들기


-그리고 공 색도 잘보이게 바꾸기


-그리고 이제 파티클 만드는 곳으로 돌아가서 점을 랜덤 위치에 만들어 주도록 하기
-랜덤수 리턴하는 유틸성?함수가 있어야 함
-이제 랜덤수 만드는 함수 담을 파일 만들기

-거기에서 최소값, 최대값을 인자로 받아와서 그 사이에서 랜덤숫자를 리턴하는 함수 만들고 익스포트하기!

-그리고 파티클 만드는 함수에서 x값, y값을 랜덤수로 만들기



-이제 파티클 갯수 늘려서 여러개 만들기


-불꽃놀이를 만들려면..이제 파티클들이 한 점에서 동시에 시작해서 사방으로 퍼져야함
-그러면 x와 y가 처음 생성될때엔 같은 값으로 만들어졌다가 속도만 각각 다르게 만들면 됨

-우선 x,y를 for문 바깥으로 빼면 xy가 똑같아서 한 점에서 생성됨

-그리고 파티클 클래스의 컨스트럭터로 각각의 랜덤속도를 for문 안에서 생성해서 보내주면 됨


->10개라서 폭죽처럼 터지는 것 같지만,, 파티클을 2000개로 늘리면.... 폭죽이 원모양으로 퍼지는게 아니라 네모난 상자모양으로 퍼지게 됨

->또다른 문제! 공이 화면 밖으로 나가도 랜더 함수 안에서 보이지도 않는 2천개의 파티클에 애니메이션과 드로우를 계속 그려내고 있기 때문에, cpu에서 계속 돌아가므로 나중에 성능에 문제 될 수 있음

-그래서 이 파티클들을 없앨 것임

-퍼지기 전에 파티클들이 각각 투명도값을 가지고 있다가 파티클들이 퍼지면서 업데이트 로직이 실행될 때 투명도 값을 0으로 계속 감소시켜주다가 0이되면 파티클들배열에서 지워주면! 완전히 사라지게 됨!!

-우선 파티클 클래스에다 투명도 담을 변수 만들기
-처음에는 1로 초기화해주고 업데이트함수에서 투명도값을 점점 감소시킴

-그리고 현재 파티클 색상이 #fff로 되어 있으니까 이걸 rgba형식으로 바꿔주기
->이러면 이제 파티클들이 터지면서 투명하게 됨


-이제 배열에서 완전히 없애주기
-파티클들 배열에서 파티클을 각각 뽑아낸 후에 각 파티클을 업데이트하고 드로우 한 다음! 
-만약 어느 파티클이라도 투명도가 0보다 작아진다면 배열에서 빼낸다는 조건문을 걸기

-팁! 파티클들이 다 지워졌는지 확인하고 싶다면, 개발자도구에서 더보기>퍼포먼스 모니터에 들어가보면 CPU 사용량이 나옴
-계속 랜더하기 때문에 컴에 따라서 3퍼에서 5퍼가 기본으로 나올 것임
-만약 파티클 지우지 않은 상태라면 갑자기 cpu가 20퍼정도로 사용량이 늘어남



[ 폭죽 모양을 우리가 원하는 모양으로 만드는 법 ]
-폭죽 모양 제대로 구성하는 법

1.왜 폭죽이 사각형 모양으로 퍼젔을까?
-...그래프^^

2,동그란 모양으로 퍼지게 하는 원리
-vx,vy그래프에서 원 모양을 그릴 수 있다면...실제 x와 y값이 해당 값만큼 더해질테니까 퍼지는 것도 원 모양으로 퍼질 것임!
-그러면 우리는 반지름이 1인 원을 그리고 원의 라인을 따라서 점의 좌표를 알 수 있으면...문제 해결!

-원 둘레에 있는 점의 좌표는 반지름이 1이니까... 삼각형 그리면됨^^

-사인 코사인^^.....
-.......

-vx,vy값 구하기....
-랜덤 반지름 구하기
const r = randomNumBetween(0, 3);



[ 중력 적용하기 + 프릭션? 적용하기 ]
-아래로 떨어질 때 보다 자연스러워보임
-우주에서 불꽃놀이 하는것처럼 보이는게 아니라 속도가 0에 수렴하게 되면서 보다 자연스러워짐


-그럼 이제 파티클 클래스 안에서 중력값 변수에 담아서 만들어주고 업데이트 함수 위쪽에서 속도에다가 중력을 누적해서 더해주면 점점 아래로 빠르게 떨어짐

-또 마찰?을 부여해서 점점 느려지게 만들기

-index.js로 돌아와서 랜덤 r값이 0~3이라 원이 작게 만들어지니까 이제 값을 수정해서 크기 키움 -> 이때 0.2를 곱해주면 보다 중앙에서 뭉쳤다가 퍼지므로 보다 자연스러워짐

-그리고 모두 다같이 투명도가 같은 값으로 줄어드니까... 이제는 투명도도 랜덤으로 바뀌게 만들기
->그러면 이제 투명도를 다 똑같이 1부터 시작하는 게 아니라 랜덤값에서부터 시작하면 됨!

-파티클생성 함수로 가서 투명도도 랜덤으로 뽑아내서 만들게 하기


-그리고 이제 프레임함수로 돌아와서.. 계속 배경색을 덮어 씌우고 있는데 여기에 + '10'을 해주면 #000000 헥사코드 뒤에 + 10을 붙이게 되는 것이므로! rgba의 맨 마지막 값인 알파값(투명도)을 설정하게 되는 것임

-이렇게 하면 각 파티클이 매 프레임마다 움직이되 점차 잔상이 남는 형태로..만들어져서 폭죽처럼 됨 꼬리가 만들어지는 것처럼 됨

->즉, 투명도가 10밖에 안되니까 여러번 덧칠해야 완전한 검은색으로 덧칠해서 안보이게 만드는 것임!



-이제 또 한가지 문제! 작은 화면이나 큰 화면에서나 똑같은 사이즈!!
-화면크기 상관없이 비슷하게 만들어야 함

-만약 innerWidth를 써서 랜덤r을 구하게 되면... 화면 가로가 작아지거나 화면 가로가 클 때는 비슷한 사이즈 비율로 원을 만들 수 있어서 괜찮아보이지만
-세로 화면이 작아지면 그 문제 해결하지 못하고....
-innerHeight값을 써서 랜덤 r을 구하면 반대문제가 생김...

-따라서 우리는 피타고라스정의 통해서 빗변의 길이를 통해서...랜덤 반지름r을...구하도록 함^^...
-이걸 구하는 것은 유틸성 함수므로 그곳에다 만듬


[ 화면의 빗변 값을 구하는 함수 만들기 ]
-밑변과 높이를 받아와서 밑변의 제곱 더하기 높이의 제곱을 루트로 씌우면 됨!

-그리고 랜덤 r에다가 빗변구하는 함수를 곱하고 또 거기에 0.0001을 곱해주면 사이즈에 유동적으로 대응해서 적당한 크기의 폭죽이 만들어짐


[ 꼬리 만들기 ]
-



