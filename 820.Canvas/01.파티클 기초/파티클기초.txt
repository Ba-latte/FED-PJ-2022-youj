[ 캔버스 - 파티클 그리기 ]

클래스 함수를 통해서 x, y좌표와 사이즈값 등을 관리하는 방법과 그리는 방식 설명!

1.원그리기 개념
-arc()라는 함수 사용함
-중심을 기준으로 반지름만큼으로 떨어져 원하는 각도만큼 호를 그리는 방식임

2.순서
-먼저 그리기 아크라는 함수를 써서 그리기 전에! beginPath()라는 함수를 써서 이제 그리기 시작할 것이라고 알려줘야 함
인자 순서는 시작한느x위치, y위치, 반지름길이, 시작하는 각도, 끝나는 각도, 시계방향일지 반시계방향일지 를 넣어줌
-여기서 각도는 deg 단위를 쓰는 게 아니고 레디안(?)단위를 쓰기 때문에 따로 계산해서 넣어줘야 하는데 아래처럼 해주면 됨
-만약 360도를 쓰고 싶다면, Math.PI / 180 * 360 이라고 하면 됨
-각도 1도는 파이인 3.14를 180으로 나눈 값과 같기 때문에 라디안을 단위로 쓰는 곳에서 각도 쓰기 위해서는 이렇게 Math.PI / 180 한게 1도가 되니까 여기에 360을 곱해주느면 360도가 되는 것임!!

-시계방향은 기본값이 false라서 생략해도 무방함

-그리고 내부 색상을 채우고

-그리는 것을 끝낸다는 의미로 closePath() 함수 호출해서 마무리하기

->다른 도형도 마찬가지임

-그리고 fill로 색상 채우기 전에 fillStyle로 스타일을 먼저 바꿔줄 수도 있음

-이렇게 단순하게 캔버스에 그리기만하면.. 애니메이션 만들기는 어려움...

-프레임?애니메이션이 캔버스의 애니메이션 동작의 기본 원리임
: 한 컷 한컷 조금씩 그림을 달리하여 연결해서 보면 이어지는 모양처럼 보이게 하는 것

-우리가 그린 이 하나의 원을 파티클이라고 생각했을 때 한 프레임 프레임마다 원이 시작하는 x,y위치를 우리가 만든 수식에 의해서 다른 곳으로 옮겨주고 종합적으로 재생시키면 하나의 이펙트가 완성되는 것임

-이 파티클을 여러개를 동시에 관리하기 위해서는.. 자스의 클래스로 만들어서 이 클래스의 인스턴스들로 파티클을 만드는 방법임


3. 클래스로 여러 파티클 관리하기
-클래스로 파티클 관리할 메서드 정의하기

-컨스트럭터란 클래스의 인스턴스를 생성하고 초기화를 해주기위해서 필수적인 메서드
-예를들어 이 파티크 ㄹ클래스를 통해서 여러 원을 만들고싶은데 각각 다른 위치에 생성하기 위해서는 이 파티클클래스의 컨스트럭터 안에서 정의된 x,y값을 계속 각각 다르게 해서 만들면 됨

-그래서 컨스트럭터로 x값, y값, 반지름 값을 받아와서 클래스 내부에서 값을 접근하기 위해서 this.을 붙여서 일단 정의함
-원을 그리는 메서드 정의하고 위에서 배운 순서대로 원 그리기

-컨스트럭터 안에서 필요한 인자 3개였는데 이것을 미리 변수로 정의해서 만들어두기

->>이제 포문돌려서 여러 파티클을 다른위치 다른 크기의 인스턴스 생성하면 이걸 관리할 수 있게 된 것임

->>이제 애니메이션 효과를 주기 위해서 x,y좌표를 한프레임 한 프레임마다 옆으로 옮겨주려고 함
-이때 사용하는 함수는 animate함수임


4.애니메이션 효과 주기
-애니메이트 함수 정의하기
-윈도우.리퀘스트애니메이션프레임 함수 사용함
-여기에 아까 정의한 애니메이트 함수를 인자로 넣어주면 애니메이트 함수가 쭉 실행이 되고 다시 애니메이트 함수를 요청해서 또 실행되면서 매 프레임마다 무한으로 실행되는 함수가 만들어지게 됨
->이제 이 함수 안에서 파티클 값을 바꾸면 애니메이션이 만들어지는 것임

-애니메이션 함수에 아까 정의한 파티클인스턴스의 메서드를 써서 그림을 그리면 계속 그 위치에서 그림이 그려져서 덮어 씌워지는 형태로 동작됨

-이전 프레임을 지우고 새 프레임에서 새로 그리게 하기 위해선 제일 상단에 클리어 Rect라는 함수를 쓰면 됨
-이걸 쓰면 fillRect를 썼을떄와 똑같이 인자로 시작하는x,y위치값, 가로길이 세로길이를 순서대로 넣기
-이때 0, 0, canvasWidth, canvasHeight를 넣어주면 겉으로는 표가 나지 않지만, 매 프레임마다 전체 화면을 지우고, 다음 프레임에서 파티클 드로우 하는 작업을 반복하게 됨



[ 파티클에 애니메이션 부여해서 움직이게 만들기 ]
1.전역적으로 정의한 파티클 인스턴스 필수 인자들을 업데이트해서 움직임 부여할 예정


-리퀘스트 애니메이션 프레임을 보다 효율적으로 사용하기 
-리퀘스트 애니메이션을 애니메이션함수 안에서 무한히 실시간으로 실행시키면 1초에 몇 프레임이나 찍혀서 나오나? = 현재 모니터 디스플레이의 주사율을 기반으로하여 모니터마다 다르게 횟수가 찍혀서 나옴
-예르 ㄹ들어 요새 게이밍 노트북이나 모니터는 보통 144헤르쯔의 주사율을 가지고 있는데 리퀘스트애니메이션프레임에서는 1초에 144번 함수가 실행된다고 보면 됨

-그리고 보통 호사용 모니터나 일반 사우묭은 보통 60헤르쯔의 주사율을 가지고 있는데 이느 ㄴ애니메이트 함수  안에서 프레임함수가 1초에 60번 실행된다고 보면됨

-내가만든 애니메이션을 이 애니메이트 함수 안에서 1초에 x를 1px 움직이게 만들면 사용자의 모니터마다... 움직임이 다르게 나온다는 뜻임!

-그럼 내가 만든 코드가 모든 다른 주사율을 가진 모니터에서 같은 동작을 하게 하려면 어떻게 해야 할까?

-FPS의 개념에 대해 알아야 함


1.FPS
-프레임퍼세컨드의약자. 초당 프레임 횟수를 나타냄
-이 캔버스에 적용하면 1초에 리퀘스트 애니메이션 프레임을 몇번 실행시킬까라고 생각하면 됨

-여기서 자스 내장 객체인 date개겣 쓰면 이 문제 해겨 ㄹ가능

-내 모니터의 주사율이 60헤르쯔라고 가정하면, 1초에 60번 실행된다는 말임
-이걸 바꿔 말하면 약 16ms마다 프레임 함수가 실행된다는 뜻


-또 예를 들어서 내 애니메이션의 목표 fps = 10이라하면 1초에 10번 프레임을 찍으라는 뜻임
-바꿔 말하면 100ms마다 프레임함수를 실행시켜라

-이 100ms를 인터벌이란 변수에 담아서 생각하면 됨
-그럼 이제 16ms마다 실행되는데, 100ms마다 한번씩 실행되게 하려면 어떻게 해야하나?


-이것을 now, then, delta를 통해서 가능함

-now : 리퀘스트애니메이션프레임이 한번 실행될때마다 now 현재시간을 date.now로 나중에 가져올텐데 우선 시작하는 값을 1000이라고 가정

-그리고 프레임이 한번씩 찍힐때마다 내 모니터 주사율이 60헤르쯔니까 함수 1번이 16ms씩 간격을 두고 실행됨을 알수 있게 됨

-그래ㅓㅅ 횟수가 1씩 증가할때마다 16ms씩 증가함을 알 수 있음


-then 변수는 맨처음 한번 date.now로 현재시간 now와 똑같이 시작하지만 now-then값인 delta값이 횟수가 증가함에 따라서... 7번째 실행되면 now가 1112, then이 1100, delta값이 112가 됨을 알 수 있음

-여기서 델타값이 인터벌보다 커지는 시점... 이 조건이 실행된다는 것은 100ms마다 한번씩 애니메이션 시키라는 fps 조건이 성립된다는 뜻이니까 이때 애니메이션을 동작시켜주면 된다고 함
: if(delta > interval){애니메이션 동작!}


-이렇게 하고 나서 나머지인 12를 다시 적용시키면 then값은 now의 1112 - delta12..즉 1100이 되니까 다시 실행되기 시작함!
then = now - (delta % interval)

-이렇게 델타값이 인터벌보다 큰 값이 될 때 다시한번 애니메이션이 실행이 되고...

-이걸 반복하면 내가 설정한 값마다 애니메이션이 된다는 뜻


-내 모니터 주사율에 따라서 리퀘스트애니메이션프레임이 다른 횟수로 실행되지만 우리는 fps로 1초에 몇번 코드를 실행시킬지 정해서 이 나우와 덴값의 차이를 통해 모든 모니터에서 동일한 시각에 동일한 움직임을 보여줄 수 있음

-다만 fps가 높을수록 1초에 여러번 찍어낸다는 소리니까 더 부드러운 연출이 가능해짐

-요즘 기본 모니터는 60헤르쯔라서 보통 fps를 60으로 두면 된다고 생각하면 됨

-그럼 60 ~ 240헤르쯔까지 고사양 게이밍모니터까지 같은 시간, 같은 속도로 다만 부드러움에 차이가 있을 뿐 동일한 컨텐츠 제공할 수 있게 됨!!!







3.코드 작성
-



4.이제 움직임 부여하기
-파티클.y값에 1을 누적해서 추가해주면 1씩 증가해서 y값이 1씩 늘어나서 아래쪽으로 이동하게 됨

-이제 캔버스 사이즈를 전체 화면으로 바꿔주기

-이때 innerWidth, innerHeight를 넣어주면 됨

-클래스에다가 update 메서드 만들기
-이 함수 안에서 각각의 파티클들으 ㅣ컨스트럭터에서 초기화된 값을 변경시키는 작업을 하기로 함
-여기에서 y값에 1씩 더하는 로직 작성




->이제 랜덤함 속도로 y값 증가시키고 싶으면??
-업데이트 함수 안에 y+1하는 부분에서 1을 랜덤수로 바꿔주면 각각 다르 ㄴ속도로 떨어지게 함
그럼 이제 컨스트럭터에서 vy 즉 와이의 속도값을 변수로 측유화?해줘서 바깥에서 받아오게 하면 됨
-그리고 이제 파티클 만들 때 vy를 새로운 인자로 받아오면 되는데 파티클 만드는 걸 for문 돌려서 만들었으니까 거기에서 랜덤넘버비트윈으로 랜덤 수를 생성해서 인자로 넣어주면 됨



-그리고 이제 공이 바닥으로 다 떨어지면 다시 맨위의 하늘에서 생성되도록 만들기
-이미 만들어진 파티클들 배열을 forEach를 돌며 드로우로 그려내고 나서  if문으로  제어해주면됨
: 파티클의y값이 맨 아래값 즉, 캔버스의 높이값(상단이0 하단이 높이값이므로)보다 크면 아래로 내려갔다는 뜻임
그러면 공이 아래로 사라지면 파티클의 y값을 0으로 만들어서 상단으로 올리면 됨

-그런데 이렇게 하면, 엄밀히 말하면 조금 다른 점이 있음
-공의y-반지름값이 기준점이 됨..그래서 딱 절반정도가 사라지면 하늘로 올라버림...

-그리고 마찬가지로 자연스럽게 생성하기 위해서는y를 0으로 바꿔주는 것이 아니라 파티클의 반지름만큼 더 높은 점에서 만들어져야 자연스럽게 안보이는 하늘에서 만들어지는 것처럼 느껴짐!

-근데 이러면 랜덤한 느낌이 나지 않아서 좀 단조로운 느낌이 듦

-땅으로 떨어졌을 때 y값을 이동시켜주는것 뿐만아니라 이때 x값도 랜덤한 값으로 다시 설정해주고 vy도 랜덤으로 돌려주고 반지름도 랜덤으로 다시 설정해주면 더 좋음



[ 파티클에 가속도 주기 ]
-파티클의이동거리, 가속도를 줘서 매 프레임마다 일정 값을 더하거나 곱해줘서 파티클이 더 빠르거나 더 느리게 만드는 법 배우기

-공이 아래로 떨어질 때 점점 빨라지는 이유는 중력!

-우리가 아는 진짜 중력 대입시키는 건 아니고 간단하게 속도에 일정값을 더해서 가속도 만들기

-파티클 클래스 중 업데이트 메서드에서 이동한거리에 매 프레임마다 1~5씩 일정값을 더해주고 있었음

-점점더 빨라지기위해서는 위쪽에다가 속도에 1씩 더해주면 좀더 현실감있게 떨어지는 것처럼 보임
-이 1은 this.gravity, this.acc라고 보통 명명함

-우리는가속도... acc라고 명명해보기로 함

-처음에는 속도가 더 느렸다가 시간이 지날수록 더 빨리하고싶다면?? 속도에 1이상의 값을 곱해주면 더 가파르게 빨라짐
-따라서 속도에 매 프레임마다 1.5를 곱해보면...너무 빠르니까... 1.03정도 곱하면.... 자연스러움!

-그럼 반대로 1이하의 값을 곱해주면 예를 들어 0.98
이러면 자동차가 브레이크를 밟아서 멈추는 느낌으로 변화함
1이하의 값을 무한히 곱해주면 속도가 0으로 수렴하기 때문임
보통 이 마찰과 같은 개념으 ㅣ변수를 사용할때에는 this.fre..뭐?라고 명명하는 편임



[ svg 필터 입히기 ]
-파티클들이 서로 겹쳐진 부분에서는 끈적하게 서로 이어진 느낌 : 구이! (gooey)효과라고 함

1.구이 기본 원리!

-블러필터, 색상대비값을 점점 높여서 보여주는 콘트라스트 필터를 함께 사용하면 블러느낌이 안드는 것을 확인 가능함!!

-블러처리가되면서 불투명해지는 영역 즉 알파값이 들어간 요소에 대비값을 높여주면 알파값이 사라진 형태가 되는 것임
-그런데 요소가 하나가 아니라 여러개라면?!
-각각의 요소가 블러처리되면서 서로 겹치는 영역이 생김!
-대비값을 주게되면 겹쳐진 영역이 맞물리는 효과가 생기면서
-이게 젤리처럼 보이는 구이이펙트임

-간단하게 css에서 기본적으로 제공하는 것을 이용해서 함 만들어보기

-캔버스 css값에서 필터:블러값을 10px 주기
-추가로 contrast값을 10 주기

-그러면 이제 구이 이펙트가 생긴것처럼 됨

-근데 값을 높이면.... 더 강하게 젤리처럼 됨

-근데 이 css로 만든 이펙트의 단점은 배경색이 있어야 한다는 것임

-뒤의 배경색상에 따라서 우리가 원하는 파티클 색상이 아니라 대비되는 색상으로 변하는 것을 확인 가능함
-예를들어 배경색이 없으면 컨트라스트가 적용되지 않고 배경색이 있따면 원래의 색상인 오랜지가 나오는 게아니라 노란색으로 값이 바뀌는걸 확인 가능함
: 이때 뒤의 백그라운드색을 까만색으로 바꾸면 반전(?)되어버림....

-이렇듯, 배경색이 있어야해서 투명한 배경에서는 동작하지 않는 단점이 있음

-그래서 svg안에서 가지고 있는 필터 속성을 이용해서 이 css필터에 우리가 정의한 커스텀 필터르 ㄹ입혀주느 ㄴ방법이 있어서 이걸 사용하기로 함



2.만드는 법
-우선 html파일에서 캔버스 요소 아래쪽에 svg태그 넣고 그 안에 하위로 defs요소를 넣음
-defs요소는 재사용할수있도록 요소드를 정의할 때 사용됨
-이고셍 블러나 각종 필터 정의할수있음 또는 클리핑마스크오 ㅏ같이 마스킹처리할 때 마스키처리할 영역도 정의 가능
-그리고 서클이나 rect와 같은 태그를 바로 넣어서 사용하느 ㄴ것이 아니라 리액트에서 재사용위한 컴포넌트 정의하는 것처럼 이것도 미리 정의만 해둘수있다고 생각하면 됨

-재사용가능한 필터 정의하기
-필터 태그 넣고 id를 구이라고 지음
-여기에 우리는 블러 이펙트를 넣을 것임 이때 사용되는 svg필터 중 하나가 페가우시안...태그임
-보통 필터들을 정의하는 필터느 ㄴ앞에 fe라고 시작하게 됨
-여기에 아까 css에서 블러의 값이 픽셀에 따라 변경되었었는데 여기에서 값을 변경하는 부분은 std디비에이션이라는 속성으로 관리됨
-이 std어쩌고에 값을 숫자 하나만 넣을수도 있고 2개를 넣을수도 있는데 2개 넣으면 1번째는 가로의 블러값을 담당, 두번째값은 세로의 블러값을 담당함

-따라서 이미지 슬라이더에 속도가 빠른것처럼 보이게하기 위해서 이 블러에 가로갓만 활용해서 이미지 슬라이드를 만드는 예재들도 있으니까 검색해서 공부하는 것도 좋음

-그리고 값을 1개만 적으면 x와 y를 동시에 바꿔서 우리가 일반적으로 사용하는 블러 처리가 되는 것이라고 보면 됨

-이 필터가 어디에 입혀질 것인가도 넣어줘야 함
-기본적으로 in속성은 소스그래픽, 오리지날 그래픽에 주면 이 필터가 정의되어 사용되는 캔버스 엘리멘트에 다이렉트로 적용된다고 보면 됨
-그리고 리절트는 블러1이라고 줘서 이 필터의 이름을 블러1이라고 지어주는 것임


-이 필터를 css에서 사용하기 위해서는 간단하게, 필터 속성 쓴것처럼 값을 url에 아이디를 적으면 됨


-이제 여기에 대비효과주면 됨
-대비는 svg의 여러 필터중에서 fe컬러매트릭스라는 태그에서 변경 가능함
-in은 캔버스로 해주느 ㄴ것이 아니라 아까 블러으 ㅣ이름 즉 리절트로 정의한 블러1을 적으면 이 컬러 매트릭스에서 정의한 값을 블러에 적용해주게 됨

-그리고 모드를 매트릭스라고 주는데, 매트릭스 모드로 5*4행열형태로 된 매트릭스 값 안에서 일부값만 수정할 예정임

-다음으로 벨류즈에서 이 매트릭스값을 입력해주는데 기본적으로는 "1 0 0 0 0  0 1 0 0 0   0 0 1 0 0  0 0 0 1 0"과 같이 작성하면 됨

-매트릭스 기본값에서 아무 변경하지 않았기때문에 아무런 변화가 없는 상태임 지금은

-여기서 우리는 마지막 2칸만 바꿀 예정임
-첫번째는 20, 두번째는 -3정도로 바꿈

-std디비에이션? 블러값을 한 40정도로 주고 이 흐릿해진 상태에서 대비값을 더 강하게 줘서 선명하게 하면....
->>그러면 이 값들을 어떤 기준으로 바꾸냐??



-자세한건 강사도 이해하기어렵대^^....ㅋㅋ....
-마지막 2개만 바꾸면 색상 건들ㅈ ㅣ않고 구이효과를 조절가능하대

-플레이그라운드 사이트가 있음.....우리가 힘들게 테스트하지않아도 됨
-



[ dat.GUI 활용하기 ]
-수기로 값을 변경하면서 하는... 맘에 드는 환경 구성하기 어려운 것을 라이브러리 활용해서 값을 쉽게 테스트하는 환경 구성해보고자 함

-dat.GUI를 통해..우리가 원하는 애니메이션 효과 찾아내기


1.라이브러리 가져오기
-cdn통해서 가져오기
https://cdnjs.com/libraries/dat-gui

-먼저 스케일된 코드 아래쪽에 닷지유아이 가져오기
-먼저 dat.gui 컨트롤패널안에서  변화를 주기 위한 값들을 먼저 정의해줘야함
-new 함수의 인스턴스값에 담아서 변화를 줄 값을 담기
-gui메서드에서 사용될 값들을 여기서 this로 가져오기 때문에 변수명 앞에this.을 붙어야 함

-블러값을 적당히 담아서 초기값으로 설정해주기
-this.blurValue = 40; 이런식으로!

-그리고 콘트라스트값도 적어주는데... 매트릭스의값중에서 2개를 변경했는데, 순서대로 정의하도록 함
-this.alphaChannel이라고...그리고 매트릭스의 맨 마지막 값을 alphaOffset으로 명명해서 값을 넣어줌

-그리고 함수 바깥으로 나와서 gui를 선언해서 만들어주기
-현재는 담아둔 패널이 없어서 변화가 없는 것이고 하나씩 추가하면 됨

-패널 추가는 gui.add로 추가하면됨

-보통 4가지 인자를 넣어줌
-위에서 정의한 컨트롤스, 컨트롤스에서 사용한 변수 이름을 스트링형태로 넣어줌, 그리고 3번째와 4번째는 각각 테스트해볼 최솟값과 최대값을 넣으면 됨

-그리고 .onchange로 메서드체인으로 연결해서 값이 바뀌었을때 어떻게 동작시킬것인지도 추가함(실시간으로 바뀌도록)
-안에 콜백함수로 value를 가지고 들어가서 바뀐값을 리턴해주는데, 

-우리가 실제로 svg값을 콜백함수 안에서 변경해주며 ㄴ됨
-우선 가우시안 태그가져와야 그안으 ㅣ속성 변경가능....하니까... 전역적으로다가... 가우시안 태그 변수에 담아두기

-그리고 콜백으로 받아온 벨류값을 setAttribute로 

-벨류즈라는 한 속성안에서 두 값을 동시에 바꾸고있기 때문에 이렇게만 하면 한 값은 원래값으로 초기화되기 때문에.... 우리가 원하는대로 모든 값들이 다 종합적으로 적용한다거나 하는 그런 거는 안 됨... 따라서 위에는 마지막값을 컨트롤스.알파오프셋으로해주고 아래는 컨트롤스.알파채널로 해서 한 속성안의 두개으 ㅣ값이 한꺼번에 적용 되도록 함



-파티클 클래스 내의 자체적인 속성값도 변경할 수잇게 해보기
-그러면 이제 controls안에 this.acc를 써서 우리가 원래 쓰던 값을 초기값으로 담아주고
-gui에 패널을 추가해주면 됨
-이번에는 add()의 5번째 인자를 써볼건데.. step이라고 해서 얼마만큼씩 변화 줄 것인지를 정의 가능함
: acc는 소숫점 둘째자리까지있으니까 자세하게 테스트하려면 스텝으로 단계 조절하는 게 좋기 때문!
-그리고 가속도는..현재 생성되어 있는 파티클들에 모두에다가 적용해야하기 때문에 파티클즈를 foreach돌아야함...
-파티클을.acc에다가 인자로 받아온 벨류값을 넣어주면 됨



-이제 이걸 폴더 형식으로 만들면 더 깔끔하게 됨
-이럴떄는 애드폴더메서드를 쓰면 됨

-그리고 매번 폴더 열기 귀찮으면... 폴더가 열린 상태가 기본값으로 만들면됨
-폴더를 정의한 후 아래쪽에다가 폴더명.open()을 하면 폴더가 열린 상태가 기본값이 됨




[ 캔버스 리사이즈 다루기 ]
-화면 리사이즈했을 때 캔버스 사이즈가 자동으로 조절되지 않는 것을 자동으로 바뀌게 만들기!
-우리는 윈도우가 리사이즈될때마다 다시 캔버스가로,세로값을 새로운 값으로 바꿔주도록 함

-그리고 캔버스width와 height을 가지고 있는 모든 값들을 바꿔주면 됨

-이제 사이즈 초기화 함수 만듦



-그런데 화면이 커지면 파티클 갯수가 적어짐...
그러면이제 파티클 갯수를 화면 사이즈에 따라 가변적으로 정의하도록 하기

-토탈을 20이라는 정적인 숫자를 적는게 아니라
-상단으로 옮겨서 토탈을 캔버스width / 10을 해주면 밀도가 비슷한 결과가 나타남
